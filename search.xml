<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>阅读清单</title>
      <link href="/2024/09/09/%E9%98%85%E8%AF%BB%E6%B8%85%E5%8D%95/"/>
      <url>/2024/09/09/%E9%98%85%E8%AF%BB%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>node.js阅读笔记</title>
      <link href="/2024/09/09/node-js%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/09/09/node-js%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csapp阅读笔记</title>
      <link href="/2024/09/09/csapp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/09/09/csapp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="cssapp阅读笔记第一章"><a href="#cssapp阅读笔记第一章" class="headerlink" title="cssapp阅读笔记第一章"></a>cssapp阅读笔记第一章</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓开发</title>
      <link href="/2024/05/31/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91/"/>
      <url>/2024/05/31/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="安卓开发"><a href="#安卓开发" class="headerlink" title="安卓开发"></a>安卓开发</h1><p>安卓开发有两种方式： 混合开发，混合开发</p><p>混合开发好处： 跨端，用户体验不如原生开发</p><p>原生开发语言： kotlin和java</p><p>kotlin 比java更火，但是建议掌握java</p><p>kotlin 也是运行在jvm上的</p><p>布局文件用xml，会被compose替代</p><p>安卓当中使用的是 SQLite 进行数据管理，   </p><p>安卓组件组成： </p><ul><li><p>activitites ： 描述ui，并且处理用户与及其屏幕之间的交互</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends Activity &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>services： 处理与应用程序关联的后台操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyService extends Service &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务是运行在后台，执行长时间操作的组件</p><p>比如： 用户在使用不同的程序时在后台播放音乐， 或者在活动中通过网络获取数据但不阻塞用户交互</p></li><li><p>broadcast  recievers： 处理android操作系统和应用程序之间的通信</p><p>广播接收器 简单的相应从其他应用程序或者系统发来的广播消息， 举个例子， 应用程序可以发起广播来让其他应用程序知道以些数据已经被下载到设备， 广播其会拦截这些通信并且采取适当的行动， </p><p>广播接收器是broadcastReciver 的一个子类， 每个消息以Intent对象的形式进行广播</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyReceiver  extends  BroadcastReceiver &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>content providers： 处理数据和数据库管理 方面的问题</p><p>内容提供者组件通过请求从一个应用程序 到另一个应用程序提供数据吗这些请求 由 contentResolver 类方法来处理， 这些数据可以是存储在文件系统， 数据库或者其他地方</p></li></ul><p>附件组件</p><ul><li>Fragments ： 代表活动中的一个行为或者一部分用户界面</li><li>Views： 绘制在屏幕上的UI元素， 包括按钮，列表灯</li><li>layout： 屏幕控制格式， 展示视图外观的View继承</li><li>Intents： 组件之间的消息连线</li><li>Resources： 外部元素，例如字符串资源， 常量资源及图片</li><li>Mainfest： 应用的配置文件</li></ul><h3 id="声明周期"><a href="#声明周期" class="headerlink" title="声明周期"></a>声明周期</h3><table><thead><tr><th>onCreate()</th><th>这是第一个回调，在活动第一次创建时调用</th></tr></thead><tbody><tr><td>onStart()</td><td>这个回调在活动为用户可见时被调用</td></tr><tr><td>onResume()</td><td>这个回调在应用程序与用户开始可交互的时候调用</td></tr><tr><td>onPause()</td><td>被暂停的活动无法接受用户输入，不能执行任何代码。当前活动将要被暂停，上一个活动将要被恢复时调用</td></tr><tr><td>onStop()</td><td>当活动不在可见时调用</td></tr><tr><td>onDestroy()</td><td>当活动被系统销毁之前调用</td></tr><tr><td>onRestart()</td><td>当活动被停止以后重新打开时调用</td></tr></tbody></table><h2 id="安卓应用的工程目录结构"><a href="#安卓应用的工程目录结构" class="headerlink" title="安卓应用的工程目录结构"></a>安卓应用的工程目录结构</h2><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202406010112541.png" alt="image-20240601011241430"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202406011634167.png" alt="image-20240601163434055"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202406011634130.png" alt="image-20240601163456023"></p><h2 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h2><ul><li>Log.e: 表示错误信息</li><li>Log.w： 表示警告信息</li><li>Log.i ： 表示一般信息</li><li>Log.d： 表示调试信息</li><li>Log.v： 表示冗余信息</li></ul><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202406012028739.png" alt="image-20240601202802602"></p><h2 id="目录结构说明"><a href="#目录结构说明" class="headerlink" title="目录结构说明"></a>目录结构说明</h2><p>xml ： 放布局文件 &#x3D;&gt; html</p><p>java： 操作相应事件 &#x3D;&gt; javascript</p><h2 id="创建完整页面流程"><a href="#创建完整页面流程" class="headerlink" title="创建完整页面流程"></a>创建完整页面流程</h2><ul><li><p>在layout目录下创建xml文件</p><p> <img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202406012039944.png" alt="image-20240601203911904"></p></li><li><p>创建xml文件对应的java代码 ，必须要有</p><p>​这段代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_view_border);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>  <img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202406012038761.png" alt="image-20240601203858713"></p></li><li><p>在AndroidMainfest.xml 中注册页面配置</p></li></ul><p>​             <img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202406012038138.png" alt="image-20240601203847090"></p><p>或者直接点击创建activity</p><h2 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h2><p>过程： 就是在要进行跳转的页面中的java文件中写上跳转逻辑</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Button button=findViewById(R.id.button_first);</span><br><span class="line">       button.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onClick(View view) &#123;</span><br><span class="line">               Intent intent= new Intent();</span><br><span class="line">               intent.setClass(MainActivity.this,MainActivity2.class);</span><br><span class="line">             startActivity(intent);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p>下面是一个完整的示例，展示如何在 Android 活动中使用这段代码：</p><p>这样，当 <code>MainActivity</code> 启动时，它会立即启动 <code>MainActivity2</code>。在实际应用中，你可能希望将 <code>startActivity</code> 放在一个按钮点击事件或其他用户交互事件中，而不是 <code>onCreate</code> 方法中。</p><p> activity中的段代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">       android:id=&quot;@+id/button_first&quot;</span><br><span class="line">       android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">       android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">       android:text=&quot;点击跳转&quot;</span><br><span class="line">       /&gt;</span><br></pre></td></tr></table></figure><h2 id="简单控件"><a href="#简单控件" class="headerlink" title="简单控件"></a>简单控件</h2><h3 id="文本显示"><a href="#文本显示" class="headerlink" title="文本显示"></a>文本显示</h3><ul><li>设置文本的两种方式 ： xml 中 通过android：text设置文本</li></ul>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">    android:id=&quot;@+id/button_first&quot;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:text=&quot;点击跳转&quot;</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure><ul><li><p>在java代码中 通过调整 文本视图对象中的setText 方法设置文本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TextView tv = findViewById(R.id.tv);</span><br><span class="line">tv.setText(&quot;你好，卢红霞&quot;);</span><br><span class="line">Log.d(&quot;ning&quot;,&quot;成功&quot;);</span><br><span class="line">Button button=findViewById(R.id.button_first);</span><br><span class="line">button.setText(&quot;hh&quot;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="字体单位设置"><a href="#字体单位设置" class="headerlink" title="字体单位设置"></a>字体单位设置</h4><p>纯数字的setText方法，内部默认字号是sp， 印证了 sp是andoid 推荐的字号单位</p><p>主要是区分dp和sp</p><p>dp和sp是相对单位， sp可以根据系统的字体大小做变化</p><h4 id="设置字体颜色"><a href="#设置字体颜色" class="headerlink" title="设置字体颜色"></a>设置字体颜色</h4><p>setTextColor</p><p>可以设置为系统颜色，同时也支持， 16进制颜色设置</p><p><strong>支持8位16进制，6位16进制</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">android:textColor=&quot;@color/design_default_color_primary&quot;</span><br></pre></td></tr></table></figure><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202406012204431.png"></p><p>也可以在&#x2F;values&#x2F;color.XML&#x2F;中设置颜色</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202406012204431.png" alt="image-20240601220426205"></p><h3 id="视图基础"><a href="#视图基础" class="headerlink" title="视图基础"></a>视图基础</h3><h4 id="设置-视图宽高"><a href="#设置-视图宽高" class="headerlink" title="设置 视图宽高"></a>设置 视图宽高</h4><ul><li>match-parent： 表示与上级视图保持一致</li><li>warp-content： 表示与内容自适应</li><li>以dp位具体的单位尺寸</li></ul><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202406012239933.png" alt="image-20240601223921863"></p><p>或者</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> super.onCreate(savedInstanceState);</span><br><span class="line"> setContentView(R.layout.activity_view_border);</span><br><span class="line">TextView fill= findViewById(R.id.fill);</span><br><span class="line"> ViewGroup.LayoutParams params = fill.getLayoutParams();</span><br><span class="line"> params.width= Utils.dip2px(this,500);</span><br><span class="line"></span><br><span class="line"> fill.setLayoutParams(params);</span><br></pre></td></tr></table></figure><h3 id="设置视图间距"><a href="#设置视图间距" class="headerlink" title="设置视图间距"></a>设置视图间距</h3><p>layout_margin&#x2F;layout_pading</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202406012301300.png" alt="image-20240601230116236"></p><h3 id="常用布局"><a href="#常用布局" class="headerlink" title="常用布局"></a>常用布局</h3><h3 id="按钮触控"><a href="#按钮触控" class="headerlink" title="按钮触控"></a>按钮触控</h3><h3 id="图像显示"><a href="#图像显示" class="headerlink" title="图像显示"></a>图像显示</h3><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue的设计与实现</title>
      <link href="/2024/05/25/vue%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/05/25/vue%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h2 id="vue是声明式框架"><a href="#vue是声明式框架" class="headerlink" title="vue是声明式框架"></a>vue是声明式框架</h2><p>框架</p><ul><li>命令式框架： js去声明网页html 绑定点击事件&#x3D; 直接修改<ul><li>关注过程</li></ul></li><li>声明式框架<ul><li>关注结果： 一行解决&#x3D; 找出差异+直接修改</li></ul></li></ul><p>vue框架的特点</p><ul><li>声明式框架的性能不如命令式框架</li></ul><p>原因： 声明式框架是根据我们写得代码对其进行修改， 所以相比于命令式框架多了一个步骤， 所以命令式框架的性能不如声明式框架</p><p>只有当找出差异的性能消耗为0时，两者的消耗才完全相同</p><ul><li>可维护性比命令式框架强</li></ul><h3 id="为了提升了vue框架的性能，-vue采用-虚拟dom"><a href="#为了提升了vue框架的性能，-vue采用-虚拟dom" class="headerlink" title="为了提升了vue框架的性能， vue采用 虚拟dom"></a>为了提升了vue框架的性能， vue采用 虚拟dom</h3><p>虚拟dom： 创建js对象， 必要时dom更新</p><p>innerhtml： 渲染html 字符串， 销毁所有旧dom&#x2F;新建所有新的dom</p><p>所以 性能差异主要在创建js对象， dom性能优化的点就是 比较差异，必要时更新dom，但是innerhtml 需要全量更新，所以</p><p>innerhtml&lt; 虚拟dom&lt;原生js</p><p>vue框架&#x3D; 运行时+编译时框架</p><h2 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h2><p>把代码从动态项目，打包成静态的文件</p><p>把node.js模块化的代码，转化成浏览器可执行的代码</p><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><h3 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h3><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tools</title>
      <link href="/2024/05/19/tools/"/>
      <url>/2024/05/19/tools/</url>
      
        <content type="html"><![CDATA[<h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo hello // 控制台输出hello</span><br></pre></td></tr></table></figure><p>输出os上所有的路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $PATH </span><br></pre></td></tr></table></figure><p>“which echo”是一个命令行指令，用于查找系统中的可执行文件 “echo” 的路径。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">which echo</span><br></pre></td></tr></table></figure><p>打印当前路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><p>cd :改变当前路径</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd</span><br><span class="line">cd .. : 返回上层路径</span><br><span class="line">cd  ./XXX： 去到当前路径下某个子路径</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>展示当前路径下所有的文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls: 以rows方式显示</span><br><span class="line">ls  *.sh ：展示以sh方式结尾的文件</span><br><span class="line">ll： 以column的方式显示</span><br></pre></td></tr></table></figure><p> – help :</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取帮助</span><br><span class="line">ls --help</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ll -l ： 每行列出一个文件</span><br></pre></td></tr></table></figure><p>输入输出到文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo hello &gt; HELLO.TXT</span><br><span class="line">ECHO  &lt; HELLO.TXT :输出的控制台</span><br><span class="line">cat helo.TXT /cat &lt; HELLO.TXT； 打印到控制带</span><br></pre></td></tr></table></figure><p>curl命令访问网络：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl 是一个功能强大的命令行工具，用于在各种网络协议之间传输数据。它支持多种协议，包括HTTP、HTTPS、FTP、FTPS、SCP、SFTP、TFTP、LDAP、LDAPS、DICT、TELNET、FILE、IMAP、SMTP、POP3和RTMP等。</span><br></pre></td></tr></table></figure><p>grep ： 查找工具</p><h2 id="shell-工具"><a href="#shell-工具" class="headerlink" title="shell 工具"></a>shell 工具</h2><p>避免执行重复代码</p><h3 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h3><p>命名为 XXX.sh</p><p>$1： 代表第一个参数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MCD&#123;</span><br><span class="line">mkdir -P &quot;$1&quot;</span><br><span class="line">CD &quot;$1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何执行这段代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source mcd.sh</span><br><span class="line">$2~$9 ： 第2到第9个参数</span><br></pre></td></tr></table></figure><p>图片转换</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">convert image.png image.jpg</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建文件</p><p>touch  xxx</p><p>同样也可以在linux 当中直接运行python脚本</p><ul><li><p>python script.py</p></li><li><pre><code>#!/usr/bin/env python3print(&quot;Hello, World!&quot;)chmod +x script.py./script.py<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## git</span><br><span class="line"></span><br><span class="line">版本控制系统</span><br><span class="line"></span><br><span class="line">git 使用有向无环图来实现版本控制</span><br><span class="line"></span><br><span class="line">commit ： 需要提交的东西</span><br><span class="line"></span><br><span class="line">tree ： function</span><br><span class="line"></span><br><span class="line">### git命令演示</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul><p>git init ： 创建初始化仓库， 包括 文件系统， 指向历史版本指针的<br>git  status： git status 是一个用于显示当前 Git 仓库状态的命令<br>git add xxx ： 将文件从列出了未被 Git 追踪的文件，放到暂存区<br>git reset Head <file><br>git restor <file> :<br>git log –all –graph –decorate –oneline：显示提交分支的关系<br>git check out ： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">git status ：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$ git status<br>On branch main<br>Your branch is up to date with ‘origin&#x2F;main’.</p><p>Changes to be committed:<br>  (use “git reset HEAD <file>…” to unstage)<br>        modified:   file1.txt<br>        new file:   file2.txt</p><p>Changes not staged for commit:<br>  (use “git add <file>…” to update what will be committed)<br>  (use “git restore <file>…” to discard changes in working directory)<br>        modified:   file3.txt</p><p>Untracked files:<br>  (use “git add <file>…” to include in what will be committed)<br>        file4.txt</p><pre><code>git add xxx</code></pre><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>6.858网络安全相关知识</title>
      <link href="/2024/05/17/6-858%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/05/17/6-858%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="security"><a href="#security" class="headerlink" title="security"></a>security</h3><ul><li>policy , 协议 ，可以理解为规则</li><li>威胁模型</li><li>mechenism ： 机制 - 》 software&#x2F; sys</li></ul><h3 id="policy"><a href="#policy" class="headerlink" title="policy"></a>policy</h3><p> 登录网站的时候， 忘记密码； 会发送邮件， 如果忘记邮件密码， 需要重置密码， 会有一些问题 （ 朋友名字，之类 的） 帮助进入邮箱</p><p> 重置邮箱密码的例子：</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405180120287.png" alt="image-20240518012034177"></p><h3 id="mechanisim"><a href="#mechanisim" class="headerlink" title="mechanisim"></a>mechanisim</h3><p>机制错误的例子： </p><p>apple cloud 服务，</p><p>iCloud集成了很多接口，文件存储， 文件分享</p><p>登录界面， 密钥跟踪登录的次数；</p><p>花旗银行： </p><p>一个信用卡信息查询网站，没有权限验证，导致，更改信息即可重定向到任何人的信用卡</p><p>比特币： 知道私钥就可以消费比特币， 所以才对私钥就可以转让比特币</p><p>早期的ssl的编码问题</p><h3 id="强制缓存区溢出：-buffer-flows"><a href="#强制缓存区溢出：-buffer-flows" class="headerlink" title="强制缓存区溢出： buffer flows"></a>强制缓存区溢出： buffer flows</h3><p>缓冲区 ， 溢出： 栈种代码被覆盖</p><p>追求速度的 底层源码都是c语言， 这些缺陷源自于c语言本身</p><p>如和解决缓冲区溢出</p><ul><li>避免c代码的种的错误</li><li>构建工具， 允许程序员查找错误 - 静态分析</li><li>使用内存安全的程序语言编写代码 ，java， python ，c#<ul><li>遗留代码,不能用高级语言进行编写</li><li>低级访问硬件， 驱动程序之类的编写需要c</li><li>性能问题</li></ul></li></ul><h3 id="攻击者如何利用缓冲区溢出"><a href="#攻击者如何利用缓冲区溢出" class="headerlink" title="攻击者如何利用缓冲区溢出"></a>攻击者如何利用缓冲区溢出</h3><ul><li><p>获得对指令指针的控制</p></li><li><p>使指针指向恶意代码  </p><p>  <strong>如何解决</strong></p><ul><li><p>堆栈金丝雀： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">堆栈金丝雀（Stack Canary）是一种用于防止缓冲区溢出攻击的安全机制。在程序中，堆栈金丝雀是一种特殊的随机数或者特定值，被插入到函数的栈帧中的局部变量之后，但是在函数返回地址之前。</span><br><span class="line"></span><br><span class="line">当函数执行时，堆栈金丝雀的值会被记录在栈帧中。当函数执行完毕准备返回时，系统会检查堆栈金丝雀的值是否被篡改。如果堆栈金丝雀的值被篡改了，说明发生了缓冲区溢出攻击，程序会立即终止或者采取其他的安全措施。</span><br><span class="line"></span><br><span class="line">堆栈金丝雀可以有效地防止缓冲区溢出攻击，因为攻击者在进行溢出时很难预测到堆栈金丝雀的值，而且攻击者无法直接修改堆栈金丝雀的值，因为它位于函数栈帧中的局部变量之后，攻击者只能通过覆盖局部变量的方式来修改堆栈金丝雀的值，但是这样做会破坏堆栈结构并导致程序异常终止。</span><br></pre></td></tr></table></figure></li><li><p>边界检查： bounds-checking</p></li></ul></li></ul><h2 id="控制劫持攻击"><a href="#控制劫持攻击" class="headerlink" title="控制劫持攻击"></a>控制劫持攻击</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>软件体系结构</title>
      <link href="/2024/05/05/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/2024/05/05/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405052326075.png" alt="image-20240505232645008"></p><h3 id="软件体系结构定义"><a href="#软件体系结构定义" class="headerlink" title="软件体系结构定义"></a>软件体系结构定义</h3><ul><li><p>组成派： 关注于软件本身， 将软件体系结构看作<strong>构件和交互</strong>的集合</p></li><li><p>决策派： 关注于软件架构中的实体，将软件体系结构视为一系<strong>列重要决策</strong>的集合</p></li></ul><p>软件体系结构三大要素： 组件+ 连接件+ 约束</p><p>组件： 一组代码也可以是独立的程序</p><p>连接件： 表示组件之间的相互关系，可以是过程调用，管道和消息</p><p>约束： 为组件连接时的条件</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405052334357.png" alt="image-20240505233416272"></p><h2 id="数据流体系结构风格"><a href="#数据流体系结构风格" class="headerlink" title="数据流体系结构风格"></a>数据流体系结构风格</h2><p>简单例子： 无数据不工作（数据激活）</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405052340332.png" alt="image-20240505234000276"></p><p>连接件： 数据流</p><p>批处理体系结构风格</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405052341839.png" alt="image-20240505234126782"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405052341745.png" alt="image-20240505234155684"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405052343124.png" alt="image-20240505234315076"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405052343899.png" alt="image-20240505234326846"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405052344700.png" alt="image-20240505234404654"></p><h2 id="调用返回体系结构风格"><a href="#调用返回体系结构风格" class="headerlink" title="调用返回体系结构风格"></a>调用返回体系结构风格</h2><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405052346028.png" alt="image-20240505234559976"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405052346575.png" alt="image-20240505234651535"></p><h2 id="以数据为中心体系结构风格"><a href="#以数据为中心体系结构风格" class="headerlink" title="以数据为中心体系结构风格"></a>以数据为中心体系结构风格</h2><h2 id="虚拟机体系结构风格"><a href="#虚拟机体系结构风格" class="headerlink" title="虚拟机体系结构风格"></a>虚拟机体系结构风格</h2><h2 id="事件体系结构风格"><a href="#事件体系结构风格" class="headerlink" title="事件体系结构风格"></a>事件体系结构风格</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>自主可控嵌入式系统设计</title>
      <link href="/2024/05/05/%E8%87%AA%E4%B8%BB%E5%8F%AF%E6%8E%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/05/05/%E8%87%AA%E4%B8%BB%E5%8F%AF%E6%8E%A7%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="自主可控嵌入式系统设计"><a href="#自主可控嵌入式系统设计" class="headerlink" title="自主可控嵌入式系统设计"></a>自主可控嵌入式系统设计</h2><h2 id="第一周："><a href="#第一周：" class="headerlink" title="第一周："></a>第一周：</h2><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405052315284.png" alt="image-20240505231510049"></p><p>四次实验可以一起做，也可以分开做</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061607454.png" alt="image-20240506160711152"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061610177.png" alt="image-20240506161046026"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061618967.png" alt="image-20240506161850888"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061622004.png" alt="image-20240506162233858"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061627204.png" alt="image-20240506162724085"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061630974.png" alt="image-20240506163026856"></p><h2 id="第二周"><a href="#第二周" class="headerlink" title="第二周"></a>第二周</h2><h3 id="常见嵌入式处理器结构和技术"><a href="#常见嵌入式处理器结构和技术" class="headerlink" title="常见嵌入式处理器结构和技术"></a>常见嵌入式处理器结构和技术</h3><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061639646.png" alt="image-20240506163905615"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061639570.png" alt="image-20240506163930483"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061646891.png" alt="image-20240506164626743"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061649492.png" alt="image-20240506164927295"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061653385.png" alt="image-20240506165308260"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061659672.png" alt="image-20240506165956442"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061708630.png" alt="image-20240506170841477"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061709633.png" alt="image-20240506170951499"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061710451.png" alt="image-20240506171011273"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061715328.png" alt="image-20240506171532213"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061721353.png" alt="image-20240506172105267"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061723919.png" alt="image-20240506172333720"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061726266.png" alt="image-20240506172607978"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061729855.png" alt="image-20240506172906671"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061730942.png" alt="image-20240506173006812"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061840683.png" alt="image-20240506184023522"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061840618.png" alt="image-20240506184039481"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061854816.png" alt="image-20240506185436638"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061858189.png" alt="image-20240506185837940"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061859929.png" alt="image-20240506185909734"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061901205.png" alt="image-20240506190110078"></p><h2 id="第三周"><a href="#第三周" class="headerlink" title="第三周"></a>第三周</h2><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061916529.png" alt="image-20240506191632438"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061916579.png" alt="image-20240506191658496"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405061920517.png" alt="image-20240506192012343"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405062021081.png" alt="image-20240506202140988"></p><h2 id="第五周"><a href="#第五周" class="headerlink" title="第五周"></a>第五周</h2><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405062341112.png" alt="image-20240506234151949"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405071642315.png" alt="image-20240507164228211"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405071642890.png" alt="image-20240507164238695"></p><h2 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h2><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405071647219.png" alt="image-20240507164736016"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405071649185.png" alt="image-20240507164945052"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405071650564.png" alt="image-20240507165035454"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405071652945.png" alt="image-20240507165207839"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405071658438.png" alt="image-20240507165811335"></p><h2 id="第11周"><a href="#第11周" class="headerlink" title="第11周"></a>第11周</h2><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405091119246.png" alt="image-20240509111909127"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405091131877.png" alt="image-20240509113109721"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计网和操作系统</title>
      <link href="/2024/04/23/%E8%AE%A1%E7%BD%91%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/04/23/%E8%AE%A1%E7%BD%91%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>OSI七层模型，TCP&#x2F;IP5层模型，五层结构</p><p>OSI:</p><p>应用层</p><p>表示层</p><p>会话层应用层应用层</p><p>传输层传输层传输层</p><p>网络层网络层网络层</p><p>数据链路层     数据链路层</p><p>物理层          网络接口层      物理层</p><p>七层网络模型的对应的功能：</p><p>物理层：</p><p> 透明比特流的传输</p><p>数据链路层： </p><p>将数据无差错的传输给网络层</p><p>网络层：</p><p>将各个分组从源地址传输到目的地址（逻辑寻址，路由选择）</p><p>传输层： 负责报文从一个进程到另一个进程</p><p>会话层： 负责会话的同步和控制</p><p>表示层： 翻译，加密压缩数据</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自我介绍</title>
      <link href="/2024/04/22/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"/>
      <url>/2024/04/22/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>面试官你好，我是西安电子科技大学的大三软件工程在读的学生， 然后在校期间，获得过国家励志奖学金，院级优秀学生，同时积极参加竞赛，比如数学建模比赛，国赛，美赛等比赛，拿过省一的成绩。然后基于hexo搭建过一个个人博客， 上面有部分自己学的部分博客。然后我之前是一名后端工程师，入门语言是java，学过一些后端的框架， 然后做过一些后端的项目，但是在投递简历的过程当中，发现后端竞争比较大，一直没有面试，所以转了前端，目前正在学习前端相关的知识。</p><h2 id="博客需要写好一点"><a href="#博客需要写好一点" class="headerlink" title="博客需要写好一点"></a>博客需要写好一点</h2><h2 id="跨域如何解决"><a href="#跨域如何解决" class="headerlink" title="跨域如何解决"></a>跨域如何解决</h2><p>cors， jsonp， nginx反向代理，</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>fpga</title>
      <link href="/2024/04/21/fpga/"/>
      <url>/2024/04/21/fpga/</url>
      
        <content type="html"><![CDATA[<h2 id="FPGA实验"><a href="#FPGA实验" class="headerlink" title="FPGA实验"></a>FPGA实验</h2><p><img src="C:\Users\86198\AppData\Roaming\Typora\typora-user-images\image-20240502201128202.png" alt="image-20240502201128202"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405022016106.png" alt="image-20240502201638002"></p><p>百分比可调整</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405022034577.png" alt="image-20240502203451483"></p><h2 id="语言-：VHDL"><a href="#语言-：VHDL" class="headerlink" title="语言 ：VHDL"></a>语言 ：VHDL</h2><p>例子</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405041050416.png" alt="image-20240504105002055"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405041050380.png" alt="image-20240504105023223"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405041052222.png" alt="image-20240504105207049"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405041058371.png" alt="image-20240504105830162"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405041111144.png" alt="image-20240504111103062"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405042027624.png" alt="image-20240504202754332"></p><p>变量数据类型</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405042029367.png" alt="image-20240504202945198"></p><p>后仿真流程</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405050138988.png" alt="image-20240505013820559"></p><p>第7周第1，2节</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;2&quot;, </span><br><span class="line">    &quot;videoPath&quot;: &#123;</span><br><span class="line">        &quot;pptVideo&quot;: &quot;http://202.117.115.64:8092/file/cloud://10.168.76.10:6201/HIKCLOUD/accessid/NUVQYWFpMEp6c0ppVVJkdFVMbDc5N3VVZjU1MWw4Szc2ODEyOGYyejdHNzkxN2FJMlhYNmQyNzQ0ZDNpTDM2/accesskey/a3gxcEs3SVNiN1lCeTFoOW80OThPb3o4N3I3R3hBQnpFajY3NUk3NVJ6VDdUNDdubTQ4UzQxNDUwN3RRZDJN/bucket/bucket/key/2e317772778c48a0b393449d803636d0/1/1712898309/1712901608/0/playback.m3u8&quot;, </span><br><span class="line">        &quot;teacherTrack&quot;: &quot;http://202.117.115.68:8092/file/cloud://10.168.76.10:6201/HIKCLOUD/accessid/NUVQYWFpMEp6c0ppVVJkdFVMbDc5N3VVZjU1MWw4Szc2ODEyOGYyejdHNzkxN2FJMlhYNmQyNzQ0ZDNpTDM2/accesskey/a3gxcEs3SVNiN1lCeTFoOW80OThPb3o4N3I3R3hBQnpFajY3NUk3NVJ6VDdUNDdubTQ4UzQxNDUwN3RRZDJN/bucket/bucket/key/1b8537452a7a40929b1fbfbd5281fdcf/1/1712899280/1712902578/0/playback.m3u8&quot;, </span><br><span class="line">        &quot;studentFull&quot;: &quot;http://202.117.115.68:8092/file/cloud://10.168.76.10:6201/HIKCLOUD/accessid/NUVQYWFpMEp6c0ppVVJkdFVMbDc5N3VVZjU1MWw4Szc2ODEyOGYyejdHNzkxN2FJMlhYNmQyNzQ0ZDNpTDM2/accesskey/a3gxcEs3SVNiN1lCeTFoOW80OThPb3o4N3I3R3hBQnpFajY3NUk3NVJ6VDdUNDdubTQ4UzQxNDUwN3RRZDJN/bucket/bucket/key/6d3a49b2bf834ce982014cc4b2518578/1/1712900269/1712903580/0/playback.m3u8&quot;</span><br><span class="line">    &#125;, </span><br><span class="line">    &quot;liveId&quot;: 11759294</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;videoPath&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pptVideo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://202.117.115.72:8092/file/cloud://10.168.76.10:6201/HIKCLOUD/accessid/NUVQYWFpMEp6c0ppVVJkdFVMbDc5N3VVZjU1MWw4Szc2ODEyOGYyejdHNzkxN2FJMlhYNmQyNzQ0ZDNpTDM2/accesskey/a3gxcEs3SVNiN1lCeTFoOW80OThPb3o4N3I3R3hBQnpFajY3NUk3NVJ6VDdUNDdubTQ4UzQxNDUwN3RRZDJN/bucket/bucket/key/6e15ded4ec85426da6ba651f8c0ab66d/1/1712909290/1712912287/0/playback.m3u8&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;teacherTrack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://202.117.115.72:8092/file/cloud://10.168.76.10:6201/HIKCLOUD/accessid/NUVQYWFpMEp6c0ppVVJkdFVMbDc5N3VVZjU1MWw4Szc2ODEyOGYyejdHNzkxN2FJMlhYNmQyNzQ0ZDNpTDM2/accesskey/a3gxcEs3SVNiN1lCeTFoOW80OThPb3o4N3I3R3hBQnpFajY3NUk3NVJ6VDdUNDdubTQ4UzQxNDUwN3RRZDJN/bucket/bucket/key/215124e111f34dff90c97a1027573c3e/1/1712910151/1712913148/0/playback.m3u8&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;studentFull&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://202.117.115.72:8092/file/cloud://10.168.76.10:6201/HIKCLOUD/accessid/NUVQYWFpMEp6c0ppVVJkdFVMbDc5N3VVZjU1MWw4Szc2ODEyOGYyejdHNzkxN2FJMlhYNmQyNzQ0ZDNpTDM2/accesskey/a3gxcEs3SVNiN1lCeTFoOW80OThPb3o4N3I3R3hBQnpFajY3NUk3NVJ6VDdUNDdubTQ4UzQxNDUwN3RRZDJN/bucket/bucket/key/11babed651a54b90b17f65663f09e007/1/1712910792/1712913790/0/playback.m3u8&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;liveId&quot;</span><span class="punctuation">:</span> <span class="number">11759295</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>第8周第一节</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;videoPath&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pptVideo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://202.117.115.54:8092/file/cloud://10.168.76.10:6201/HIKCLOUD/accessid/NUVQYWFpMEp6c0ppVVJkdFVMbDc5N3VVZjU1MWw4Szc2ODEyOGYyejdHNzkxN2FJMlhYNmQyNzQ0ZDNpTDM2/accesskey/a3gxcEs3SVNiN1lCeTFoOW80OThPb3o4N3I3R3hBQnpFajY3NUk3NVJ6VDdUNDdubTQ4UzQxNDUwN3RRZDJN/bucket/bucket/key/07ae2b8cf8534a45bd190ada90fc08d9/1/1713502303/1713505601/0/playback.m3u8&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;teacherTrack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://202.117.115.54:8092/file/cloud://10.168.76.10:6201/HIKCLOUD/accessid/NUVQYWFpMEp6c0ppVVJkdFVMbDc5N3VVZjU1MWw4Szc2ODEyOGYyejdHNzkxN2FJMlhYNmQyNzQ0ZDNpTDM2/accesskey/a3gxcEs3SVNiN1lCeTFoOW80OThPb3o4N3I3R3hBQnpFajY3NUk3NVJ6VDdUNDdubTQ4UzQxNDUwN3RRZDJN/bucket/bucket/key/f44dd4abd21e49eda7c71d441a54b212/1/1713502984/1713506280/0/playback.m3u8&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;studentFull&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://202.117.115.54:8092/file/cloud://10.168.76.10:6201/HIKCLOUD/accessid/NUVQYWFpMEp6c0ppVVJkdFVMbDc5N3VVZjU1MWw4Szc2ODEyOGYyejdHNzkxN2FJMlhYNmQyNzQ0ZDNpTDM2/accesskey/a3gxcEs3SVNiN1lCeTFoOW80OThPb3o4N3I3R3hBQnpFajY3NUk3NVJ6VDdUNDdubTQ4UzQxNDUwN3RRZDJN/bucket/bucket/key/038e6311a2ed4718a157789fafac2626/1/1713503804/1713507099/0/playback.m3u8&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;liveId&quot;</span><span class="punctuation">:</span> <span class="number">11759296</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>第8周第二节</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;videoPath&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pptVideo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://202.117.115.54:8092/file/cloud://10.168.76.10:6201/HIKCLOUD/accessid/NUVQYWFpMEp6c0ppVVJkdFVMbDc5N3VVZjU1MWw4Szc2ODEyOGYyejdHNzkxN2FJMlhYNmQyNzQ0ZDNpTDM2/accesskey/a3gxcEs3SVNiN1lCeTFoOW80OThPb3o4N3I3R3hBQnpFajY3NUk3NVJ6VDdUNDdubTQ4UzQxNDUwN3RRZDJN/bucket/bucket/key/57c053c0c5344b1d94086f625e671546/1/1713510703/1713513702/0/playback.m3u8&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;teacherTrack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://202.117.115.54:8092/file/cloud://10.168.76.10:6201/HIKCLOUD/accessid/NUVQYWFpMEp6c0ppVVJkdFVMbDc5N3VVZjU1MWw4Szc2ODEyOGYyejdHNzkxN2FJMlhYNmQyNzQ0ZDNpTDM2/accesskey/a3gxcEs3SVNiN1lCeTFoOW80OThPb3o4N3I3R3hBQnpFajY3NUk3NVJ6VDdUNDdubTQ4UzQxNDUwN3RRZDJN/bucket/bucket/key/b05e9f6e20074caca9030020561b9885/1/1713511214/1713514210/0/playback.m3u8&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;studentFull&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://202.117.115.54:8092/file/cloud://10.168.76.10:6201/HIKCLOUD/accessid/NUVQYWFpMEp6c0ppVVJkdFVMbDc5N3VVZjU1MWw4Szc2ODEyOGYyejdHNzkxN2FJMlhYNmQyNzQ0ZDNpTDM2/accesskey/a3gxcEs3SVNiN1lCeTFoOW80OThPb3o4N3I3R3hBQnpFajY3NUk3NVJ6VDdUNDdubTQ4UzQxNDUwN3RRZDJN/bucket/bucket/key/ca8c74af970d406bb68cad27a934bc4a/1/1713511994/1713514989/0/playback.m3u8&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;liveId&quot;</span><span class="punctuation">:</span> <span class="number">11759297</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>第9周第1节</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;videoPath&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pptVideo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://202.117.115.54:8092/file/cloud://10.168.76.10:6201/HIKCLOUD/accessid/NUVQYWFpMEp6c0ppVVJkdFVMbDc5N3VVZjU1MWw4Szc2ODEyOGYyejdHNzkxN2FJMlhYNmQyNzQ0ZDNpTDM2/accesskey/a3gxcEs3SVNiN1lCeTFoOW80OThPb3o4N3I3R3hBQnpFajY3NUk3NVJ6VDdUNDdubTQ4UzQxNDUwN3RRZDJN/bucket/bucket/key/6c39a3bc55ca421289862dac74a8bab6/1/1714103127/1714106425/0/playback.m3u8&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;teacherTrack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://202.117.115.54:8092/file/cloud://10.168.76.10:6201/HIKCLOUD/accessid/NUVQYWFpMEp6c0ppVVJkdFVMbDc5N3VVZjU1MWw4Szc2ODEyOGYyejdHNzkxN2FJMlhYNmQyNzQ0ZDNpTDM2/accesskey/a3gxcEs3SVNiN1lCeTFoOW80OThPb3o4N3I3R3hBQnpFajY3NUk3NVJ6VDdUNDdubTQ4UzQxNDUwN3RRZDJN/bucket/bucket/key/6e300d5705ad4259b825260221e987c6/1/1714103520/1714106818/0/playback.m3u8&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;studentFull&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://202.117.115.54:8092/file/cloud://10.168.76.10:6201/HIKCLOUD/accessid/NUVQYWFpMEp6c0ppVVJkdFVMbDc5N3VVZjU1MWw4Szc2ODEyOGYyejdHNzkxN2FJMlhYNmQyNzQ0ZDNpTDM2/accesskey/a3gxcEs3SVNiN1lCeTFoOW80OThPb3o4N3I3R3hBQnpFajY3NUk3NVJ6VDdUNDdubTQ4UzQxNDUwN3RRZDJN/bucket/bucket/key/b1e744cbdc2d421191cecf85a88198d3/1/1714104046/1714107344/0/playback.m3u8&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;liveId&quot;</span><span class="punctuation">:</span> <span class="number">11759298</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>第9周第二节</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;videoPath&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pptVideo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://202.117.115.54:8092/file/cloud://10.168.76.10:6201/HIKCLOUD/accessid/NUVQYWFpMEp6c0ppVVJkdFVMbDc5N3VVZjU1MWw4Szc2ODEyOGYyejdHNzkxN2FJMlhYNmQyNzQ0ZDNpTDM2/accesskey/a3gxcEs3SVNiN1lCeTFoOW80OThPb3o4N3I3R3hBQnpFajY3NUk3NVJ6VDdUNDdubTQ4UzQxNDUwN3RRZDJN/bucket/bucket/key/98d24f0611334dd085c1bb8ca83c478d/1/1714108816/1714111814/0/playback.m3u8&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;teacherTrack&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://202.117.115.54:8092/file/cloud://10.168.76.10:6201/HIKCLOUD/accessid/NUVQYWFpMEp6c0ppVVJkdFVMbDc5N3VVZjU1MWw4Szc2ODEyOGYyejdHNzkxN2FJMlhYNmQyNzQ0ZDNpTDM2/accesskey/a3gxcEs3SVNiN1lCeTFoOW80OThPb3o4N3I3R3hBQnpFajY3NUk3NVJ6VDdUNDdubTQ4UzQxNDUwN3RRZDJN/bucket/bucket/key/9410f8a59a6245a1842aa24618a63782/1/1714109433/1714112434/0/playback.m3u8&quot;</span><span class="punctuation">,</span> </span><br><span class="line">        <span class="attr">&quot;studentFull&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://202.117.115.54:8092/file/cloud://10.168.76.10:6201/HIKCLOUD/accessid/NUVQYWFpMEp6c0ppVVJkdFVMbDc5N3VVZjU1MWw4Szc2ODEyOGYyejdHNzkxN2FJMlhYNmQyNzQ0ZDNpTDM2/accesskey/a3gxcEs3SVNiN1lCeTFoOW80OThPb3o4N3I3R3hBQnpFajY3NUk3NVJ6VDdUNDdubTQ4UzQxNDUwN3RRZDJN/bucket/bucket/key/8a0fdf0410bc456ead08432a65388363/1/1714109962/1714112960/0/playback.m3u8&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;liveId&quot;</span><span class="punctuation">:</span> <span class="number">11759299</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>第10周第一节</p><p>第10周第二节</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202405052052886.png" alt="image-20240505205235583"></p><h2 id="第11周"><a href="#第11周" class="headerlink" title="第11周"></a>第11周</h2><p>节拍 ：状态节拍</p><p>​ 时钟的节拍</p><p><strong>最大工作频率</strong>是什么：</p><p>  时钟的频率紧密相关</p><p>RTL点击仿真的时候</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>检测</title>
      <link href="/2024/04/21/%E6%A3%80%E6%B5%8B/"/>
      <url>/2024/04/21/%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="笔试题目"><a href="#笔试题目" class="headerlink" title="笔试题目"></a>笔试题目</h2><h2 id="元素居中的几种方式"><a href="#元素居中的几种方式" class="headerlink" title="元素居中的几种方式"></a>元素居中的几种方式</h2><p>方式1： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 500px;</span><br><span class="line">    background-color: #ccc;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.box&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform: translate(-50%,-50%);</span><br><span class="line">    background-color: #6f42c1;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式2： flex布局</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">       width: 500px;</span><br><span class="line">       height: 500px;</span><br><span class="line">       display: flex;</span><br><span class="line">       background-color: #20c997;</span><br><span class="line">       justify-content: center;</span><br><span class="line">   &#125;</span><br><span class="line">   .box&#123;</span><br><span class="line">       background-color: #6f42c1;</span><br><span class="line">       width: 100px;</span><br><span class="line">       height: 100px;</span><br><span class="line">       align-self: center;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p>脱离文档标准流到指定位置</p><p>清除浮动就是闭合父元素，不让内部元素，出来影响其他元素</p><p>方法： </p><p>额外标签法：<strong>通过在浮动元素的末尾添加一个空的标签</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</span><br><span class="line">2. .clear &#123; clear:both &#125;</span><br><span class="line">    &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;</span><br><span class="line">3..clear&#123; clear:both &#125;</span><br><span class="line">    &lt;br class=&quot;clear&quot; /&gt;    &lt;!--也可以使用br等别的块级元素来清除浮动--&gt;</span><br></pre></td></tr></table></figure><p>给父级元素添加overflow样式：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">        <span class="attribute">overflow</span>: auto;  </span><br><span class="line">      <span class="comment">/* 加上这句话，就可以清除浮动   overflow = hidden|auto|scroll 都可以实现*/</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>伪元素法</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">&quot;.&quot;</span>;  <span class="comment">/*尽量不要为空，一般写一个点*/</span></span><br><span class="line">    <span class="attribute">height</span>:<span class="number">0</span>;     <span class="comment">/*盒子高度为0，看不见*/</span></span><br><span class="line">    <span class="attribute">display</span>:block;    <span class="comment">/*插入伪元素是行内元素，要转化为块级元素*/</span></span><br><span class="line">    <span class="attribute">visibility</span>:hidden;      <span class="comment">/*content有内容，将元素隐藏*/</span></span><br><span class="line">    <span class="attribute">clear</span>:both;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    *zoom: <span class="number">1</span>;   <span class="comment">/*  *只有IE6,7识别 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:before</span>, <span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">       <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>; </span><br><span class="line">       <span class="attribute">display</span>: table;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">       <span class="attribute">clear</span>: both;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">       *zoom: <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="pading和margin的百分比单位：-一律包含盒的宽度"><a href="#pading和margin的百分比单位：-一律包含盒的宽度" class="headerlink" title="pading和margin的百分比单位： 一律包含盒的宽度"></a>pading和margin的百分比单位： 一律包含盒的宽度</h2><h2 id="父子边距重合"><a href="#父子边距重合" class="headerlink" title="父子边距重合"></a>父子边距重合</h2><p>解决办法： 在父元素上加上overflow：hidden 使其称为BFC</p><h2 id="CSS字体大小设置的三种"><a href="#CSS字体大小设置的三种" class="headerlink" title="CSS字体大小设置的三种"></a>CSS字体大小设置的三种</h2><p>rem  em，px</p><p>px绝对大小L</p><p>em： 相对大小， 相对于父元素</p><p>rem： 相对大校，相对于根元素</p><h2 id="css3新特性"><a href="#css3新特性" class="headerlink" title="css3新特性"></a>css3新特性</h2><p>圆角： border-radius</p><p>边框阴影： box-shadow</p><p>background-size： 背景图片由图片的实际尺寸决定， </p><p>text-wrap： 设置区域内换行</p><p>css2D转换： 对元素进行移动，缩放， 转动，拉长和伸缩</p><p><strong>translate（X,Y) : 元素根据给定的left和right表表， 从当前位置移动， x为向右移动，y为向下移动</strong></p><p><strong>rotate</strong>（） ： 正值为顺时针转动， </p><p><strong>scale（x,y)</strong>: 根据给定的宽度x轴和y轴，控制元素尺寸的增加和减少 x为宽度为原来的多少倍。 y为高度是原来的多少倍</p><p><strong>skew（x,y</strong>:   元素绕x轴 ，y轴分别反转多少度</p><p>允许3d转换：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rotateX:绕x轴旋转多少度</span><br><span class="line">rotateY： 绕y轴旋转多少度</span><br></pre></td></tr></table></figure><p>CSS过度：在不使用flash动画的情况下，一种样式变化为另一种样式时添加的效果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设置亮相内容： </span><br><span class="line">设置添加过渡时的属性</span><br><span class="line">设置添加过渡时的时长</span><br><span class="line">例子：</span><br><span class="line">    .box2&#123;</span><br><span class="line">        background-color: #6f42c1;</span><br><span class="line">        width: 100px;</span><br><span class="line">        height: 100px;</span><br><span class="line">        transition:  width 2s;</span><br><span class="line">    &#125;</span><br><span class="line">    .box2:hover&#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">        background-color: pink;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>cookie和sessionStoreage和localSrorage的区别</p><p>cookie始终在同源的http请求中携带，即使不需要， 即cookie在浏览器和服务器，sessionStorage和localStorage不会自动把数据发送给服务器， 仅在本地保存， cookie数据还有路径的概念， 可以限制cookie仅属于某个路径下</p><p>存储大小不同： cookie数据不能超过4K， 同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识，sessionStorage和localSrorage虽然也有存储大小的限制， 但是比cookie大得多，5m</p><p>数据有效期不同： sessionStorage仅在浏览器窗口关闭前有效， localsorage始终有效， 窗口或者浏览器关闭也一直保存， 因此用作持久数据， cookie： 只在设置的cookie过期事件之前有效， 即使窗口或者浏览器关闭</p><p>作用域不同：sessionStorage不在不同的浏览器窗口共享，即使是同一个页面 ；localStorage在所有同源的窗口共享， cookie叶子也在所有的同源窗口共享</p><h2 id="浏览器如何渲染页面"><a href="#浏览器如何渲染页面" class="headerlink" title="浏览器如何渲染页面"></a>浏览器如何渲染页面</h2><p>HTML会被html解析器解析成dom树</p><p>css被css解析器解析成cssdom树</p><p>结合dom树和cssdom树，生成一颗渲染树， 这一过程称为attachement</p><p>生成布局flow，浏览器在屏幕上画出渲染树所有的结点</p><p>将布局绘制在屏幕上，渲染整个页面</p><h2 id="重绘和重排，如何避免重排"><a href="#重绘和重排，如何避免重排" class="headerlink" title="重绘和重排，如何避免重排"></a>重绘和重排，如何避免重排</h2><p>重排： 渲染树的一部分必须更新， 并且结点尺寸发生了变化，浏览器会使得渲染树中收到影响的部分失效， 并且重新构造渲染树</p><p>重绘： 是指一个元素的外观被改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制， 使得元素呈现新的外观，（改变颜色，文字背景颜色，）</p><p>区别： 重排必然导致重绘</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>校招算法</title>
      <link href="/2024/04/19/%E6%A0%A1%E6%8B%9B%E7%AE%97%E6%B3%95/"/>
      <url>/2024/04/19/%E6%A0%A1%E6%8B%9B%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="哈希函数和哈希表"><a href="#哈希函数和哈希表" class="headerlink" title="哈希函数和哈希表"></a>哈希函数和哈希表</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js面试</title>
      <link href="/2024/04/18/js%E9%9D%A2%E8%AF%95/"/>
      <url>/2024/04/18/js%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="let-var-const-区别"><a href="#let-var-const-区别" class="headerlink" title="let var const 区别"></a>let var const 区别</h2><p>let: let和const不存在变量提升，存在块级作用域，不能跨域访问 ，同一作用域，let和const不允许重复声明，const创建变量不运行修改，全局变量并不会挂在在windows下，挂在在script下，创建提升，没有初始化</p><p>var：存在全局作用域和函数作用域， 不能跨函数访问 ，初始化提升</p><h2 id="7种基本数据类型，一种引用数据类型"><a href="#7种基本数据类型，一种引用数据类型" class="headerlink" title="7种基本数据类型，一种引用数据类型"></a>7种基本数据类型，一种引用数据类型</h2><p>boolean   null  undefined  Number  BigInt （超出范围不报错） String  symbol（唯一，不可修改）   object</p><h2 id="数据类型检测"><a href="#数据类型检测" class="headerlink" title="数据类型检测"></a>数据类型检测</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>只能检测基本数据类型type of： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(typeof undefined) // undefined</span><br><span class="line">console.log(typeof null)// object</span><br><span class="line">console.log(typeof NaN)// number</span><br><span class="line">console.log(typeof 1)// number</span><br><span class="line">console.log(typeof &#x27;1&#x27;)// string</span><br><span class="line">console.log(typeof true)// boolean</span><br><span class="line">console.log(typeof Symbol())// symbol</span><br></pre></td></tr></table></figure><h3 id="instanceof：-检测当前实例是否属于这个类"><a href="#instanceof：-检测当前实例是否属于这个类" class="headerlink" title="instanceof： 检测当前实例是否属于这个类"></a>instanceof： 检测当前实例是否属于这个类</h3><p>但是你检测数组是否为Object的时候返回true</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(person instanceof  Person)//Person</span><br></pre></td></tr></table></figure><p>底层机制： 只要当前类出现在实例的原型链上，结果都是true</p><p>由于我们可以肆意修改原型指向，所以检测结果是不准确的</p><p>且不能检测基本数据类型</p><h3 id="实例-prototype-x3D-x3D-x3D-类-prototype"><a href="#实例-prototype-x3D-x3D-x3D-类-prototype" class="headerlink" title="实例._____prototype ____&#x3D;&#x3D;&#x3D;类.______prototype ___"></a>实例._____prototype ____&#x3D;&#x3D;&#x3D;类.______prototype ___</h3><h3 id="constructor是否相等"><a href="#constructor是否相等" class="headerlink" title="constructor是否相等"></a>constructor是否相等</h3><p>可以处理基本数据类型， 用起来看起来比instaceof好用一点</p><p>但是constructor可以随便改，所以也可能不准确</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(person.constructor===Person)</span><br></pre></td></tr></table></figure><h3 id="Object-prototype-tostring-不是转化为字符串，是返回当前实例所属类的信息"><a href="#Object-prototype-tostring-不是转化为字符串，是返回当前实例所属类的信息" class="headerlink" title="Object.prototype.tostring: 不是转化为字符串，是返回当前实例所属类的信息"></a>Object.prototype.tostring: 不是转化为字符串，是返回当前实例所属类的信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">console.log(Object.prototype.toString.call(1)) // [object Number]</span><br><span class="line"></span><br><span class="line">console.log(Object.prototype.toString.call(&#x27;1&#x27;))// [object String]</span><br><span class="line">console.log(Object.prototype.toString.call(true))// [object Boolean]</span><br><span class="line">console.log(Object.prototype.toString.call(Symbol()))// [object Symbol]</span><br><span class="line">console.log(Object.prototype.toString.call(null))// [object Null]</span><br><span class="line">console.log(Object.prototype.toString.call(undefined))// [object Undefined]</span><br><span class="line">console.log(Object.prototype.toString.call(person))// [object Object]</span><br></pre></td></tr></table></figure><h3 id="真实情况：-封装一个方法"><a href="#真实情况：-封装一个方法" class="headerlink" title="真实情况： 封装一个方法"></a>真实情况： 封装一个方法</h3><p>基本数据类型： typeof</p><p>对象：  对象tostring&#x3D;&#x3D;Object.prototype.tostring </p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404182203992.png" alt="image-20240418220339934"></p><p> <img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404182200399.png" alt="image-20240418220037096"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404182205523.png" alt="image-20240418220501452"> </p><p>基本数据类型  </p><p>事件流</p><h2 id="dom树"><a href="#dom树" class="headerlink" title="dom树"></a>dom树</h2><p>html文档树（编译原理的抽象树）</p><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>捕获阶段  目标 冒泡阶段</p><h2 id="事件委托：-把事件响应交给父元素"><a href="#事件委托：-把事件响应交给父元素" class="headerlink" title="事件委托： 把事件响应交给父元素"></a>事件委托： 把事件响应交给父元素</h2><h2 id="JS的三种循环及其性能分析"><a href="#JS的三种循环及其性能分析" class="headerlink" title="JS的三种循环及其性能分析"></a>JS的三种循环及其性能分析</h2><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var  a=1;</span><br><span class="line">function sum(b,c)</span><br><span class="line">&#123;</span><br><span class="line">    return b+c;</span><br><span class="line">&#125;</span><br><span class="line">function addsum(d,e)</span><br><span class="line">&#123;</span><br><span class="line">    var f=10;</span><br><span class="line">    result=sum(d,e);</span><br><span class="line">    return a+result+f;</span><br><span class="line">&#125;</span><br><span class="line">addsum(3,6);</span><br></pre></td></tr></table></figure><p>调用栈的过程：</p><ol><li>创建全局上下文，将其压入栈底，执行a&#x3D;1，进行变量提升</li><li>调用addsum，javaScript引编译该函数， 并且为其创建一个执行上下文， 最后将该函数的执行上下文压入栈种， </li><li>执行到add函数时，创建上下文， 把函数压入栈中</li></ol><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>以前： 全局作用域和函数作用域</p><p>全局作用域的特点： 挂在到window对象种，只要页面不关闭，这个变量就存活</p><p>比如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a=10;</span><br><span class="line">console.log(window.a)</span><br></pre></td></tr></table></figure><p>ES6新增作用域： 块级作用域</p><h4 id="let和const关键字解决问题的原理"><a href="#let和const关键字解决问题的原理" class="headerlink" title="let和const关键字解决问题的原理"></a>let和const关键字解决问题的原理</h4><ul><li>let和const关键字创建的变量都存储在词法环境当中，var关键字创建的变量存储在变量环境中</li><li>块级内部代码执行结束，立马销毁内部let，const创建的变量</li><li>let和const创建的变量，初始化不提升（没有初始化） ，创建提升， 造成暂时性的死去</li><li>访问变量先在执行上下文的词法环境中查找， 再到变量环境中查找</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function  bar()</span><br><span class="line">&#123;</span><br><span class="line">    var myname=&quot;zhangsan&quot;;</span><br><span class="line">    let test1=100</span><br><span class="line">    if(1)</span><br><span class="line">    &#123;</span><br><span class="line">        console.log(test1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function  foo()</span><br><span class="line">&#123;</span><br><span class="line">    var name=&#x27;dd&#x27;</span><br><span class="line">    let test=200</span><br><span class="line">    &#123;</span><br><span class="line">        let test=300</span><br><span class="line">        bar()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var myname=&#x27;aa&#x27;</span><br><span class="line">let myage=10</span><br><span class="line">let test=1</span><br><span class="line">foo() //打印100</span><br></pre></td></tr></table></figure><h4 id="作用域的特点：-代码编译阶段就决定好，和函数怎么调用没有关系"><a href="#作用域的特点：-代码编译阶段就决定好，和函数怎么调用没有关系" class="headerlink" title="作用域的特点： 代码编译阶段就决定好，和函数怎么调用没有关系"></a>作用域的特点： 代码编译阶段就决定好，和函数怎么调用没有关系</h4><h4 id="作用域链：-当一个函数使用了某个变量，-首先会在自己的内部作用域查找，然后首先再向外部一层层查找，-直到全局作用域，-这个链式查找就时作用域链"><a href="#作用域链：-当一个函数使用了某个变量，-首先会在自己的内部作用域查找，然后首先再向外部一层层查找，-直到全局作用域，-这个链式查找就时作用域链" class="headerlink" title="作用域链： 当一个函数使用了某个变量， 首先会在自己的内部作用域查找，然后首先再向外部一层层查找， 直到全局作用域， 这个链式查找就时作用域链"></a>作用域链： 当一个函数使用了某个变量， 首先会在自己的内部作用域查找，然后首先再向外部一层层查找， 直到全局作用域， 这个链式查找就时作用域链</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let num=1;</span><br><span class="line">function fun1()</span><br><span class="line">&#123;</span><br><span class="line">    function fun2()</span><br><span class="line">    &#123;</span><br><span class="line">        function fun3()</span><br><span class="line">        &#123;</span><br><span class="line">            console.log(num)</span><br><span class="line">        &#125;</span><br><span class="line">        fun3()</span><br><span class="line">    &#125;</span><br><span class="line">    fun2()</span><br><span class="line">&#125;</span><br><span class="line">fun1()</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h3><p>作用域链： 当前作用域可以访问上级作用域中的变量</p><p>全局变量只在页面关闭才会销毁</p><h3 id="闭包解决的问题"><a href="#闭包解决的问题" class="headerlink" title="闭包解决的问题"></a>闭包解决的问题</h3><p>函数作用域中的变量在函数执行结束就会销毁， 但是有时候我们不希望销毁</p><p>在函数外部可以访问函数内部的变量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function  foo()</span><br><span class="line">&#123;</span><br><span class="line">    let test1=1;</span><br><span class="line">    const test2=2;</span><br><span class="line">    var myname=&#x27;王美丽&#x27;</span><br><span class="line">    var innerbar=&#123;</span><br><span class="line">        getname: function () &#123;console.log(test1) ;test1++;return myname&#125;,</span><br><span class="line">        setname: function (name) &#123;this.myname=name&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return innerbar</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var bar =foo()</span><br><span class="line">bar.setname(&#x27;张三&#x27;)</span><br><span class="line">bar.getname()</span><br><span class="line">console.log(bar.getname())</span><br></pre></td></tr></table></figure><h3 id="函数闭包带来的问题"><a href="#函数闭包带来的问题" class="headerlink" title="函数闭包带来的问题"></a>函数闭包带来的问题</h3><p>容易造成内存泄漏</p><ul><li>内存泄漏： 占用的内存没有及时泄漏， 内存泄漏积累多了就容易导致内存溢出</li></ul><h4 id="闭包应用：-柯里化：-把一个多参函数转化为单参数函数的办法"><a href="#闭包应用：-柯里化：-把一个多参函数转化为单参数函数的办法" class="headerlink" title="闭包应用： 柯里化： 把一个多参函数转化为单参数函数的办法"></a>闭包应用： 柯里化： 把一个多参函数转化为单参数函数的办法</h4><p>例子： 正则复用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function test(reg)</span><br><span class="line">&#123;</span><br><span class="line">    return function (txt)</span><br><span class="line">    &#123;</span><br><span class="line">        return reg.test(txt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const email=test(/^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$/)</span><br><span class="line">console.log(email(&#x27;119473323@qq.com&#x27;))</span><br></pre></td></tr></table></figure><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>严格模式和非严格模式下：</p><p>严格模式下全局作用域调用的函数打印的this： 指向undefined</p><p>非严格模式下全局作用域调用的函数打印的this： 指向window</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;use strict&#x27;</span><br><span class="line">function get()</span><br><span class="line">&#123; </span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">get() //undefined</span><br></pre></td></tr></table></figure><p>非严格模式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">function get()</span><br><span class="line">&#123;</span><br><span class="line">    console.log(this) //window</span><br><span class="line">&#125;</span><br><span class="line">get()</span><br></pre></td></tr></table></figure><p>箭头函数没有this， 它的this取决于它的外部函数</p><p>new 构建了新对象，this就是指向新对象本身</p><h3 id="为什么要有this：-因为在javascript中创建了一个对象，对象中的函数想要访问对象的其他属性无法访问"><a href="#为什么要有this：-因为在javascript中创建了一个对象，对象中的函数想要访问对象的其他属性无法访问" class="headerlink" title="为什么要有this： 因为在javascript中创建了一个对象，对象中的函数想要访问对象的其他属性无法访问"></a>为什么要有this： 因为在javascript中创建了一个对象，对象中的函数想要访问对象的其他属性无法访问</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj=&#123;</span><br><span class="line">    name:&#x27;dd&#x27;,</span><br><span class="line">    age:&#x27;18&#x27;,</span><br><span class="line">    show:function()&#123;</span><br><span class="line">        console.log(name,age) //报错</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.show()</span><br><span class="line">obj=&#123;</span><br><span class="line">    name:&#x27;dd&#x27;,</span><br><span class="line">    age:&#x27;18&#x27;,</span><br><span class="line">    show:function()&#123;</span><br><span class="line">        console.log(this.name,this.age) //dd 18</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="嵌套函数中的this不继承"><a href="#嵌套函数中的this不继承" class="headerlink" title="嵌套函数中的this不继承"></a>嵌套函数中的this不继承</h3><h3 id="改变this的方法：-call，-apply-，bind"><a href="#改变this的方法：-call，-apply-，bind" class="headerlink" title="改变this的方法： call， apply ，bind"></a>改变this的方法： call， apply ，bind</h3><h1 id="ES6的新特性"><a href="#ES6的新特性" class="headerlink" title="ES6的新特性"></a>ES6的新特性</h1><h2 id="解构符号"><a href="#解构符号" class="headerlink" title="解构符号"></a>解构符号</h2><h3 id="解构符号作用"><a href="#解构符号作用" class="headerlink" title="解构符号作用"></a>解构符号作用</h3><p>结构赋值是对赋值运算符的扩展， 她是一种针对数组或者对象进行模式匹配， 然后对其中的变量进行赋值， ES6,运行按照一定模式，从数组和对象中提取值， 对变量进行赋值，称为结构</p><h3 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h3><ul><li><p>基本使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let [a,b,c]=[1,2,3]</span><br><span class="line">console.log(a,b,c)</span><br></pre></td></tr></table></figure></li><li><p>嵌套使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let [a,[b,c]]=[1,[2,3]]</span><br><span class="line">console.log(a,b,c)</span><br></pre></td></tr></table></figure></li><li><p>忽略</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let [a,,c]=[1,2,3]</span><br><span class="line">console.log(a,c)</span><br></pre></td></tr></table></figure></li></ul><p>​    应用： 浅克隆和合并</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> a=[1,2,3,4,5,6,7,8,9,10]</span><br><span class="line">let b=[11,12]</span><br><span class="line">let c=[...a,...b]</span><br><span class="line">console.log(c) c是浅克隆合并a，b</span><br></pre></td></tr></table></figure><p>提取JSON数据</p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><ol><li><p>箭头函数没有this， this是从外部获取的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mm(a,b,c)&#123;</span><br><span class="line">    console.log(arguments);</span><br><span class="line">    console.log(arguments.length);</span><br><span class="line">    console.log(arguments[0]);</span><br><span class="line">    console.log</span><br><span class="line">    console.log(this) //window</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(mm(1,1,1))</span><br><span class="line"></span><br><span class="line">const aa=()=&gt;&#123;</span><br><span class="line">    console.log(this) //&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">aa();</span><br><span class="line">function mm ()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    return() =&gt;&#123;console.log(arguments)</span><br><span class="line">    console.log(this)&#125;</span><br><span class="line">&#125;</span><br><span class="line">const  a=1</span><br><span class="line"></span><br><span class="line">const b=mm.bind(a,1,2,3)</span><br><span class="line">const c=b()</span><br><span class="line">console.log(c())</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>箭头函数不能对箭头函数进行new操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const aa=()=&gt;&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const a=new aa() //报错， aa is not a constructor</span><br></pre></td></tr></table></figure></li><li><p>箭头函数没有arguments ，可以继承外层函数的arguments</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function mm ()</span><br><span class="line">&#123;</span><br><span class="line">    return() =&gt;&#123;console.log(arguments)&#125;</span><br><span class="line">&#125;</span><br><span class="line">let a=mm(11)</span><br><span class="line">console.log(a())</span><br></pre></td></tr></table></figure></li><li><p>箭头函数没有原型和super</p><h2 id="map和weakmap"><a href="#map和weakmap" class="headerlink" title="map和weakmap"></a>map和weakmap</h2><p>1.1 map的特点： </p><p>map的键和值可以是任何数据类型，object不可以</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const ma=new Map</span><br><span class="line">ma.set(2,&#x27;zhangsan&#x27;)</span><br><span class="line">console.log(ma)</span><br></pre></td></tr></table></figure><p>键值对按照插入顺序排序</p><p>map数据可迭代， object数据不可迭代</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const ma=new Map</span><br><span class="line">ma.set(2,&#x27;zhangsan&#x27;)</span><br><span class="line">ma.set(3,&#x27;lisi&#x27;)</span><br><span class="line">console.log(ma)</span><br><span class="line">for(let [key,value] of ma)</span><br><span class="line">&#123;</span><br><span class="line">    console.log(key,value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map常见属性"><a href="#map常见属性" class="headerlink" title="map常见属性"></a>map常见属性</h2><table><thead><tr><th>map.set(key,value)</th><th>添加键值对到映射中</th></tr></thead><tbody><tr><td>map.get(key)</td><td>获取映射中的某一个键对应的值</td></tr><tr><td>map.delete(key)</td><td>将某一键值对移除映射</td></tr><tr><td>map.clear()</td><td>清空映射中的所有键值对</td></tr><tr><td>map.entries()</td><td>返回一个二元数组作为元素的的数组   的对象</td></tr><tr><td>map.has(key)</td><td>检查映射中是否有包含某一键值对</td></tr><tr><td>map.values()</td><td>获取当前映射中的所有值作为可迭代对象</td></tr><tr><td>map,size</td><td>映射中的数量</td></tr></tbody></table></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const ma=new Map</span><br><span class="line">ma.set(3,&#x27;zhangsan&#x27;)</span><br><span class="line">ma.set(2,&#x27;lisi&#x27;)</span><br><span class="line">console.log(ma)</span><br><span class="line">const  c=ma.size</span><br><span class="line">const d=ma.entries()</span><br><span class="line">const e=ma.keys()</span><br><span class="line">const f=ma.values()</span><br><span class="line">// const g=ma</span><br><span class="line">console.log(f)</span><br><span class="line">console.log(e)</span><br><span class="line">console.log(c)</span><br><span class="line">for(let i of d)</span><br><span class="line">    console.log(i)</span><br></pre></td></tr></table></figure><h2 id="weakmap"><a href="#weakmap" class="headerlink" title="weakmap"></a>weakmap</h2><p>weakmap和map相似，也是用于生成键值对的集合</p><ul><li>只接受对象作为简明（null 除外） ， 不接受其他类型的值作为键名</li><li>键名是弱引用，键值可以 是任意的， 键名所指向的对象可以被垃圾回收， 此时键名是无效的</li><li>不可枚举，枚举其列表将会受到垃圾回收机制的影响， 方法有get，set，has，delete，get</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const wk=new WeakMap();</span><br><span class="line">let one=&#123;n:1&#125;;</span><br><span class="line">wk.set(one,55)</span><br><span class="line">console.log(wk.get(one))</span><br><span class="line">one=null</span><br><span class="line">console.log(wk.get(one))</span><br></pre></td></tr></table></figure><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><ol><li><p>网络连接</p><table><thead><tr><th>OSI七层模型</th><th>TCP&#x2F;IP四层协议簇</th><th>对应网络协议</th></tr></thead><tbody><tr><td>应用层</td><td>应用层</td><td>HTTP&#x2F;TFTP&#x2F;FTP&#x2F;WAIS&#x2F;SMTP</td></tr><tr><td>表示层</td><td></td><td>Telnet , Rlogin ,Snmp ,Gopher</td></tr><tr><td>会话层</td><td></td><td>SMTP,DNS</td></tr><tr><td>传输层</td><td>传输层</td><td>TCP UDP</td></tr><tr><td>网络层</td><td>网络层</td><td>IP ,ICMP,ARP,RARP, AKP,UUCP</td></tr><tr><td>数据链路层</td><td>数据链路层</td><td>FEEI,Ethernet,Arpanet,PDN,SLIP,PPP</td></tr><tr><td>物理层</td><td></td><td>IEEE802.1A IEEE802.2到IEEE 802.11</td></tr></tbody></table></li></ol><h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><h3 id="http0-9"><a href="#http0-9" class="headerlink" title="http0.9"></a>http0.9</h3><p>只请求一个html文件， 所以返回的文件都是ASCII码形式， 只有一个请求行</p><h3 id="http1-0"><a href="#http1-0" class="headerlink" title="http1.0"></a>http1.0</h3><ol><li>支持多种类型， 格式，编码，语言的文件，添加请求头和响应头</li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accept: text/html;</span><br><span class="line">accept-coding:gzip,utf-8;</span><br><span class="line">accept-charset: ISO-8859-1,UTF-8;</span><br><span class="line">accept-language: zh-cn,zh;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">content-encoding: brocontent-type, txt/html; charset-utf-8</span><br></pre></td></tr></table></figure><ol start="2"><li>请求状态服务器可能无法处理，或者出错，这时候就需要告诉浏览器服务器最终该请求的情况，状态码就是通过响应的方式来通知浏览器的</li><li>减轻服务压力，http1.0中还挺供了Cache机制，用来缓存已经下载过多数据</li><li>服务器需要统计客户端的基础信息，比如windows和macOS的用户，所以http1.0还加入了用户代理的字段</li></ol><p><strong>http1.0对每一次请求都建立了了tcp的连接</strong></p><h3 id="http1-1"><a href="#http1-1" class="headerlink" title="http1.1"></a>http1.1</h3><p><strong>改动： tcp持久化连接，多个http请求可以在同一个tcp，只要浏览器或服务器没有明确断开连接，那么tcp连接就会一直保持</strong></p><p>http1.1默认开启长连接： Connecttion： keep-alive</p><p><strong>管线化： 将多个http请求整批提交给服务器的技术， 虽然可以整批发，不过服务器依然需要根据请求的顺序来回复浏览器的请求</strong></p><p><strong>第三个： 提供虚拟机支持， http1.1的请求头中增加了host字段， 用来表示当前的域名地址，这样服务器可以根据不同的host值做处理</strong></p><p>第四个： 对动态生成的内同，http1.1引入了chunk  transfer机制， 服务器会将数据分割为若干个任意大小的数据块， 每个数据块发送时会赋上上个数据块的长度，最后使用一个零长度的块作为数据完成的标志</p><p><strong>第五个： http1.1还引入了客户端Cookie机制</strong></p><p><strong>第6个： 补充了缓存的请求头和响应头</strong></p><h3 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h3><ol><li><p>主要需要解决的问题</p><p>第一个： 一个域名只使用一个TCP长连接’</p><p>解决tcp慢启动， 减少tcp连接次数</p><p>针对同一个域名最多可以简历6个tcp连接，每个连接都会占用部分带宽资源， 且不会按照优先级分配带块资源，导致需要加载出来的数据慢返回</p><p>第二个: 消除对头拥塞问题</p><p>​ <strong>解决办法： 多路复用</strong></p><p>浏览器发送请求： 通过二进制分帧，分成一帧一帧的数据去传输， （一个请求有多帧，每个帧有相同的id）</p><p>服务器响应请求： 服务器接收到所有帧之后，会将所有的相同id的帧合并为一条完整的的请求信息， 并将处理的响应行，响应头，分别发送至二进制分帧层， 返回时可以按照请求优先级，或者响应速度，返回帧数据</p><p>浏览器接受数据： 浏览器接受到响应帧后，会根据ID编号将帧的数据提交给响应的请求</p><h3 id="http2-0特性"><a href="#http2-0特性" class="headerlink" title="http2.0特性"></a>http2.0特性</h3><ol><li><p>多路复用： 一个域名只使用一个TCP长连接， 消除了对头阻塞的问题</p></li><li><p>可以设置请求的优先级： 解决服务器接收到数据，会处理有衔接高的数据</p></li><li><p>服务器推送： 服务器直到html页面会引用的几个重要的javaScript文件和css文件，那么在接收到html请求之后，附带将要使用的css文件和javaScript文件一并发送给浏览器，这样当浏览器解析完html文件之后，就能拿到需要的css文件和javaScript文件</p></li><li><p>头部压缩： http2对请求头响应进行了压缩</p></li></ol><h3 id="http的状态码"><a href="#http的状态码" class="headerlink" title="http的状态码"></a>http的状态码</h3><p>1xx： 指定客户端的某些动作，代表请求已被接受， 需要继续处理</p><p>2xx:     代表请求已成功被服务器接收，理解并接受，如200</p><p>3xx： 代表需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，如302</p><p>4xx:   代表请求错误</p><p>5xx： 代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理，常见的有500，503</p><h3 id="http-常用的状态码"><a href="#http-常用的状态码" class="headerlink" title="http 常用的状态码"></a>http 常用的状态码</h3><p><strong>2开头：（请求成功） ，代表成功处理了请求的状态码</strong></p><p><strong>3开头： （请求被重定向） 表示要完成请求需要进一步操作， 通常这些状态码需要用来重定向</strong></p><ul><li><p>301（永久移动） ： 请求的网页永久移动到新的位置， 服务器返回此响应（对get和head请求的响应时） ，会自动将请求转移到新的位置 </p></li><li><p>302（临时移动） ： 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求</p></li></ul><p>304（未修改） ： 自从上次请求后，请求的网页未修改过， 服务器返回此响应时， 不会返回网页内容</p><p><strong>4开头：（请求错误）这些状态码代表请求可能出错， 妨碍了服务器的处理</strong></p><ul><li><p>403（禁止） ：服务器拒绝请求</p></li><li><p>404（未找到）： 服务器找不到请求的网页</p></li></ul><p><strong>5开头：（服务器错误）这些状态码代表服务器在尝试处理请求时，内部发生的错误，这些错误可能时服务器本身的错误，而不是请求出错</strong>、</p><ul><li>500  （服务器内部错误） 服务器遇到错误，无法完成请求</li><li>504（网关超时） ，服务器作为网关代理，但是没有及时从上游服务器收到请求</li></ul><h3 id="http请求头和响应头"><a href="#http请求头和响应头" class="headerlink" title="http请求头和响应头"></a>http请求头和响应头</h3><p>accept: text&#x2F;html;<br>accept-coding:gzip,utf-8;<br>accept-charset: ISO-8859-1,UTF-8;<br>accept-language: zh-cn,zh;</p><p>coonection：</p><p>host： ip地址</p><p>useragent</p><p>cookie： </p><p><strong>响应头：</strong></p><p>cache-control</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>强制缓存</p><h3 id="接口请求的几种方式"><a href="#接口请求的几种方式" class="headerlink" title="接口请求的几种方式"></a>接口请求的几种方式</h3><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><h3 id="浏览器运行原理"><a href="#浏览器运行原理" class="headerlink" title="浏览器运行原理"></a>浏览器运行原理</h3><h3 id="浏览器调试工具"><a href="#浏览器调试工具" class="headerlink" title="浏览器调试工具"></a>浏览器调试工具</h3></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>web</title>
      <link href="/2024/04/18/css-1/"/>
      <url>/2024/04/18/css-1/</url>
      
        <content type="html"><![CDATA[<h1 id="web知识"><a href="#web知识" class="headerlink" title="web知识"></a>web知识</h1><p>开发语言： html，js，sass&#x2F;less，ts</p><p>基础知识： 网络，设计模式， 后端基础知识，基础设计交互知识</p><p>移动web： 响应式开发，移动端适配，触摸交互，桥协议</p><p>安全： csrs，xss，csr，同源策略</p><p>部署：</p><p>质量： 单元测试，自动化测试，代码风格检查</p><p>可视化： SVG,Canvas，webGL</p><p>web基础框架： vue，angular，react</p><p>组件库： ant，elementui，mtdui，roo</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试</title>
      <link href="/2024/04/17/%E9%9D%A2%E8%AF%95/"/>
      <url>/2024/04/17/%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="Script的8个属性"><a href="#Script的8个属性" class="headerlink" title="Script的8个属性"></a>Script的8个属性</h2><p>只对外部文件有效：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async: 标识立即下载该脚本，可以不按照顺序</span><br><span class="line">defer： 标识脚本可以延迟到文档被完全解析和显示后再执行，按照顺序执行</span><br><span class="line">integrity: 可选， 允许对比接受到的资源的签名和这个属性指定的签名不匹配，页面会报错， 脚本不会执行，这个属性可以确保内容分发网络，不会提供恶意内容</span><br></pre></td></tr></table></figure><p>如何把自己的script代码暴露出去</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;);</span><br><span class="line">const cors=require(&#x27;cors&#x27;)</span><br><span class="line">const fs = require(&quot;fs&quot;);</span><br><span class="line">// const cor=require(&#x27;cors&#x27;)</span><br><span class="line">const app=express();</span><br><span class="line">// app.use(express.json())</span><br><span class="line">// // app.use((req,res)=&gt;&#123;</span><br><span class="line">// //     console.log(&#x27;jjj&#x27;)</span><br><span class="line">// //</span><br><span class="line">// // &#125;)</span><br><span class="line">app.use(cors(</span><br><span class="line">    &#123;</span><br><span class="line">        origin: &#x27;*&#x27;,</span><br><span class="line">        methods: [&#x27;GET&#x27;, &#x27;POST&#x27;],</span><br><span class="line">        allowedHeaders: [ ]</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">))</span><br><span class="line">app.get(&#x27;/&#x27;,(req,res)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    console.log(&#x27;收到请求&#x27;)</span><br><span class="line">    res.write(JSON.stringify(obg))</span><br><span class="line">    res.end()</span><br><span class="line">&#125;)</span><br><span class="line">app.get(&#x27;/js/my.js&#x27;,(req,res)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    const filepath=__dirname+&#x27;/my.js&#x27;</span><br><span class="line">    console.log(filepath);</span><br><span class="line">    fs.readFile(filepath,&#x27;utf-8&#x27;,(err,data)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">        if(err)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            console.error(&#x27;Error reading JS file:&#x27;, err);</span><br><span class="line">            return res.status(500).send(&#x27;Internal Server Error&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        res.setHeader(&#x27;Content-Type&#x27;,&#x27;application/javascript&#x27;)</span><br><span class="line">        res.send(data)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000,()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;server is running on port 3000&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如何在页面中引用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;xue.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;http://localhost:3000/js/my.js&quot; defer&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;login&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;title&quot;&gt;系统登录&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;nameandpass&quot;&gt;&lt;input type=&quot;text&quot; class=&quot;name&quot; placeholder=&quot;请输入账号&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;nameandpass&quot;&gt;&lt;input type=&quot;password&quot;  class=&quot;pass&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;in&quot;&gt; &lt;button type=&quot;submit&quot;&gt;登录&lt;/button&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>浏览器解析这个资源时，会向src属性指定的路径发生一个get请求，以获取相应的资源， 假定是一个javaScript，这个请求就不受浏览器同源策略限制， 但是返回并执行的javaScript则受限制， 当然， 这个请求仍然收到http&#x2F;https协议的限制， integrity这个关键字可以防范这个问题，但是这个属性不是所有浏览器都支持， 里面可以写，这个js文件相关的hash码，每次下载，对文件进行hash码计算，如果相同的话，则正常加载，否则拒绝执行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script</span><br><span class="line">    integrity=&quot;sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxy9rx7HNQlGYl1kPzQho1wx4JwY8wC&quot;</span><br><span class="line">    src=&quot;https://cdn.xxx.xx/js/index.js&quot;&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="动态加载脚本"><a href="#动态加载脚本" class="headerlink" title="动态加载脚本"></a>动态加载脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    const login = document.querySelector(&#x27;.login&#x27;);</span><br><span class="line">    login.addEventListener(&#x27;click&#x27;,function(e)&#123;</span><br><span class="line">  let script=document.createElement(&#x27;script&#x27;);</span><br><span class="line">  script.src=&#x27;http://localhost:3000/js/my.js&#x27;;</span><br><span class="line">  script.async=false;</span><br><span class="line">  document.head.appendChild(script)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><p>ES6新增数据类型， 符号是原始值， 且符号是唯一的不可变的， ，符号的用途是确保对象使用唯一标识，不发生属性冲突</p><p>全局符号注册表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let foo=Symbol(&#x27;foo&#x27;)</span><br><span class="line">let fo=Symbol.for(&#x27;foo&#x27;)</span><br><span class="line">console.log(fo)</span><br><span class="line">console.log(foo===fo)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let s1=Symbol(&#x27;foo&#x27;),</span><br><span class="line">    s2=Symbol(&#x27;bar&#x27;),</span><br><span class="line">    s3=Symbol(&#x27;baz&#x27;);</span><br><span class="line">let o=&#123;</span><br><span class="line">&#125;</span><br><span class="line">Object.defineProperty(o,s2,&#123;value:&#x27;bar val&#x27;&#125;);</span><br><span class="line">console.log(Object.getOwnPropertySymbols(o))</span><br></pre></td></tr></table></figure><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for in :用来枚举对象中的非符号属性</p><p>for of：  是一种严格的迭代语句，用于遍历可迭代对象的元素</p><h3 id="变量，作用域和内存"><a href="#变量，作用域和内存" class="headerlink" title="变量，作用域和内存"></a>变量，作用域和内存</h3><p>变量： 原始值+引用值</p><p>原始值： 最简单的数据类型</p><p>引用值L多个值构成的对象</p><p>6种原始值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">undefined，Null，Boolean，Number， String，Symbol</span><br></pre></td></tr></table></figure><p>对于原始值变量是按值范文的，我们操作的就是存储在变量种的实际值</p><p>引用值是保存再内存种对象，javaScript不允许直接访问内存位置， 不允许直接访问内存空间， 所以操作的是对变量的引用， 而非对象本身</p><h3 id="javaScript确定对象类型"><a href="#javaScript确定对象类型" class="headerlink" title="javaScript确定对象类型"></a>javaScript确定对象类型</h3><p>typeof</p><h3 id="执行上下文和作用域"><a href="#执行上下文和作用域" class="headerlink" title="执行上下文和作用域"></a>执行上下文和作用域</h3><h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let expression=/pattern/flags</span><br></pre></td></tr></table></figure><p>flag用来控制正则表达式的行为，可以带一个或者多个</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g： 全局模式，找到所有符合的内容</span><br><span class="line">i： 不区分大小写，</span><br><span class="line">m： 多行模式，</span><br><span class="line">y： 黏附模式， 是否只查找从lastIndex开始及以后的字符串</span><br><span class="line">u： unicode模式</span><br><span class="line">s： doall模式， biao&#x27;shi</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>转义字符</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">([&#123;\ ^ $ | &#125;]) ? * +</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>css</title>
      <link href="/2024/04/17/css/"/>
      <url>/2024/04/17/css/</url>
      
        <content type="html"><![CDATA[<h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h3 id="css盒模型"><a href="#css盒模型" class="headerlink" title="css盒模型"></a>css盒模型</h3><p>普通盒模型： content+pading+border+ margin</p><p>怪异盒模型： with+margin</p><p>如何设置： box-sizeing属性： </p><p>普通： box-sizing： box-content</p><p>怪异：  box-sizing： border-box</p><h3 id="margin纵向重叠问题"><a href="#margin纵向重叠问题" class="headerlink" title="margin纵向重叠问题"></a>margin纵向重叠问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.d&#123;</span><br><span class="line">    background: red;</span><br><span class="line">    margin-bottom: 15px;</span><br><span class="line">    height: 20px;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.f&#123;</span><br><span class="line">background: #e5fff6;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">    height: 20px;</span><br><span class="line">&#125; 两者距离取最大值</span><br></pre></td></tr></table></figure><h2 id="两种布局"><a href="#两种布局" class="headerlink" title="两种布局"></a>两种布局</h2><h3 id="圣杯布局：-左右盒子宽度固定，-中间盒子自适应，中间盒子最先渲染"><a href="#圣杯布局：-左右盒子宽度固定，-中间盒子自适应，中间盒子最先渲染" class="headerlink" title="圣杯布局： 左右盒子宽度固定， 中间盒子自适应，中间盒子最先渲染"></a>圣杯布局： 左右盒子宽度固定， 中间盒子自适应，中间盒子最先渲染</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 静态页面搭建</span><br><span class="line">&lt;div class=&quot;box&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;content&quot;&gt;333333&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">// 样式实现</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line">    .box &#123;</span><br><span class="line">        display: flex;</span><br><span class="line">    &#125;</span><br><span class="line">    .left,</span><br><span class="line">    .right &#123;</span><br><span class="line">        width: 300px;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background-color: gold;</span><br><span class="line">    &#125;</span><br><span class="line">    .content &#123;</span><br><span class="line">        flex: 1;</span><br><span class="line">        height: 300px;</span><br><span class="line">        background-color: tomato;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="双飞翼布局："><a href="#双飞翼布局：" class="headerlink" title="双飞翼布局："></a>双飞翼布局：</h3><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><p>容器属性： </p><p>主轴方向</p><p>flex drection： row（横向） row reverse（反向）</p><p>​column（纵向）  column（纵轴反向排列）</p><p>justfy-content： 设置居中</p><p>justify-content：  flex-start：从左向右紧挨着排列</p><p>​flex-end： 从右到左</p><p>​                     space-between： 左右两边紧紧挨着边框，中间自适应</p><p>​space-around： 每个相邻的地方自适应</p><p>​ center：从中间开始紧挨着排列</p><p>flex-wrap（换行）：nowrap(不换行)</p><p>​wrap：换行</p><p>​align-items： 设置在副轴上的排列</p><p>​flex-end&#x2F;start</p><p>​center</p><p>​baseline</p><p>​stretch</p><p>align-conten：多行的时候</p><h4 id="项目属性："><a href="#项目属性：" class="headerlink" title="项目属性："></a>项目属性：</h4><p>flex： 百分比(站盒子的大小)</p><p>order：位置（越大越靠后）</p><p>align-self：副轴排列在哪</p><h2 id="骰子三点"><a href="#骰子三点" class="headerlink" title="骰子三点"></a>骰子三点</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;items&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;items&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;items&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .container&#123;</span><br><span class="line">        display: flex;</span><br><span class="line">        height: 200px;</span><br><span class="line">        width: 200px;</span><br><span class="line">        justify-content: space-between;</span><br><span class="line">    &#125;</span><br><span class="line">    .items:nth-child(1)&#123;</span><br><span class="line">        align-self: flex-start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .items:nth-child(2)&#123;</span><br><span class="line">        align-self: center;</span><br><span class="line">    &#125;</span><br><span class="line">    .items:nth-child(3)&#123;</span><br><span class="line"></span><br><span class="line">        align-self: flex-end;</span><br><span class="line">    &#125;</span><br><span class="line">    .items&#123;</span><br><span class="line">        width: 40px;</span><br><span class="line">        height: 40px;</span><br><span class="line">        border-radius: 20px;</span><br><span class="line">        background-color: #2b3035;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h2 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h2><h3 id="行内元素居中"><a href="#行内元素居中" class="headerlink" title="行内元素居中"></a>行内元素居中</h3><p>子绝父相</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">   &lt;span class=&quot;box&quot;&gt;hhh&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .container&#123;</span><br><span class="line">        position: relative;</span><br><span class="line">    &#125;</span><br><span class="line">    .box&#123;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top:50%; </span><br><span class="line">        left:50%; //祖先</span><br><span class="line">        transform: translate(-50%,50%);//自身</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="flex-1"><a href="#flex-1" class="headerlink" title="flex"></a>flex</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.box&#123;</span><br><span class="line">    align-items: center;</span><br><span class="line">    justify-content: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><p>margin： 0 atuo</p><h2 id="响应式式单位"><a href="#响应式式单位" class="headerlink" title="响应式式单位"></a>响应式式单位</h2><ul><li>em：相对于自身字体大小的单位</li><li>rem：相对于html标签字体大小的单位</li></ul><p>vh： 当前屏幕高度分为100分，占多数</p><p>vw： 当前屏幕宽度100份，占多数</p><h2 id="样式处理器"><a href="#样式处理器" class="headerlink" title="样式处理器"></a>样式处理器</h2><p>sass ，less，</p><p>CSS 本身可能很有趣，但是样式表正变得越来越大、 越来越复杂、越来越难以维护。这就是预处理可以提供帮助的地方。 Sass 为你提供了 CSS 中还不存在的特性，例如变量、 嵌套、混合、继承和其它实用的功能，让编写 CSS 代码变得再次有趣。</p><h2 id="三种导入方式："><a href="#三种导入方式：" class="headerlink" title="三种导入方式："></a>三种导入方式：</h2><p>内部样式表： 卸载style标签当中</p><p>外部样式表： 外部的js文件</p><p>行内样式表：行内样式</p><p>优先级： 行内样式&gt;内部样式&gt;外部样式</p><p>拓展： @import&#x2F;link</p><h4 id="import和link的区别"><a href="#import和link的区别" class="headerlink" title="@import和link的区别"></a>@import和link的区别</h4><p>适用范围不同：</p><p>@import可以再网页页面中引用，也可以再css中使用， 可以用来将多个css文件引入到网页页面当中， 而link只能将css文件引入到网页页面中</p><p>功能范围不同</p><p>link属于xhtml标签， @import是css提供的一种方式，link除了可以加载css之外，还可以定义rel连接属性，定义rss等，@import只能加载css</p><p>加载顺序不同：</p><p>页面被加载的时候， link引用的css会同时被加载，</p><p> @import引用的css会等到页面全部被下载再完全被加载</p><p>兼容性：</p><p>@import是css2.1提出的，所以老 的浏览器不支持， @import只有再IE5以上才能是被</p><p>控制样式时的差别</p><p>适用link范式库让用户切换css杨</p><h2 id="样式选择器"><a href="#样式选择器" class="headerlink" title="样式选择器"></a>样式选择器</h2><p>基本选择器： 标签选择器&#x2F;类选择器&#x2F;id选择器</p><h3 id="高级选择器"><a href="#高级选择器" class="headerlink" title="高级选择器"></a>高级选择器</h3><p>后代选择器  body p{}</p><p> 子选择器  &gt;</p><p>相邻兄弟选择器 +</p><p>  通用选择器</p><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p>标准文档流： 不布局</p><p>display： block&#x2F;inline&#x2F;inline-block</p><p>float: 浮动 left&#x2F;right</p><h2 id="rgba和opacity的透明度有什么不同"><a href="#rgba和opacity的透明度有什么不同" class="headerlink" title="rgba和opacity的透明度有什么不同"></a>rgba和opacity的透明度有什么不同</h2><p>opacity是一个属性，能被子元素继承，</p><p>rgba是一个属性值， rgba设置的元素，只对该元素的背景色有改变，不可被继承</p><h3 id="display：-none和-visibility：-hidden的区别"><a href="#display：-none和-visibility：-hidden的区别" class="headerlink" title="display： none和  visibility： hidden的区别"></a>display： none和  visibility： hidden的区别</h3><p>（1）在渲染树中</p><p>display:none会让元素完全从渲染树中消失，渲染时不会占据任何空间；<br>visibility:hidden不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。<br>（2）是否是继承属性</p><p>display:none是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；<br>visibility:hidden是继承属性，子孙节点消失是由于继承了hidden，通过设置visibility:visible可以让子孙节点显示；</p><h2 id="css的元素选择器"><a href="#css的元素选择器" class="headerlink" title="css的元素选择器"></a>css的元素选择器</h2><p>一、常用的选择器</p><p>1.元素选择器</p><p>2.类选择器(class选择器)</p><p>3.id选择器</p><p>4.通配符选择器</p><p>二、群组选择器</p><p> 三、关系选择器</p><p>1.后代选择器</p><p> 2.子代选择器</p><p>3.相邻兄弟选择器</p><p> 4.通用兄弟选择器</p><p>5.案例</p><p> 四、属性选择器</p><p> 五、伪类选择器</p><p>1.常用的伪类选择器</p><p> 2.否定伪类</p><p>3.元素的伪类</p><p>六、伪元素选择器</p><h3 id="css盒模型-1"><a href="#css盒模型-1" class="headerlink" title="css盒模型"></a>css盒模型</h3><h3 id="css选择器的优先级"><a href="#css选择器的优先级" class="headerlink" title="css选择器的优先级"></a>css选择器的优先级</h3><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404181034205.png" alt="image-20240418103414972"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404181035541.png" alt="image-20240418103550436"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404181037216.png" alt="image-20240418103705171"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404181040454.png" alt="image-20240418104026393"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404181041676.png" alt="image-20240418104109623"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404181043753.png" alt="image-20240418104340700"></p><h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404181047802.png" alt="image-20240418104712757"></p><h3 id="操作数组的方法"><a href="#操作数组的方法" class="headerlink" title="操作数组的方法"></a>操作数组的方法</h3><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404181048949.png" alt="image-20240418104820896"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404181049341.png" alt="image-20240418104941278"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404181050214.png" alt="image-20240418105034152"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404181051758.png" alt="image-20240418105148704"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404181052710.png" alt="image-20240418105220650"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404181053108.png" alt="image-20240418105311047"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404181054216.png" alt="image-20240418105424152"></p><h2 id="ES6新特性"><a href="#ES6新特性" class="headerlink" title="ES6新特性"></a>ES6新特性</h2><ol><li><p>块级作用域</p></li><li><p>新增列定义类的语法糖</p></li><li><p>新增了一种基本数据类型（symbol）</p></li><li><p>新增了解构赋值</p></li><li><p>新增了函数参数的默认值</p></li><li><p>数组新增了api</p></li><li><p>对象和数组都新增了扩展运算符</p></li><li><p>promise</p></li><li><p>模块化（import，export）</p></li><li><p>新增列set和map数据结构</p></li><li><p>新增了generator</p></li><li><p>新增了箭头函数</p></li></ol><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404181100071.png" alt="image-20240418110015996"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404181101820.png" alt="image-20240418110112768"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404181103511.png" alt="image-20240418110338457"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>html</title>
      <link href="/2024/04/17/html/"/>
      <url>/2024/04/17/html/</url>
      
        <content type="html"><![CDATA[<h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><h2 id="html5新增标签"><a href="#html5新增标签" class="headerlink" title="html5新增标签"></a>html5新增标签</h2><p>header，footer，nav，article，section，aside</p><p>video，audio</p><h2 id="常见的块元素，行内元素，三者有何不同"><a href="#常见的块元素，行内元素，三者有何不同" class="headerlink" title="常见的块元素，行内元素，三者有何不同"></a>常见的块元素，行内元素，三者有何不同</h2><h3 id="块："><a href="#块：" class="headerlink" title="块："></a>块：</h3><p>h1~h6,</p><p>div</p><p>p</p><p>ul,ol,li</p><p>块元素的特点：</p><p>独占一行，</p><p>高度和宽度，外边距可以空值</p><p>是一个容器及盒子，里面可以放行内或者块级元素</p><p><strong>注意</strong>： 文字类元素内不能使用块级元素， p标签主要用于存放文字， p标签里不能存放块级元素，不能放div</p><p>h1~h6都是文字类块级元素， 里面不能放其他元素</p><h3 id="行内"><a href="#行内" class="headerlink" title="行内"></a>行内</h3><p>a,span, em,u</p><h3 id="DOCTYPE的作用"><a href="#DOCTYPE的作用" class="headerlink" title="DOCTYPE的作用"></a>DOCTYPE的作用</h3><p>doctype是html5中一种标准通用语言的文档类型声明， 目的是告诉浏览器，应该以什么样的文档类型定义来解析文档， 不同的渲染模式会影响浏览器对css代码，甚至是javaScript脚本的解析</p><p>两种模式</p><p>css1compat： 默认模式，浏览器使用W3C的标准解析渲染页面</p><p>backCompat： 怪异模式，浏览器使用自己的怪异模式解析渲染页面， 再怪异模式中，页面以一种宽松模式的向后兼容的方式显示</p><h2 id="localStorage，-sessionStorage，cookie三者的明细区别"><a href="#localStorage，-sessionStorage，cookie三者的明细区别" class="headerlink" title="localStorage， sessionStorage，cookie三者的明细区别"></a>localStorage， sessionStorage，cookie三者的明细区别</h2><table><thead><tr><th></th><th>cookie</th><th>localstorage</th><th>sessionStorage</th></tr></thead><tbody><tr><td>存储大小</td><td>4kb</td><td>5M</td><td>5M</td></tr><tr><td>通讯相关</td><td>随请求携带</td><td>不会自动携带</td><td>不会自动携带</td></tr><tr><td>操作相关</td><td>操作发杂，无api</td><td>操作简单，有api，只能前端操作</td><td>操作简单，有api，只能前端操作</td></tr><tr><td>存储格式</td><td>字符串</td><td>键值对</td><td>键值对</td></tr><tr><td>失效相关</td><td>默认会话级别，可以收到设置</td><td>永久存储，手动删除后才会清除</td><td>永久存储，手动删除后才会清除</td></tr><tr><td>跨页面通讯</td><td></td><td>随便跨页面</td><td>只在本页面跳转通信</td></tr></tbody></table><p>cookie： 标识用户身份，而存储再用户本地段 的数据， </p><p>cookie数据始终再同源的http请求中携带， 即使不需要， 会再浏览器和服务器间来沪传递</p><p>sessionStoreage和localStorage不会自动把数据发送给服务器，仅在本地保存</p><p><strong>存储大小</strong></p><p>cookie：4 kb</p><p>sessionStoreage和localStorage： 虽然也有存储大小的限制，但是比cookie大得多，可以打到5m或者更大</p><p><strong>过期时间</strong></p><p>localStorage： 浏览器关闭后数据不丢失除非主动删除数据</p><p>sessionStorage 数据在当前浏览器窗口关闭后自动删除</p><p>cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p><h2 id="网站TDK三大标签以及SEO优化"><a href="#网站TDK三大标签以及SEO优化" class="headerlink" title="网站TDK三大标签以及SEO优化"></a>网站TDK三大标签以及SEO优化</h2><p>TDK是网站****标题（title）、描述（description）、关键词（keywords）****这三者的英文首字母缩写，主要用来对当前网页进行总结和概况。</p><p>在SEO界，<strong>标题、描述、关键词</strong>通常也被称为三大标签。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Axios</title>
      <link href="/2024/04/14/Axios/"/>
      <url>/2024/04/14/Axios/</url>
      
        <content type="html"><![CDATA[<h2 id="rest"><a href="#rest" class="headerlink" title="rest"></a>rest</h2><h3 id="传统服务器都是基于mvc模式实现的"><a href="#传统服务器都是基于mvc模式实现的" class="headerlink" title="传统服务器都是基于mvc模式实现的"></a>传统服务器都是基于mvc模式实现的</h3><p>model： 数据模型</p><p>View： 视图，用来呈现</p><p>controller： 控制器，加载数据并选择视图来呈现数据</p><p>传统的服务器： 直接返回一个页面，浏览器只需要显示页面</p><p>这个模式就是前后端不分离</p><p>这个模式的缺点： 传统服务器并不能适用于现在的应用场景</p><p>现在的应用场景： 一个应用由多个客户端存在， </p><p>web端， 移动端， pc端，这样每个端都有一个服务器</p><h3 id="现在的模式"><a href="#现在的模式" class="headerlink" title="现在的模式"></a>现在的模式</h3><p>后端只返回数据，</p><h3 id="rest-1"><a href="#rest-1" class="headerlink" title="rest"></a>rest</h3><p>： 一种服务器设计风格，只返回数据</p><p>数据传输格式： JSON ,两者之间数据传输是通过json实现的</p><p>get： 加载数据</p><p>post： 新建和添加数据</p><p>put： 添加和修改数据</p><p>patch： 修改数据</p><p>delete： 删除数据</p><p>option： 浏览器自动发送，检查请求的一些权限</p><h2 id="node-js编写api"><a href="#node-js编写api" class="headerlink" title="node.js编写api"></a>node.js编写api</h2><p>预备步骤： </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn init -y</span><br><span class="line">yarn add epress</span><br></pre></td></tr></table></figure><p>新建文件： 开写</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;);</span><br><span class="line">const app=express();</span><br><span class="line">app.get(&#x27;/&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">    res.send(&#x27;hello world&#x27;);</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000,()=&gt;&#123;</span><br><span class="line">    console.log(&#x27;server is running on port 3000&#x27;)；</span><br><span class="line">&#125;)</span><br><span class="line">app.get(&#x27;/&#x27;,(req,res)=&gt;&#123;</span><br><span class="line">    const obg=&#123;</span><br><span class="line">        name:&#x27;aa&#x27;,</span><br><span class="line">        age:15</span><br><span class="line">    &#125;</span><br><span class="line">    res.write(JSON.stringify(obg))  //不转化为json会报错</span><br><span class="line">    res.end()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Ajax简介"><a href="#Ajax简介" class="headerlink" title="Ajax简介"></a>Ajax简介</h3><p>A： 异步， J ： javaScript，  A 和xml</p><ul><li><p>异步的js和xml</p></li><li><p>它的作用就是通过js向服务器发送请求来加载数据</p></li><li><p>xm是早期ajax受用的数据格式，就是java的pom.xml文件</p></li><li><p>目前的数据格式： json</p></li><li><p>可选择的方式</p><ul><li>xmlHttprRequest（xhr） ：浏览器元素</li><li>Fetch：</li><li>Axios ：在xhr的基础上来做封装</li></ul></li><li><p>CORS : 跨域资源共享</p><ul><li><p>如果两个网站的完整域名不相同，就会出现跨域问题</p><p> <a href="http://haha.com/">http://haha.com</a></p><p><a href="http://heihei.com/">http://heihei.com</a> </p><p>这样就会有跨域问题</p></li><li><p>跨域检查三个东西</p><ul><li>协议 域名  端口号</li></ul></li><li><p>当我们通过ajax去发送跨域请求的时候， 会阻止JS 读取到服务器的数据</p></li><li><p>解决办法</p><ul><li><p>在服务器中设置一个允许跨域的头</p><p> Access-Control-Allow-Origion</p><ul><li><p>允许哪些客户端访问我们的服务器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.use((req,res)=&gt;&#123;</span><br><span class="line">    res.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;*&quot;)</span><br><span class="line">    //Access-Control-Allow-Origin : * ,设置时候只能设置一个客户端</span><br><span class="line">    //Access-Control-Allow-Methods : GET,POST,PUT,DELETE //允许请求的方法</span><br><span class="line">    res.setHeader(&quot;Access-Control-Allow-Methods&quot;,&quot;GET,POST,PUT,DELETE&quot;)</span><br><span class="line">    //Access-Control-Allow-Headers : Content-Type,Content-Length,Authorization,Accept,X-Requested-With //允许传递的请求头</span><br><span class="line">    res.setHeader(&quot;Access-Control-Allow-Headers&quot;,&quot;Content-Type,Content-Length,Authorization,Accept,X-Requested-With&quot;)</span><br><span class="line">next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p>客户端：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         </span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="xhr"><a href="#xhr" class="headerlink" title="xhr"></a>xhr</h4><p>  function  getdata() {<br>        console.log(1)<br>        &#x2F;&#x2F;创建一个新的xhr对象， xhr表示请求信息<br>       const xhr&#x3D;new XMLHttpRequest();<br>        xhr.onload&#x3D;function ()<br>        {<br>            console.log(xhr.status)<br>            if(xhr.status&#x3D;&#x3D;200)<br>                console.log(JSON.parse(xhr.response))<br>        }</p><pre><code>   //设置请求头    xhr.open(&#39;get&#39;,&#39;http://localhost:3000/&#39;);    //发送请求    xhr.send();    // console.log(xhr.response) //异步无法直接读取&#125;</code></pre><h4 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h4><ul><li><p>fetch是xhr的升级版，采用的是promise API</p></li><li><p>作用和AJAX一样的，使用起来更友好</p></li><li><p>fetch原生就是js支持的一种ajax请求 的方式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义请求的 URL、要更新的数据及其唯一标识（如 ID）</span><br><span class="line">const url = &#x27;https://example.com/api/data/123&#x27;; // 假设 123 是待更新数据的 ID</span><br><span class="line">const updatedData = &#123; key1: &#x27;new value1&#x27;, key2: &#x27;new value2&#x27; &#125;; // 示例数据，实际应替换为您的更新对象</span><br><span class="line">const headers = &#123;</span><br><span class="line">  &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 发起 PUT 请求</span><br><span class="line">fetch(url, &#123;</span><br><span class="line">  method: &#x27;PUT&#x27;,</span><br><span class="line">  headers,</span><br><span class="line">  body: JSON.stringify(updatedData),</span><br><span class="line">&#125;)</span><br><span class="line">  .then(response =&gt; &#123;</span><br><span class="line">    if (!response.ok) &#123;</span><br><span class="line">      throw new Error(`HTTP error! status: $&#123;response.status&#125;`);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return response.json();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(data =&gt; &#123;</span><br><span class="line">    console.log(&#x27;Updated data:&#x27;, data);</span><br><span class="line">    // 在这里可以进一步操作响应数据</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(error =&gt; &#123;</span><br><span class="line">    console.error(&#x27;Error updating data:&#x27;, error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> 前后端通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery</title>
      <link href="/2024/04/14/jquery/"/>
      <url>/2024/04/14/jquery/</url>
      
        <content type="html"><![CDATA[<h1 id="jquery"><a href="#jquery" class="headerlink" title="jquery"></a>jquery</h1><p>提供了代码操作dom库， 用更少的代码，完成相同的事</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log($) //向网页当中引入新的函数 //可以用$访问呢或这 jQuery</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dom对象</title>
      <link href="/2024/04/14/dom%E5%AF%B9%E8%B1%A1/"/>
      <url>/2024/04/14/dom%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="document"><a href="#document" class="headerlink" title="document"></a>document</h1><p>整个网页的对象，它包括html对象，比他大的是window</p><h2 id="通过id，clas，标签获取对象"><a href="#通过id，clas，标签获取对象" class="headerlink" title="通过id，clas，标签获取对象"></a>通过id，clas，标签获取对象</h2><h3 id="通过class和id，标签获取元素，匹配到全部元素，获取到数组"><a href="#通过class和id，标签获取元素，匹配到全部元素，获取到数组" class="headerlink" title="通过class和id，标签获取元素，匹配到全部元素，获取到数组"></a>通过class和id，标签获取元素，匹配到全部元素，获取到数组</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const btn=document.getElementsByClassName(&#x27;btn&#x27;)[0];</span><br><span class="line">const name=document.getElementsByClassName(&#x27;name&#x27;)[0];</span><br><span class="line"></span><br><span class="line">const all=document.getElementsByTagName(&#x27;div&#x27;) //根据标签</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="通用的方式获取元素，匹配到得到的第一个标签"><a href="#通用的方式获取元素，匹配到得到的第一个标签" class="headerlink" title="通用的方式获取元素，匹配到得到的第一个标签"></a>通用的方式获取元素，匹配到得到的第一个标签</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr=[&#x27;张三&#x27;,&#x27;李四&#x27;,&#x27;王麻子&#x27;,&#x27;小明&#x27;,&#x27;小蓝&#x27;,&#x27;小紫&#x27;]</span><br><span class="line">const btn=document.querySelector(&#x27;.btn&#x27;)  //不是实时更新</span><br><span class="line">const  name=document.querySelector(&#x27;.name&#x27;)</span><br></pre></td></tr></table></figure><h3 id="获取文本结点对象"><a href="#获取文本结点对象" class="headerlink" title="获取文本结点对象"></a>获取文本结点对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const div1=document.getElementById(&#x27;div1&#x27;)[0]</span><br><span class="line">// div1.firstChild//</span><br><span class="line">div1.textContent //获取文本内容 ，不包含标签</span><br><span class="line"></span><br><span class="line">div1.innerText //修改元素或者文本内容，不好含标签</span><br><span class="line">div1.innerHTML //修改元素中的html代码，包含标签</span><br></pre></td></tr></table></figure><h2 id="document-的继承树"><a href="#document-的继承树" class="headerlink" title="document 的继承树"></a>document 的继承树</h2><p>ducument -&gt;node-&gt;evnetTarget-&gt;object.prototype-&gt;bull</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.documentElement //html元素</span><br><span class="line">document.head//head元素</span><br><span class="line">document.title//title元素</span><br><span class="line">document.body//body元素</span><br><span class="line">document.body //body元素</span><br><span class="line">document.links //获取页面中所有的超链接</span><br></pre></td></tr></table></figure><h3 id="event"><a href="#event" class="headerlink" title="event"></a>event</h3><p>事件： 用户和用户之间的交互</p><p>事件三要素： 事件源，事件，回调函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ul.addEventListener(&#x27;click&#x27;,function(e)&#123;  //可以同时绑定多个函数</span><br><span class="line">    console.log(e)</span><br><span class="line">    if(e.target.tagName===&#x27;LI&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        console.log(e.target)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button onclick=&quot;alert(&#x27;你点我干嘛&#x27;)&quot;&gt;&lt;/button&gt;  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div.onclick=function()&#123;</span><br><span class="line">    alert(&#x27;点击了&#x27;)</span><br><span class="line">&#125;//只能绑定一个</span><br></pre></td></tr></table></figure><h2 id="xss注入"><a href="#xss注入" class="headerlink" title="xss注入"></a>xss注入</h2><p>就是在输入框里输入一段script代码，导网站出现不该有的内容（敏感信息，等） ，这种情况通常发生在根据输入内容创建tag</p><h3 id="如何解决XSS攻击"><a href="#如何解决XSS攻击" class="headerlink" title="如何解决XSS攻击"></a>如何解决XSS攻击</h3><p>防止手动创建元素</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const td=document.createElement(&#x27;td&#x27;) //输入要创建的tag</span><br><span class="line">const tr=document.getElementsByTagName(&#x27;tr&#x27;)[0]</span><br><span class="line">tr.appendChild(td)</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js面向对象</title>
      <link href="/2024/04/10/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2024/04/10/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="javaScript原始类型"><a href="#javaScript原始类型" class="headerlink" title="javaScript原始类型"></a>javaScript原始类型</h2><p>8种数据类型：</p><ul><li>数值：Number</li><li>大整数：BigInt</li><li>字符串： String</li><li>布尔值：Boolean</li><li>空值：Null</li><li>符号：symbol</li><li>对象： object</li></ul><h3 id="对象：-js种的一种复合数据类型"><a href="#对象：-js种的一种复合数据类型" class="headerlink" title="对象：  js种的一种复合数据类型"></a>对象：  js种的一种复合数据类型</h3><p>容器： 存储各种数据类型</p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj=new Object()</span><br><span class="line">console.log(obj)</span><br><span class="line">let obg=&#123;</span><br><span class="line">    name:&#x27;张三&#x27;,</span><br><span class="line">    age:18,</span><br><span class="line">    sex:&#x27;男&#x27;,</span><br><span class="line">    [&quot;food&quot;]:&quot;苹果&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(obg)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对象种可以添加多个类型的数据，对象种存储的数据称为属性</p><p>添加属性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj=new Object()</span><br><span class="line">obj.name=&#x27;张三&#x27;</span><br><span class="line">obj.age=  18</span><br><span class="line">obj.sex=&#x27;男&#x27;</span><br><span class="line">console.log(obj)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj=new Object()</span><br><span class="line">obj.name=&#x27;张三&#x27;</span><br><span class="line">obj.age=  18</span><br><span class="line">obj.sex=&#x27;男&#x27;</span><br><span class="line">console.log(obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//修改属性</span><br><span class="line">obj.name=&#x27;李四&#x27;</span><br><span class="line"></span><br><span class="line">//删除属性</span><br><span class="line">delete obj.age</span><br><span class="line">console.log(obj)</span><br></pre></td></tr></table></figure><h3 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete obj.age</span><br><span class="line">console.log(obj)</span><br><span class="line"></span><br><span class="line">//属性名可以是任何值，如果属性名太特殊，需要用[]来设置</span><br><span class="line">obj[&quot;fasdfsdf ddgsg&quot;]=&#x27;特殊属性&#x27;</span><br><span class="line">console.log(obj[&quot;fasdfsdf ddgsg&quot;])</span><br></pre></td></tr></table></figure><p>symbol作为属性名，用谁存的用谁取，用symbol添加的属性，通常是不希望被外界访问的属性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let mysybol=Symbol()</span><br><span class="line">console.log(mysybol)</span><br><span class="line"></span><br><span class="line">obj[mysybol]=&#x27;dfadffs&#x27;</span><br><span class="line">console.log(obj)</span><br></pre></td></tr></table></figure><h3 id="检查对象是否有属性"><a href="#检查对象是否有属性" class="headerlink" title="检查对象是否有属性"></a>检查对象是否有属性</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&quot;name&quot; in obj )//判断属性是否存在</span><br></pre></td></tr></table></figure><h3 id="枚举属性"><a href="#枚举属性" class="headerlink" title="枚举属性"></a>枚举属性</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let food=&#123;</span><br><span class="line">    appple:&#x27;苹果&#x27;,</span><br><span class="line">    banana:&#x27;香蕉&#x27;,</span><br><span class="line">    cheery:&#x27;车厘子&#x27;</span><br><span class="line">    [Symbol()]:&#x27;gg&#x27;</span><br><span class="line">&#125;</span><br><span class="line">for (let proporty in food)</span><br><span class="line">&#123;</span><br><span class="line">    console.log(proporty) //有几个属性就执行几次，但是不是所有属性都能被枚举，比如使用符号添加的属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象是一种可变类型："><a href="#对象是一种可变类型：" class="headerlink" title="对象是一种可变类型："></a>对象是一种可变类型：</h3><p>是开辟了一块内存存储10这个数值，把地址给了a，a&#x3D;5，给a重新赋值，然后把5的地址赋值给a所以是不可变类型</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let a=10;</span><br><span class="line">let b=10</span><br><span class="line">// a=5</span><br><span class="line">console.log(a===b)  true ，</span><br></pre></td></tr></table></figure><p>&#x2F;&#x2F;全等比较的是内存地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let og=obg //指向同一个对象地址</span><br><span class="line"></span><br><span class="line">console.log(og===obg)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let og=obg //指向同一个对象地址</span><br><span class="line">og=null //修改变量，对原对象无影响</span><br><span class="line">og.age=20//改对象</span><br><span class="line">console.log(og===obg)</span><br><span class="line">console.log(obg)</span><br></pre></td></tr></table></figure><p>所以一般用const赋值变量，禁止修改变量</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数也是一个对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1.函数式声明</span><br><span class="line">function f1()&#123;</span><br><span class="line">    console.log(&quot;f1&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//2.函数表达式</span><br><span class="line">const fn=function()&#123;</span><br><span class="line">    console.log(&quot;f2&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//箭头函数</span><br><span class="line">()=&gt;&#123;</span><br><span class="line">    console.log(&quot;f3&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const  get=() =&gt;&#123;</span><br><span class="line">    console(&#x27;good&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">const  g=( get)=&gt;&#123;</span><br><span class="line">    console.log(&#x27;how&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">//三种函数</span><br><span class="line">g(get) //传递函数的代码</span><br></pre></td></tr></table></figure><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>每次调用，都产生一个新的作用域</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>使用一个变量时，在当前作用域找，找不到，找上一层作用域找</p><p>函数也可以称为对象的一个属性</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g(get) //传递函数的代码</span><br><span class="line"></span><br><span class="line">obj.sayhi=get</span><br><span class="line">console.log(obj)</span><br></pre></td></tr></table></figure><p>how<br>{<br>  name: ‘李四’,<br>  sex: ‘男’,<br>  ‘fasdfsdf ddgsg’: ‘特殊属性’,<br>  sayhi: [Function: get],<br>[Symbol()]: ‘dfadffs’<br>}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var c=2;</span><br><span class="line">function  fn ()</span><br><span class="line">&#123;</span><br><span class="line">    console.log(c) //undefined</span><br><span class="line">    var c=1;</span><br><span class="line">    console.log(c)//1</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line">console.log(c)//2</span><br></pre></td></tr></table></figure><h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//立即执行函数,前后要加分号</span><br><span class="line">    (function  how()&#123;</span><br><span class="line">        console.log(&#x27;立即执行&#x27;)</span><br><span class="line">    &#125;());</span><br></pre></td></tr></table></figure><h3 id="隐含-this"><a href="#隐含-this" class="headerlink" title="隐含 this"></a>隐含 this</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fn1()&#123;</span><br><span class="line">    console.log(this)//window</span><br><span class="line">&#125;</span><br><span class="line">fn1()  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    function fn1()&#123;</span><br><span class="line">        console.log(this)//window</span><br><span class="line">    &#125;</span><br><span class="line">    // fn1()</span><br><span class="line">obj.say=fn1</span><br><span class="line">console.log(obj.say())  //this变成了obj</span><br></pre></td></tr></table></figure><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>js中运行代码有两种： 严格模式+正常模式</p><p>正常模式： 语法检查并不严格，能不报错就不报错</p><p>严格模式： 语法检查严格，禁止一些语法</p><p>在代码开头些 use strict ，</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const  five=&#123;</span><br><span class="line">    name:&#x27;五子棋&#x27;,</span><br><span class="line">    age:18,</span><br><span class="line"></span><br><span class="line">    play()&#123;</span><br><span class="line">        console.log(&#x27;五子棋开始&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    win() &#123;</span><br><span class="line">        console.log(&#x27;五子棋赢了&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(five)</span><br></pre></td></tr></table></figure><p>创建对象的方法：</p><ul><li><p>Object创建，无法区分出不同的对象， 不方便批量创建对象</p></li><li><p>js中通过类模板床架对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Dog&#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        this.name=name</span><br><span class="line">        this.age=age</span><br><span class="line">    &#125;</span><br><span class="line">    eat()&#123;</span><br><span class="line">        console.log(&#x27;吃东西&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const doga=new Dog(&#x27;小黑&#x27;,18)</span><br><span class="line">const dogb=new Dog(&#x27;小黑&#x27;,18)</span><br><span class="line">console.log(doga)</span><br><span class="line">console.log(dogb)</span><br><span class="line">console.log(typeof doga)</span><br><span class="line">console.log(doga==dogb)</span><br></pre></td></tr></table></figure><h3 id="静态属性：-只能通过类去访问"><a href="#静态属性：-只能通过类去访问" class="headerlink" title="静态属性： 只能通过类去访问"></a>静态属性： 只能通过类去访问</h3></li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Dog&#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">    static o=&quot;11&quot;</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        this.name=name</span><br><span class="line">        this.age=age</span><br><span class="line">    &#125;</span><br><span class="line">    eat()&#123;</span><br><span class="line">        console.log(&#x27;吃东西&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(Dog.o)</span><br></pre></td></tr></table></figure><h3 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class Dog&#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">    static o=&quot;11&quot;</span><br><span class="line">    #oop</span><br><span class="line">    constructor(name,age,oop)&#123;</span><br><span class="line">        this.name=name</span><br><span class="line">        this.age=age</span><br><span class="line">    &#125;</span><br><span class="line">    eat()&#123;</span><br><span class="line">        console.log(&#x27;吃东西&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const doga=new Dog(&#x27;小黑&#x27;,18,&#x27;f&#x27;)</span><br><span class="line">const dogb=new Dog(&#x27;小黑&#x27;,18,&#x27;f&#x27;)</span><br><span class="line">console.log(doga.oop)</span><br></pre></td></tr></table></figure><p>私有属性无法从外部访问</p><h2 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h2><p>对象中存储属性的区域实际有两个：</p><ol><li><p>对象自身</p><ul><li>直接通过对象添加的属性</li><li>在类中通过 X&#x3D;Y形式添加的属性位于对象自身</li></ul></li><li><p>原型对象（prototype）</p><ul><li><p>对象中还有一些内容， 会存储到其他对象里</p></li><li><p>对象中会有一个属性用来存储原型对象，这个属性叫做__proto_</p></li><li><p>原型对象也负责为对象存储属性</p><ul><li><p>当我们访问对象中的属性时，优先访问对象自身的属性</p></li><li><p>如果没有的话， 就去原型中寻找</p><ul><li><p>在类中 xxx（）{} 方式添加的方法， 位于原型中</p><p>​       xxx &#x3D;（）{} 添加到对象自身当中</p></li></ul></li></ul></li></ul></li></ol><h3 id="如何访问原型对象"><a href="#如何访问原型对象" class="headerlink" title="如何访问原型对象"></a>如何访问原型对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(doga.__proto__)</span><br><span class="line">或者</span><br><span class="line">console.log(Object.getPrototypeOf(doga)) 更安全</span><br></pre></td></tr></table></figure><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404131418115.png" alt="image-20240413141832010"></p><p>原型对象的中的数据</p><ul><li><p>对象中的数据方法， </p></li><li><p>constructor（对象中的构造函数）、，就是类中的代码</p></li><li><pre><code>class Dog&#123;        name        age        static o=&quot;11&quot;        #oop        constructor(name,age,oop)&#123;            this.name=name            this.age=age        &#125;        eat()&#123;            console.lo…                        <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 原型对象也有原型 两个proto有值，三个就是null，根据对象的复杂程度不同， 原型链的长度也不同</span><br><span class="line"></span><br><span class="line">  ```</span><br><span class="line">  console.log(doga.__proto__.__proto__.__proto__)</span><br><span class="line">  ```</span><br><span class="line"></span><br><span class="line">- 读取对象属性的时候， 会优先对象自身属性</span><br><span class="line"></span><br><span class="line">  - 如果对象中有，则使用， 没有则去原型的原型中寻找</span><br><span class="line">  - 知道找到Object对西电原型，如果依然没有则返回undefined</span><br><span class="line"></span><br><span class="line">- 作用域链：找不到会报错， </span><br><span class="line"></span><br><span class="line">  **所有通类型对象的原型对象只有一个（一个类）**</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### 原型的作用</span><br><span class="line"></span><br><span class="line">原型就是一个公共的区域，可以被所有该类实例访问</span><br><span class="line"></span><br><span class="line">- 将一个该类实例所有的公共属性，统一存储到原型当中</span><br><span class="line">- 这样我们就只需要创建一个属性，即可被所有实例访问</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 在对象中有的值时对象独有的， 有的值对每个对象来说都是一样的， 对于一样的值没有必要重复的创建</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### js继承就是通过原型来实现的</span><br><span class="line"></span><br><span class="line">- 当继承的时候， 子类的原型就是一个父类的实例</span><br><span class="line"></span><br><span class="line">- 如何修改原型，</span><br><span class="line"></span><br><span class="line">  - 通过对象修改原型， 向原型中添加方法， 修改后所有同类都能访问该方法</span><br><span class="line"></span><br><span class="line">     问题：  影响其他对象的方法，破坏封装性</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    console.log(doga.__proto__)</span><br><span class="line">    doga.__proto__.run=()=&gt;&#123;</span><br><span class="line">        console.log(&quot;我跑起来了&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    console.log(dogb.__proto__)</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">  ​      ![image-20240413150945178](https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404131509317.png)</span><br><span class="line"></span><br><span class="line">  -  为对象赋值一个新的原型</span><br><span class="line"></span><br><span class="line">    ```</span><br><span class="line">    doga.__proto__=new five()</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">    ![image-20240413151500951](https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404131515989.png)</span><br><span class="line"></span><br><span class="line">  - 通过类访问实例的原型对象也可，修改原型直接在类上修改即可</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    Dog.__proto__.fly=()=&gt;&#123;</span><br><span class="line">        console.log(&quot;我在飞&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(doga.__proto__)</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    ![image-20240413152635218](https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404131526257.png)</span><br><span class="line"></span><br><span class="line">  -  原型尽量不要手动改</span><br><span class="line">  - 要改也不要通过实例取修改</span><br><span class="line">  - 通过类.prototype属性取修改</span><br><span class="line">  - 最好不要直接给prototype取赋值</span><br><span class="line"></span><br><span class="line">  ### in检查属性</span><br><span class="line"></span><br><span class="line">  in 运算符检查属性时， 无论属性是否在对象还是自身还是原型当中，都会返回true，包括原型对象</span><br><span class="line"></span><br><span class="line">  ###  hasOwnProperty</span><br><span class="line">  </span><br><span class="line">  检查属性是否在对象实例当中，不包括原型对象</span><br><span class="line">  </span><br><span class="line">  ### hasOwn ： 推荐使用</span><br><span class="line">  </span><br><span class="line">  检查对像自身是否包含某个属性，不包括原型，原因如果没有继承的hasOwnProperty的话，会报错</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  ## 就类</span><br><span class="line">  </span><br><span class="line">  早期的JS定义类</span><br><span class="line">  </span><br><span class="line">  ### 函数</span><br><span class="line">  </span><br></pre></td></tr></table></figure>function()&#123;&#125;//直接调用就是一个普通函数//new 来调用就是一个构造函数<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">###  var person=（function（）&#123;&#125;） （）</span><br><span class="line"></span><br></pre></td></tr></table></figure>var Person=(function() &#123;&#125;)()  把所有的过程全部放进去，包括对原型对象的修改<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### new 发生的过程</span><br><span class="line"></span><br><span class="line">-   创建一个普通的js对象， Object&#123;&#125;</span><br><span class="line">-    将构造函数的prototype属性设置为新对象的原型</span><br><span class="line">- 使用实参来执行狗仔函数，并且将新对象设置为函数中的this</span><br><span class="line">- 如果构造函数返回的是一个非原始值， 则该值会作为new运算的返回值返回，  如果构造函数返回的是一个原始值，或者没有指定返回值， 则新队将会作为返回值返回</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 常见对象</span><br><span class="line"></span><br><span class="line">对象分类</span><br><span class="line"></span><br><span class="line">- 内建对象</span><br><span class="line"></span><br><span class="line">  比如ES标准定义的对象： Object ，Function， string， Number等</span><br><span class="line"></span><br><span class="line">- 宿主对象</span><br><span class="line"></span><br><span class="line">   由浏览器提供的对象： window</span><br><span class="line"></span><br><span class="line">  document ：BOM, DOM</span><br><span class="line"></span><br><span class="line">- 自定义对象</span><br><span class="line"></span><br><span class="line">   自己写出来的对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 内建对象</span><br><span class="line"></span><br><span class="line">### 数组 </span><br><span class="line"></span><br><span class="line">创建数组的两种方式</span><br><span class="line"></span><br></pre></td></tr></table></figure>const arr=new Array();const  arr1=[]console.log(arr)console.log(arr1)arr[0]=77arr[99]=100console.log(arr)console.log(arr[0])const  arr1=[]console.log(arr)console.log(arr1)arr[0]=77arr[99]=100console.log(arr)console.log(arr[0])console.log(typeof arr)//objectconsole.log(arr instanceof Array)//判断对象是否是数组console.log(arr.length)//数组长度arr[arr.length-1]=1  //数组的最好增加元素arr.length=11//修改数组长度console.log(arr)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">  #### 数组的遍历</span><br><span class="line">  </span><br><span class="line">  #### for循环</span><br><span class="line">  </span><br><span class="line">  ```</span><br><span class="line">  arr2=[1,2,&#x27;hello&#x27;,true] //不限制数组的数据类型，但是尽量确保数组的类型相同</span><br><span class="line">  for (let i = 0; i &lt; arr2.length; i++) &#123;</span><br><span class="line">      console.log(arr2[i])</span><br><span class="line">  &#125;</span><br><span class="line">  ```</span><br><span class="line">  </span><br><span class="line">  #### for-of ：对象，字符串， 都能遍历 ，可迭代的对象</span><br><span class="line">  </span><br><span class="line">  ```</span><br><span class="line">  for (let i of arr2)</span><br><span class="line">  &#123;</span><br><span class="line">      console.log(i)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  for (let value of &quot;hello0&quot;)</span><br><span class="line">  &#123;</span><br><span class="line">      console.log(value)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ```</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  #### 其他方法</span><br><span class="line">  </span><br><span class="line">  ```</span><br><span class="line">  console.log(Array.isArray(arr)) //判断是否是数组</span><br><span class="line">  </span><br><span class="line">  //at 获取数组中的元素</span><br><span class="line">  console.log(arr.at(0))</span><br><span class="line">  // contact用来连接数组</span><br><span class="line">  const arr3=arr.concat(arr2)</span><br><span class="line">  console.log(arr3)</span><br><span class="line">  ```</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  #####  数组的方法</span><br><span class="line">  </span><br><span class="line">  ##### index of方法： 获取元素在数组中第一次出现的索引</span><br><span class="line">  </span><br><span class="line">   插叙元素，查询元素第一次出现的位置</span><br><span class="line">  </span><br><span class="line">  ```</span><br><span class="line">  console.log(arr2.indexOf(1))  </span><br><span class="line">  ```</span><br><span class="line">  </span><br><span class="line">  ##### join：将数组中的方法拼接成字符串</span><br><span class="line">  </span><br><span class="line">  ```</span><br><span class="line">  //join : 将数组中的元素连接成一个字符串</span><br><span class="line">  console.log(arr2.join(&#x27;-&#x27;))</span><br><span class="line">  ```</span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line">  </span><br><span class="line">  #### slice： 截取数组（非破坏性方法）</span><br><span class="line">  </span><br><span class="line">  - 参数</span><br><span class="line">  </span><br><span class="line">    1. 截取的做闭右开，包左不包右</span><br><span class="line">  </span><br><span class="line">       ```</span><br><span class="line">       console.log(arr2.slice(0,2))</span><br><span class="line">       ```</span><br><span class="line">  </span><br><span class="line">             2. 第二个参数不写，截取全部，则会</span><br><span class="line">             2. 参数不写，可以对数组进行浅拷贝</span><br><span class="line">  </span><br><span class="line">  ###  深拷贝和浅拷贝</span><br><span class="line">  </span><br><span class="line">  通常对象的拷贝都是浅拷贝</span><br><span class="line">  </span><br><span class="line">  ##### 浅拷贝： 就是对对象的浅层进行赋值（只赋值一层） ： 新建一个对象，指向原对象指向的地址</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  ```</span><br><span class="line">  const arr4=[&#123;name:&#x27;gg&#x27;&#125;,&#123;name:&#x27;bb&#x27;&#125;]</span><br><span class="line">  //浅拷贝</span><br><span class="line">  const  arr5=arr4</span><br><span class="line">  arr4[0].name=&#x27;aa&#x27;</span><br><span class="line">  console.log(arr5)</span><br><span class="line">  console.log(arr4)</span><br><span class="line">  ```</span><br><span class="line">  </span><br><span class="line">  ![image-20240413205057767](https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404132050941.png)</span><br><span class="line">  </span><br><span class="line">  深拷贝：  对象中存储的是原始值，那么深浅不重要： 不仅复制对象本身，还复制对象中的属性和元素</span><br><span class="line">  </span><br><span class="line">  ```</span><br><span class="line">  const arr4=[&#123;name:&#x27;gg&#x27;&#125;,&#123;name:&#x27;bb&#x27;&#125;]</span><br><span class="line">  //浅拷贝</span><br><span class="line">  const  arr5=arr4</span><br><span class="line">  </span><br><span class="line">  const arr6=structuredClone(arr4) //深拷贝</span><br><span class="line">  arr4[0].name=&#x27;aa&#x27;</span><br><span class="line">  console.log(arr5)</span><br><span class="line">  console.log(arr4)</span><br><span class="line">  console.log(arr6)</span><br><span class="line">  ```</span><br><span class="line">  </span><br><span class="line">  ![image-20240413205215776](https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404132052810.png)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  ##### assign: 赋值</span><br><span class="line">  </span><br><span class="line">  ```</span><br><span class="line">  const arr7=Object.assign([],arr5);</span><br><span class="line">  console.log(arr7)</span><br><span class="line">  ```</span><br><span class="line">  </span><br><span class="line">  #### 破坏性的方法</span><br><span class="line">  </span><br><span class="line">  ###### push： 向上数组的末尾添加元素</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  pop： 删除最后一个元素，并返回最后一个元素</span><br><span class="line">  </span><br><span class="line">  unshift： 在数组的首部插入元素</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  ### splice： 删除区间splice（1，2） </span><br><span class="line">  </span><br><span class="line">  splice（1，1，“1”，“2”，“3”）,删除1位置的1个元素，并且插入1，2，3</span><br><span class="line">  </span><br><span class="line">  ##### 对数组去重</span><br><span class="line">  </span><br><span class="line">  - 简单的：  </span><br><span class="line">  </span><br><span class="line">  ### 高阶函数</span><br><span class="line">  </span><br><span class="line">  动态成一个函数： 参数中可以传递函数</span><br><span class="line">  </span><br><span class="line">  ```</span><br><span class="line">  function sum(arr )&#123;</span><br><span class="line">      let su=0;</span><br><span class="line">      console.log(arr)</span><br><span class="line">      if(arr instanceof  Array)</span><br><span class="line">      &#123;for(value of arr)</span><br><span class="line">      &#123;</span><br><span class="line">          su+=value</span><br><span class="line">      &#125;&#125;</span><br><span class="line">      return su;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  function log(cn, arr)</span><br><span class="line">  &#123;</span><br><span class="line">      console.log(arr)</span><br><span class="line">      console.log(&#x27;正在执行&#x27;+typeof cn.name)</span><br><span class="line">      cn(arr)</span><br><span class="line">  &#125;</span><br><span class="line">  ar=[1,2,3,4,5]</span><br><span class="line">  </span><br><span class="line">  log(sum,ar)</span><br><span class="line">  ```</span><br><span class="line">  </span><br><span class="line">  ### 函数闭包</span><br><span class="line">  </span><br><span class="line">  创建一个函数： 感觉像是函数里面封装了一个函数，里面的函数可以使用外面函数的值</span><br><span class="line">  </span><br><span class="line">  函数嵌套， 内部函数引用外部函数变量，内部函数作为返回值</span><br><span class="line">  </span><br><span class="line">  每次调用都会产生一个新的闭包，</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  ### 数组foreach遍历</span><br><span class="line">  </span><br><span class="line">  ```</span><br><span class="line">  arr6.forEach((value)=&gt;&#123;</span><br><span class="line">      console.log(value)</span><br><span class="line">  &#125;)</span><br><span class="line">  ```</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">### filter 过滤数组中的元素</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">const res=arr8.filter((value) =&gt;&#123;</span><br><span class="line">    if(value&gt;1)</span><br><span class="line">       return true</span><br><span class="line">    else</span><br><span class="line">        return false</span><br><span class="line">&#125;)</span><br><span class="line">console.log(res)</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">![image-20240413231635626](https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404132316863.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### map ：根据当前数组生成一个新数组</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">console.log(res)</span><br><span class="line">const va=arr8.map((value)=&gt;&#123;</span><br><span class="line">    if(value&gt;1)</span><br><span class="line">        return 1</span><br><span class="line">    else</span><br><span class="line">        return  0</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### reduce函数</span><br><span class="line"></span><br><span class="line">将数组中的所有元素整合成一个值</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">const res1=arr8.reduce((pre,value)=&gt;&#123;</span><br><span class="line">    pre+=value</span><br><span class="line">    return pre</span><br><span class="line">&#125;)</span><br><span class="line">console.log(res1)</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 函数的可变参数： </span><br><span class="line"></span><br><span class="line">//没有定义形参，可以之际访问到传递的参数</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">function add() &#123;</span><br><span class="line"></span><br><span class="line">    console.log(arguments.length)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add() 0</span><br><span class="line">add(1)1</span><br><span class="line">add(1, 2)2</span><br><span class="line">add(1,2,3)3</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">function  sum()</span><br><span class="line">&#123;</span><br><span class="line">    let result=0</span><br><span class="line">    for(let num of arguments)</span><br><span class="line">    &#123;</span><br><span class="line">        result+=num</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum(1,2,3,4,5))</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可变参数</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">function  sum2(...args)  //参数名可以自己指定</span><br><span class="line">&#123;</span><br><span class="line">    let result=0</span><br><span class="line">    for(let i=0;i&lt;args.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result+=args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum2(1,2,3,4,5)) //15</span><br><span class="line">function  sum3(a,...args)</span><br><span class="line">&#123;</span><br><span class="line">    let result=0</span><br><span class="line">    for(let i=0;i&lt;args.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result+=args[i]</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum3(1,2,3,4,5))//14</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### this</span><br><span class="line"></span><br><span class="line">1. 以函数形式调用，this是window</span><br><span class="line">2. 以方式形式调用， this是调用方法的对象</span><br><span class="line">3. 以构造函数形式调用，this是新建的对象</span><br><span class="line">4. 以箭头形式调用， 由外层作用域决定</span><br><span class="line"></span><br><span class="line">### 函数调用方法</span><br><span class="line"></span><br><span class="line">apply，call，bind区别</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">function  fn()</span><br><span class="line">&#123;</span><br><span class="line">    console.log(this) //window</span><br><span class="line">&#125;</span><br><span class="line">const  obj=&#123;</span><br><span class="line">    name:&quot;obj&quot;,</span><br><span class="line">    fn:fn</span><br><span class="line">&#125;</span><br><span class="line">// obj.fn() //打印obj</span><br><span class="line">//函数嗲用的其他方法</span><br><span class="line">fn.call() //打印window</span><br><span class="line">//可以通过call或者apply调用函数</span><br><span class="line">//这样做的用处</span><br><span class="line">//apply和call可以指定函数中的this</span><br><span class="line">//传递的参数就是this</span><br><span class="line">fn.apply(obj) //打印obj</span><br><span class="line">fn.call(1)//打印1</span><br><span class="line"></span><br><span class="line">//call和apply的区别</span><br><span class="line">function  fn1(a,b)</span><br><span class="line">&#123;</span><br><span class="line">    console.log(a,b)</span><br><span class="line">&#125;</span><br><span class="line">fn1.call(1,2,obj) </span><br><span class="line">fn.apply(1,2,obj) //报错 ，通过apply需要把所有的实参放在数组当中</span><br><span class="line">fn1.apply(obj,[1,2])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// bind 可以返回一个函数，这个函数的this绑定了obj</span><br><span class="line">function  fn2()</span><br><span class="line">&#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">const fn3=fn1.bind(obj,1,2) </span><br><span class="line">fn3()//a，b参数已经固定</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### 解构赋值</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">let [a,b,c]=[1,2,3];</span><br><span class="line">let &#123;name,age,gender&#125; =obj //对象结构赋值 ,如果先声明，再结构，需要括号外加（），避免出现，被编译器误认为是代码块</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(a,b,c) 不对应就是undefined ，聊条结构赋值语句要加分号</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">### 对像序列化</span><br><span class="line"></span><br><span class="line">JS中的对象都是存储在计算机的内存当中的，js序列化是指将对象转化成一个可以存储的格式， </span><br><span class="line"></span><br><span class="line">JS序列化通常是指将一个对象转化成字符串，</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">const dog1=JSON.stringify(dog)</span><br><span class="line">console.log(dog1) //序列化</span><br><span class="line">//反序列化</span><br><span class="line">const dog2=JSON.parse(dog1)</span><br><span class="line">console.log(dog2)</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### map </span><br><span class="line"></span><br><span class="line">： 键值对数据类型， 比如说Object可以认为是一周key-value数据类型</span><br><span class="line"></span><br><span class="line">非普通的数据类型要加【】，</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul><p>const obj2&#x3D;{<br>    ‘name’:’zhang’,<br>    [obj]:obj</p><p>}<br>&#x2F;&#x2F;<br>打印：<br>{<br>  name: ‘zhang’,<br>  ‘[object Object]’: { name: ‘obj’, fn: [Function: fn] }<br>}</p><pre><code>// 其他方式创建map ：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const mm=new Map()</span><br><span class="line">mm.set(&#x27;name&#x27;,&#x27;fff&#x27;)</span><br><span class="line">mm.get(&#x27;name&#x27;)</span><br><span class="line">console.log(mm)</span><br><span class="line">mm.values() :获取所有value</span><br><span class="line">mm.keys() :获取所有key</span><br><span class="line">map.entries() :获取所有键值对</span><br><span class="line"></span><br></pre></td></tr></table></figure>### set创建一个集合<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const set=new Set()</span><br><span class="line">set.add(&#x27;dd&#x27;)</span><br><span class="line">set.add(1)</span><br><span class="line">//获取set中的元素</span><br><span class="line">const arrp=[...set] //按照顺序获取元素需要转化成数组</span><br></pre></td></tr></table></figure>### Math### Date的格式化<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//格式化</span><br><span class="line">console.log(today.toLocaleDateString())</span><br><span class="line"></span><br><span class="line">console.log(today.toLocaleDateString(&quot;zh-HK&quot;))</span><br><span class="line"></span><br><span class="line">console.log(today.toLocaleDateString(&quot;zh-TW&quot;))</span><br><span class="line"></span><br><span class="line">console.log(today.toLocaleDateString(&quot;en-US&quot;))</span><br><span class="line">//第二个参数，可以通过兑现属性对日期格式进行配置</span><br><span class="line">// dateStyle ；日期的风格</span><br><span class="line">//timeStyle： 时间的风格</span><br><span class="line">// full</span><br><span class="line">console.log(today.toLocaleDateString(&quot;zh-TW&quot;,&#123;weekday:&quot;long&quot;&#125;))</span><br></pre></td></tr></table></figure>### 正则正则表达式用来定义一个规则： 通过这个规则计算机可以用来检查一个字符串是否符号规则， 或者将字符串中符号规则的内容提取出来， 正则表达式也是JS中的一个兑现， 所以要使用正则表达式需要先创建正则表达式的兑现<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let reg=new RegExp(&quot;a+&quot;,&quot;i&quot;)//第一个参数就是匹配规则。 第二个参数是标志， 匹配模式</span><br><span class="line">//规则：[]:表示字符集 [A-Z] [a-z] ,[a-zA-Z]   |:表示或   [^]:表示除了</span><br><span class="line">// let a=/abc|bcd/  /[a-z]/  /^a/ :以a开头</span><br><span class="line">// /a&#123;3&#125;/ 匹配3个a  &#123;m&#125; 量词  /[a-z]&#123;3&#125;  表示3个字符 &#123;m,&#125;表示至少m个  &#123;m,n&#125; m-n个字符 + ：表示一个以上  *：表示任意数量，</span><br><span class="line">//跟编译原理的有点子像</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">let g=/a/g //reg和g等价  后面的i表示忽略大小写， g表示全局匹配,每次调用，找到复合标志的下一个， m表示匹配多行， s表示匹配多行， u表示匹配unicode字符，y表示匹配粘性</span><br><span class="line">console.log(g.exec(&quot;Aaaba////a&quot;))  //找到复合条件的内容</span><br><span class="line"></span><br><span class="line">console.log(g.exec(&quot;Aaaba////a&quot;))  //找到复合条件的内容</span><br><span class="line">console.log(g.exec(&quot;Aaaba////a&quot;))  //找到复合条件的内容  d表示任意数字</span><br></pre></td></tr></table></figure>### 字符串<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 字符串拆分</span><br><span class="line"> // result = str.split(&quot;正则&quot;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 字符串拆分</span><br><span class="line"> // result = str.split(&quot;正则&quot;)</span><br><span class="line"></span><br><span class="line">//字符串的替换 </span><br><span class="line">//str.replace(&#x27;正则&#x27;，target) 复合正则表达式的做替换</span><br></pre></td></tr></table></figure></code></pre><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> js核心原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html入门</title>
      <link href="/2024/04/10/html%E5%85%A5%E9%97%A8/"/>
      <url>/2024/04/10/html%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><p>标签分类：</p><p>单标签：br，h</p><p>双标签：</p><p>html骨架</p><p>标签的关系： 父子关系（嵌套）， 兄弟关系（平级）</p><p>注释 </p><p><code>&lt;!-- &lt;/html&gt; --&gt;</code></p><p> <code>标题标签</code> </p><p><code>新闻标题，文章标题， 网页区域名称，产品名称</code></p><p><code>标签名： h1-&gt;h6 (双标签)</code></p><p><code>h1一般放新闻标题或者网页的logo</code></p><p> <code>段落标签</code> </p><p><code>双标签： p</code></p><p><code>特点独占一行，段落之间存在间隙</code></p><p><code>根据如哪方端,总理先由晚一右翼盟领导人纳夫搭利贝内特担任,拉皮德任候任总理,外长,两人在约两年后轮换总理</code></p><p><code>这层以色列不到四年内的第五次大透.2222年4月至2223年3月,以色列继行了四次议会透举,223年6月,以色列议会</code></p><p><code>然而,这一为了推动内继品亚确下台违到一起油觉执政联盟好最不长.加之内塔亚胡资导的反对派展开猛烈攻势,这一</code></p><p><code>政联盟上台仅约一年助间.今年4月以来,两名议员相链退出贝内特领导的执政联盟,导数执政联盟议席从61席减至S59</code></p><p><code>最终通过拉皮德搜出姐澜方案,终精了内塔品亚机连续12年的执改生理.</code></p><p><code>标签名:P(双标签</code></p><p><code>独占一行</code></p><p><code>段落之间存在间隙</code></p><p>示特点:</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711976541335-b4ef434b-cdc8-4267-b38b-ee92841f297d.png?x-oss-process=image/format,webp" alt="image.png"></p><p> 换行和水平线标签 </p><p>换行： <br>  单表签，浏览器不识别enrter 换行符</p><p> 水平线：<hr>     单表签</p><p>文本格式化标签</p><p>加粗： <strong> </strong></p><p>倾斜： <em> </em></p><p>下划线： <ins> </ins></p><p>删除线： <del></del></p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711977126097-ec9c0380-ab77-478a-a136-bc050ebafdf5.png?x-oss-process=image/format,webp" alt="image.png"></p><p> 图像标签 </p><p>&lt;img src&#x3D;”图片的URL“&gt;’</p><p>图片标签</p><p>&lt;img src&#x3D;”url” alt &#x3D;”如果图片无法显示，进行替换&gt;</p><p>&lt;img src&#x3D;”url” titile  &#x3D;”鼠标悬浮在图片，上显示的文字”&gt;</p><p><img src="D:\myblog\myblog\source\_posts\url" with="100"> 更改图片大小</p><p> 相对路径和绝对路径 </p><p>相对路径： 当前文件出发找目标</p><p>绝对路径： 从盘符触发找目标</p><p>从根路径出发找目标</p><p> 超链接标签 </p><p><a href ="www.baidu.com">友情连接<a></p><p>&lt;a href &#x3D;”www.baidu.com" target="_blank&gt;友情连接<a></p><p>在新窗口打开一个连接</p><p> 音频标签 </p><p><audio src="音频URL" > </audio> 没有播放键</p><p><audio src="音频URL"  corntrols> </audio> 生成播放键</p><p><audio src="音频URL"  loops> </audio> 循环播放键</p><p><audio src="音频URL"  autoplay> </audio> 循环播放键</p><p> 视频标签 </p><p><video  src="./ media/vue.mp4" controls loops> </vdieo>  播放键+循环</p><p><video  src="./ media/vue.mp4" controls loops muted> </vdieo>  播放键+循环</p><p>muted： 静音</p><p> 综合案例 </p><p>综合案例二-VUE简介</p><p>门白意意,活做位面,油省精心图只关注巧质您,干位期手上事,还使于与第三方库或质有请们整自,炒一万黑,热与动化本</p><p>砂小量一意构请期户界置的彩产式有芝,与其他复量必植芝下国的量,V平用自高肉上苹最用发的计,V砂的核心炼凡关注无型</p><p>V(法酯AG,员红于V)量一富用于内注同户界我的至进式AV6组奖.(闪]马其它大支程证下果量.V被设计为司</p><p>他融份目登定更量分,宜型定理年时立有或户有进自数典,号一方型,地庭全有验力证处局数文师资付V光生之系使支期等</p><p>再摄以及各和支5兰车话合使用时,V也实全址能为复品单员位用(S&#x2F;A)请病能站</p><p>从油水的用机型通过祝[钟怎地的A方变空企或数发质S值合写置值件</p><p>K白有下型一个全美切架一空只聚营于药加,国包交单其在甜等习,单其谷是与其</p><p>于量变度-2使[(习,水也让复的使墨应理</p><p>从上到下</p><p>逐步分析</p><p>案例</p><p>开罗的复卖单类应间</p><p>其门者为光西面</p><p>VUE.IS</p><p>主要功能</p><p>金</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711982190575-b3241c37-1697-40e3-9c61-05b853eeaba6.png?x-oss-process=image/format,webp" alt="image.png"></p><p> 第二次课 </p><p> 列表，表格，表单 </p><p>小米高城A手机自助检测上线13项手机专次目量</p><p>高级款往人才运利</p><p>荣TIV折叠屏手机外观设计曝光:猫载装龙8</p><p>微软SUATSCEPO9快速上手:除了换芯还有细节安了</p><p>.小米12S1X概念机入驻休卡旗店新机入网图公布</p><p>.二星为GALAXYVATCH5&#x2F;PR系&gt;贴推出两款金A市</p><p>华力新专手表可购呼出气体华为官方晒月全食照片</p><p>已间读月闻意小米账号用产的议和见私改</p><p>前范&#x2F;手机号开&#x2F;小米D</p><p>尔特人</p><p>其他方式登录</p><p>茶图5</p><p>教码众汉</p><p>忘记京码?</p><p>手机号登录</p><p>全</p><p>00</p><p>约基奇</p><p>尼克斯</p><p>天风人</p><p>名次</p><p>球员</p><p>雷特</p><p>酒京斯</p><p>盖帽</p><p>29</p><p>登录注</p><p>抢酒断</p><p>国王</p><p>助攻</p><p>当日</p><p>蓝板</p><p>34</p><p>得分</p><p>30</p><p>40</p><p>知士</p><p>32</p><p>登录</p><p>中里</p><p>3</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711982215826-2b5e870d-4e1f-4630-837f-b009b358bf5a.png?x-oss-process=image/format,webp/resize,w_892,limit_0" alt="image.png"></p><p> 列表 </p><p>布局内容排列整齐的区域</p><p>高级软结人本培明南家</p><p>荣蛋CIEV折桑屑手机外欢设计曝光:猫载龙</p><p>二星为OSLAYVTEM5&#x2F;RE系列推出两款金属表第</p><p>小米森址人手机自我检制上线1项手机专项自查</p><p>小米1明女程步机入驻保卡续根店新机入同限公布</p><p>3阳营5</p><p>微软SUARFAEEPRE钠快速上手:詹了换忍延有猫节实</p><p>场为新专利手表可出气体绿力宜方晒月全食期料</p><p>,在PACIAGE,JSON中ZTYE1M0DIE</p><p>让我们菜看一个V最基的实战界9</p><p><em>MSA1E</em>PNODE.ISL5MODULESM0DEIFZ</p><p>执YNOEIMSTALLVUE</p><p>,创请一个制的文件夹,4进入</p><p>染一个应用</p><p>执行NOMIAITY</p><p>创注个LA.S</p><p>保电松合及您</p><p>连传相务松</p><p>酸码众期</p><p>理61E工专5</p><p>国务手心</p><p>国V号</p><p>下门A</p><p>加入小米</p><p>EE</p><p>检中出管</p><p>售欢城</p><p>EAOEY</p><p>服务网点</p><p>8西地</p><p>美子小米</p><p>7松个元</p><p>订学费网</p><p>生我0)</p><p>6萧姓5</p><p>E0</p><p>公微桥全</p><p>个米2京</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711982350343-73f70caf-b5fd-4d15-b3e0-3336c2176ac9.png?x-oss-process=image/format,webp" alt="image.png"></p><p>成条的</p><p>无序</p><p>样式</p><p>你非常好</p><p>你很好</p><p>你好吗</p><p>你好</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711982553987-6d6762a8-53c8-45c5-8ab0-50183b775013.png?x-oss-process=image/format,webp" alt="image.png"></p><p>ul里面只能包括li</p><p>但是li里面可以包含任何标签</p><p> 有序列表 </p><p>4.你非常好</p><p>3.你很好</p><p>2.你好孔吗</p><p>1.你好</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711982719987-adb9fe2a-c2b9-4bf3-a2b4-291323448e34.png?x-oss-process=image/format,webp" alt="image.png"></p><p> 定义列表 </p><p>dl嵌套dt和dd， dl是定义列表， dt是标题，dd是描述详情</p><p>申请售后</p><p>服务中心</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711982924716-0369c63f-e6f9-48b5-8045-c092ed0be4c8.png?x-oss-process=image/format,webp" alt="image.png"></p><p> 表格 </p><p>标签:TABLE嵌套TR,TR嵌套TD&#x2F;TH.</p><p>内容单元格</p><p>表头单元格</p><p>标签名</p><p>全市梦</p><p>全市禁一</p><p>说明</p><p>三99</p><p>四9</p><p>总达</p><p>语文</p><p>TABLE</p><p>表格</p><p>100</p><p>姓名</p><p>TH</p><p>TD</p><p>玫牛</p><p>TR</p><p>100</p><p>行</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711983002660-937aa235-f666-4e31-bf74-c4c0eeae1ea4.png?x-oss-process=image/format,webp" alt="image.png"></p><p>文数学英语</p><p>100</p><p>100</p><p>100</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711983146088-a2e4d8d5-fc56-45dd-b5b7-ff8623f623f4.png?x-oss-process=image/format,webp" alt="image.png"></p><p>加上单元格</p><p>英语</p><p>十中得吉口</p><p>语文</p><p>数学</p><p>100</p><p>100</p><p>100</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711983240635-4ff32691-c269-4aa3-9205-ff33c2535327.png?x-oss-process=image/format,webp" alt="image.png"></p><p> 表格的结构标签 </p><p>thead： 表格头部</p><p>tbody： 表格主题</p><p>tfoot： 表格底部</p><p> 合并单元格 </p><p>作用： 将多个单元格合并为一个单元格，以合并同类信息</p><p>作用:将多个单元格合并成一个单元格,以合并同类信息.</p><p>总结全市第一全市第一全市第-</p><p>总结金市第一全市第一全市</p><p>跨列合并</p><p>跨行合井</p><p>姓名语文</p><p>李四98</p><p>总结全市绣-</p><p>姓名语文数</p><p>张三9910019S</p><p>数学总分</p><p>198</p><p>姓名语文教学总</p><p>数学</p><p>199</p><p>张三99</p><p>张三99</p><p>总分</p><p>李四98</p><p>981001</p><p>199</p><p>0198</p><p>100</p><p>100</p><p>100</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711983660413-4961ef2a-f7ea-44de-965a-30c4b82b28f0.png?x-oss-process=image/format,webp" alt="image.png"></p><p>跨行： rowspan</p><p>跨列： colspan</p><p>2,保留最左最上的单元格,添加属性(取值是数字,表示需要合并的单元格量)</p><p>跨列合并,保留最左单元格,添加属性COLSPAN</p><p>跨行合井,保留最上单元格,添加属性ROWSPAN</p><p>1,明确合并的目标</p><p>删除其他单元格</p><p>跨列合并</p><p>合并单元格的步骤:</p><p>跨行合井</p><p>高级软件人才</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711983710709-eda52f8d-56a6-448b-a768-481f15caf24d.png?x-oss-process=image/format,webp" alt="image.png"></p><p>0O-格-合单元格HTML&gt;HTML&gt;BODY)TABE)TBODY&gt;TR</p><p>CMETANAMEAVEWPORTCONTENTEWIDTHEDEVICEWIDTH,ANATAALSCALEEL.E</p><p>(已选择12)空格:2UTF-8CRLF(IHTMLGOUHE8484PVET</p><p><TIT1E>表格站构标签&#x2F;T1T1E&gt;</p><p>TDROWSPANW2100K&#x2F;TD</p><p>06-表格-合并单元格HTMLX</p><p>1AKTD2100K&#x2F;TD2-2</p><p>&lt;TABLEBORDERA</p><TD>总结/TD><p>TD&gt;全市第&lt;&#x2F;TD2</p><TH>请文/TH)<TH>总分/TH<p>TD&gt;全市第一&#x2F;TD&gt;</p><p>CTD&gt;FK&#x2F;TD&gt;</p><p>TD199&#x2F;TD</p><p>合邦单元格的乡四</p><TH>姓名/TH<p>明横合开的目标</p><p>9,列26(已选择12空格</p><p>&lt;TD198K&#x2F;TD2</p><p>&lt;TD%三K&#x2F;TD</p><p>巴日国岛</p><p>TD&gt;99C&#x2F;TD2</p><p>CTH&gt;数PC&#x2F;TH2</p><p>CTD&gt;98C&#x2F;TD2</p><p>旅河性华光感</p><p>TN福XG</p><p>TFOOT&gt;</p><p>TBODY2</p><p>CTHEADP</p><p>&#x2F;THEAD&gt;</p><p>跨行合井</p></TBODY><p>4TF2</p><p>&lt;TF2</p><p>户家锅</p><p>BODY&gt;</p><p>华</p><p>(TR2</p><p>T户2</p><p>&lt;TN2</p><p>&#x2F;HEAD</p><p>TF2</p><p>10</p><p>(TR&gt;</p><p>号</p><p>品</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711983869524-52b394bb-ab68-4eae-a099-d0438ecacbc6.png?x-oss-process=image/format,webp/resize,w_792,limit_0" alt="image.png"></p><p> 表单 </p><p>作用： 收集用户信息</p><p>适用场景： </p><p>●登录页面</p><p>●注册页面</p><p>●搜素区域</p><p>INPUT标签TYPE属性值不同,则功能不同.</p><p>INPUT标签基本使用</p><p>文本框,用于输入单行又本</p><p>TYPE属性价</p><p>上传文件</p><p>CHECKBOX</p><p>密码</p><p>PASSWORD</p><p>&lt;INPUTTYPEE</p><p>多选框</p><p>说明</p><p>RADLO</p><p>TEXT</p><p>单选</p><p>FIP</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711984089123-dcbb41c8-2e0f-4267-9884-b58a4ead0760.png?x-oss-process=image/format,webp" alt="image.png"></p><p>&lt;INPUTTYPE三”PASSWORD”&gt;</p><p>&lt;INPUTTYPE&#x3D;”PASSWORD”</p><p>INPUTTYPE&#x3D;”TEXT”&gt;</p><p>100100100</p><p>OOSOSOSOSOS.</p><p>放大放大</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711984177590-1b28a209-4914-4382-814e-0e5193c66375.png?x-oss-process=image/format,webp" alt="image.png"></p><p> input标签的占位文本 </p><p>请输入密码</p><p>100</p><p>00</p><p>00</p><p>O口</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711984422946-4296592d-e812-4b6c-87d0-a892867fb50d.png?x-oss-process=image/format,webp" alt="image.png"></p>  <input type="password" placeholder="请输入密码"><p> 单选框 </p><p>控件分组,同组只能选中一个</p><p>属性名和属性值相同,简写为一个单词</p><INPUTTYPEARADIONAMEAGENDERCHECKED><p>我是出男O念女</p><p>SINPUTTYPEARADIONAMEAGENDER&gt;女</p><p>单选框RADIO</p><p>常用属性:</p><p>特殊说明</p><p>WW.ITHEIMA.COM</p><p>CHECKED</p><p>控件名称</p><p>一个(单选功能]</p><p>默认选中</p><p>NAME</p><p>作用</p><p>属性名</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711984545919-186c90e9-da9a-437c-a9f4-a0c55cb5b5fc.png?x-oss-process=image/format,webp" alt="image.png"></p><p>0男O女</p><p>性别</p><p>O</p><p>口</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711984636191-e3d47b15-9181-4ebc-b792-c718477a8756.png?x-oss-process=image/format,webp" alt="image.png"></p><p> 传文件 </p><p>​    <input type="file" mutiplre> 多选 上传文件 选择多个文件</p><p>浙江</p><p>北京</p><p>北京</p><p>重庆</p><p>北凉</p><p>上海</p><p>单</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711984966300-8eb7e85b-fa4f-43dc-9172-fcca9f362b4f.png?x-oss-process=image/format,webp" alt="image.png"></p><p> 文本域 </p><p>作用： 多行输入文本的表单控件</p><p>评论</p><p>请输入密码</p><p>评仑</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711985112284-60c17a4f-37a5-4e84-a0e1-bcca1273580c.png?x-oss-process=image/format,webp" alt="image.png"></p><p> label </p><p>作用： 网页中，某个标签的说明文本</p><p>经验:用LABEL标签绑定文字和表单控件的关系,增大表单控件的点击范围.</p><p>作用:网页中,某个标签的说明文本.</p><p>LABEL标签</p><p>中国大陆+畅请输入你的手机号</p><p>请输入校验码</p><p>获取动证码</p><p>检证码</p><p>注期</p><p>手机号码</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711985211598-318c868e-e94a-46bd-acb5-252fcbf4195f.png?x-oss-process=image/format,webp" alt="image.png"></p><p> 按钮 </p><p>button</p><p>多一句没有,少一句不行,用更短时间,教会更实用的技术!</p><p>普通按钮,默认没有功能,一般配合JAVASCRIP使用</p><p>钮,点击后将表单控件恢复默认值</p><p><BUTTONTYPEE>安纽</BUTTON></p><p>黑马程序员</p><p>点击后可以提</p><p>关道开纯小关瓶号产协碳鸭日私政室</p><p>按钮-BUTTON</p><p>TYPE属性值</p><p>重置按钮,</p><p>提交按钰</p><p>WWW.ITHEIMA.COT</p><p>数据到后台</p><p>TYPE属性值</p><p>(默认功能)</p><p>BUTTON</p><p>SUBMIT</p><p>说明</p><p>其他方式登录</p><p>RESET</p><p>手机号借学</p><p>能箱&#x2F;手杭号码&#x2F;个</p><p>车记黑码?</p><p>O0</p><p>登录注</p><p>登录</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711985481821-9f078cdd-20af-4665-a25c-0104005d4736.png?x-oss-process=image/format,webp" alt="image.png"></p><p>适用from标签进行绑定</p><p> 布局 </p><p>，div双标签是大盒子</p><p>《span》是小盒子</p><p>轮坤来定.你我情是期品NBSP;&amp;NBSP:&amp;NBSP;&amp;NBSP;&amp;NBSP;&amp;NBSP;&amp;NBSP;马.</p><p>&lt;.在代码中敲健盘的空格,网贸只识别一个,&gt;</p><p>&lt;METANANEA”VIEWPORTCONTENTWIDTHEDEVICEWIDTH,INITIALS</p><p>&lt;METAHTTPEQUIVAX-UA-COMPATIBIECONTENTAIEAEDGE</p><p>O17-字体实体HTML&gt;HTML&gt;9BODY</p><METACHARSETAUTF-B><p><TIT1E>字符实体C&#x2F;TIT1E&gt;</p><p>CHTML1ANGEEN2</p><p>17-字体实体HTMX</p><p>四日口G</p><p>1DOCTYPEHTM1&gt;</p><p>来宝,你教行</p><p>HEAD</p></HTM1><p>&amp;ITP&amp;GT</p><p>HEAD2</p><p>中客例</p><p>DBODY&gt;</p><p>&#x2F;B0DY&gt;</p><p>13</p><p>12</p><p>104</p><p>卫</p><p>6</p><p>9节</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711986149156-e443e9b9-fb8c-4051-ae12-0e8e2eed0f1d.png?x-oss-process=image/format,webp" alt="image.png"></p><p> 注册信息案例 </p><p>注册信息</p><p>确认密码:再次输入密码</p><p>居住城市:北凉?</p><p>最高学历:研究生</p><p>教育经历</p><p>个人信息</p><p>工作经历</p><p>性别:O男O男</p><p>密码:请输入密液</p><p>名:请输入姓名</p><p>在校时间:</p><p>所学专业:</p><p>工作描述:</p><p>学校名称:</p><p>TONGYI</p><p>提交</p><p>重置</p><p><img src="https://cdn.nlark.com/yuque/0/2024/png/42882174/1711987634447-6f54c327-baa0-4228-8e2c-a88dc2ffafae.png?x-oss-process=image/format,webp" alt="image.png"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java设计模式</title>
      <link href="/2024/02/10/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/02/10/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="x3D-x3D-设计模式的重要性：-x3D-x3D"><a href="#x3D-x3D-设计模式的重要性：-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;设计模式的重要性：&#x3D;&#x3D;"></a>&#x3D;&#x3D;设计模式的重要性：&#x3D;&#x3D;</h2><p>问题：</p><ol><li>解决项目的可维护性</li><li>可读性</li><li>规范性</li><li>代码重用性</li><li>使程序呈现高内聚，低耦合</li></ol><h2 id="设计模式的概念"><a href="#设计模式的概念" class="headerlink" title="设计模式的概念"></a>设计模式的概念</h2><p>反复被使用，多数人知晓的，经过分类编目的，代码设计经验的总结</p><h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><ul><li><p>创建型模式</p><p>主要特点是：对象的创建与使用分离</p></li><li><p>结构性模式</p><p>主要用于描述将类或者对象按照某种布局布局成更大的结构</p></li><li><p>行为型模式</p><p>用于描述类和对象之间相互协作完成单个对象无法单独完成的任务，以及怎样分配职责</p></li></ul><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p>统一建模语言：用来设计软件的可视化建模语言，特点是简单，统一，图形化，能表达设计中的动态和静态信息</p><p>包括： 用例图，类图，对象图，状态图，时序图，协作图，构件图，部署图等9种图</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202402192249456.png" alt="image-20240219224912415"></p><p>类图：</p><p> +public</p><p>-private</p><p>#protected</p><p>还有moren</p><p>属性的完整表示方式：</p><p>可见性 名称 ：类型【&#x3D; 缺省值】</p><p>方法的完整表达方式</p><p>可见性： 名称（参数列表）：【返回类型】 </p><p>注意： </p><ol><li>中括号中的内容是可选的</li><li>也有将类型放在变量名前面， 返回类型放在方法名前面</li></ol><h3 id="类和类之间的关系"><a href="#类和类之间的关系" class="headerlink" title="类和类之间的关系"></a>类和类之间的关系</h3><p>1.单向关联</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202402192253876.png" alt="image-20240219225325830"></p><p>2.双向关联</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202402192253266.png" alt="image-20240219225343226"></p><p>3.自关联</p><p>类图显示了模型的静态结构，特别是模型中存在的类，类的内部结构以及他们与其他类之间的关系</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202402192255685.png" alt="image-20240219225507648"></p><ol start="4"><li><p>聚合关系</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202402192300590.png" alt="image-20240219230048553"></p></li></ol><p>聚合关系是整体和部分之间的关系，整体不见了，部分还存在</p><ol start="5"><li><p>组合关系</p><p>整体和部分的关系，整体不见了，部分还存在</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202402192302012.png" alt="image-20240219230203966"></p></li><li><p>依赖关系</p><p>l临时性关系：静态方法调用</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202402192303026.png" alt="image-20240219230324983"></p></li><li><p>继承关系</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202402192305626.png" alt="image-20240219230547589"></p></li><li><p>实现关系</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202402192307626.png" alt="image-20240219230724586"></p></li></ol><h2 id="设计模式七大原则"><a href="#设计模式七大原则" class="headerlink" title="设计模式七大原则"></a>设计模式七大原则</h2><ol><li><p>开闭原则： 对扩展开放，对修改关闭，当程序需要修改的时候，不能去修改原有代码，实现一个热插拔的效果，简言之，是为了程序的扩展性性好，易于维护和升级，</p><p>关键： 合理使用接口和抽象类，当软件发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了</p><p>例子： 搜狗输入法的皮肤</p><p>搜狗输入法时输入法的背景图片，窗口颜色，声音等元素的组合，用户可以根据自己的喜爱更换输入法的皮肤，也可以下载新的皮肤。这些皮肤有共同的特点</p><p>抽象类： AbstractSkin</p><p>每个具体的皮肤： defaultSpecificSkin和HeimaSpecificSkin是子类，用户可以根据需要选择或者增加新的主题，而不需要修改源代码，所以她满足开闭原则</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202402192317953.png" alt="image-20240219231720906"></p></li><li><p>里氏替换原则： 任何基类可以出现的原则，子类一定可以出现，通俗的理解：子类可以扩展父类的功能，但不能改变父类原有的功能，换句话说，子类继承父类的时候，除添加新的方法完成新增功能外，尽量不要重写父类的方法</p><p><img src="C:\Users\86198\AppData\Roaming\Typora\typora-user-images\image-20240219233028259.png" alt="image-20240219233028259"></p></li><li><p>依赖倒转原则：高层，哦快不应该依赖底层模块，两者都依赖其抽象，抽象不应该依赖细节，简单的说就是对抽象进行编程，而不是细节进行编程，要降低客户和实现模块的耦合</p></li><li><p>&#x3D;&#x3D;单一职责原则&#x3D;&#x3D;： 一个类只负责一项职责</p><p>作用： 降低类的复杂度，一个类只负责一项职责</p><p>​提高类的可读性，可维护性</p><p>​降低变更引起的风险</p><p>​通常情况下： 我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则：只有类中方法组都少，才可以在方法级别保持单一职责原则</p></li><li><p>接口隔离原则</p><p>客户端不应该被迫依赖于它不使用的方法，一个类对另一个类的依赖应该建立在最小接口上</p></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/25/%E8%AE%A1%E7%BD%91/"/>
      <url>/2024/01/25/%E8%AE%A1%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="1-说说计算机网络体系结构"><a href="#1-说说计算机网络体系结构" class="headerlink" title="1.说说计算机网络体系结构"></a>1.说说计算机网络体系结构</h2><p>OSI七层模型，TCP&#x2F;IP5层模型，五层结构</p><p>OSI:</p><p>应用层</p><p>表示层</p><p>会话层应用层应用层</p><p>传输层传输层传输层</p><p>网络层网络层网络层</p><p>数据链路层     数据链路层</p><p>物理层          网络接口层      物理层</p><p>OSI是一个<strong>理论上</strong>的网络通信模型，TCP&#x2F;IP是<strong>实际上</strong>的网络通信模型，五层模型是为了介绍<strong>网络原理折中</strong>的网络通信模型</p><h2 id="2-数据在各层之间是如何传输的"><a href="#2-数据在各层之间是如何传输的" class="headerlink" title="2.数据在各层之间是如何传输的"></a>2.数据在各层之间是如何传输的</h2><p>物理层：比特流从一跳到另一跳的传递</p><p>数据链路层：物理层的数据无差错的传递给数据链路层，负责将帧从一条到另一跳</p><p>功能：成帧，物理寻址，流量控制，差错控制，访问控制</p><p>网络层：负责将各个分组从源地址传递到目的地址</p><p>功能：逻辑寻址，路由选择</p><p>传输层：负责将报文从一个进程到另一个进程的传递</p><p>（分段，组装，连接控制，流量控制，差错控制）</p><p>会话层：负责会话的控制和同步（会话控制，同步，session）</p><p>表示层：翻译加密，压缩数据</p><p>应用层：向用户提供服务</p><p>3.从浏览器输入url到显示主页的过程</p><ol><li><p>查缓存，浏览器有没有缓存这个页面。</p></li><li><p>dns解析：</p></li></ol><p>将域名解析为ip地址：浏览器先在缓存中找有没有域名和ip对应的缓存，如果没有就去dns服务器查找对应域名得ip</p><ol start="3"><li><p>tcp3次握手</p><p>和目标地址建立3次握手，建立连接</p></li><li><p>http传输</p><p>浏览器向服务器发起一个http请求，服务端处理请求，返回http响应。浏览器解析并且渲染页面</p></li><li><p>tcp四次挥手</p><p>断开连接，</p></li></ol><h2 id="3-说说websokect和socket得区别"><a href="#3-说说websokect和socket得区别" class="headerlink" title="3. 说说websokect和socket得区别"></a>3. 说说websokect和socket得区别</h2><p>websokect：持<strong>久化化协议，低延迟，全双工</strong>和<strong>长期运行</strong>的协议</p><p>优点：</p><p>双向实时通信</p><p>降低延迟</p><p>更高效的资源利用</p><p> 限制：</p><p>不提供加密功能</p><p>不支持古老的浏览器</p><p>websocket是建立在http协议上的一个双向的协议，http是单向的协议</p><p>所以websokect是应用层的协议</p><p><strong>socket不是协议，是方便使用tcp和udp抽象出来的一组接口</strong></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202401251623732.png" alt="image-20240125162243157"></p><p>http是断开响应式，websocket则会通过poll轮询来保持连接。说穿了就是http只能客户端请求服务端才能响应。而websocket服务端可以将数据发送给客户端。</p><h2 id="4-说一下你了解的端口及对应的服务"><a href="#4-说一下你了解的端口及对应的服务" class="headerlink" title="4.说一下你了解的端口及对应的服务"></a>4.说一下你了解的端口及对应的服务</h2><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202401251631266.png" alt="image-20240125163111224"></p><h2 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h2><p>cdn（content delivery network）是一种全球网络分发系统，把网站复制到里用户近的服务器上，提高网站的性能和速度。</p><p>CDN静态加速</p><p>使用缓存技术，将不经常修改的内容拷贝到服务器上</p><p>CDN动态加速：不仅使用缓存，还使用动态内容优化技术，加速数据库查询和动态页面的生成，针对的是经常修改的，</p><h2 id="http常用的状态码"><a href="#http常用的状态码" class="headerlink" title="http常用的状态码"></a>http常用的状态码</h2><p>1xx：信息状态码</p><p>2xx：成功状态码</p><p>3xx：重定向状态码</p><p>4xx：客户端错误状态码</p><p>5xx：服务端错误状态码</p><p>101：切换请求协议</p><p>200：请求成功</p><p>301：请求资源永久移动</p><p>302：请求资源临时移动</p><p>400：客户端请求的语法错误</p><p>401：当前请求需要认证</p><p>403：服务端理解请求，但拒绝执行</p><p>500：服务器内部错误</p><h2 id="说说301和302的区别"><a href="#说说301和302的区别" class="headerlink" title="说说301和302的区别"></a>说说301和302的区别</h2><p>301：<strong>永久性移动</strong>，请求的资源已被移动到新位置。服务器返回响应时，会返回<strong>新的资源地址</strong></p><p>302：<strong>临时性移动</strong>，服务器从另外的地址响应资源，但是客户还应该<strong>继续使用这个地址</strong></p><h2 id="http有哪些请求方式"><a href="#http有哪些请求方式" class="headerlink" title="http有哪些请求方式"></a>http有哪些请求方式</h2><p>get     向服务器获取简单的资源请求</p><p>post    向服务器提交数据请求</p><p>put      修改指定资源</p><p>delete    删除url标记的指定资源</p><p>connect   用于代理服务器</p><p>trance   主要用于换回测试</p><p>options  返回所有可用的方法</p><p>head     获取url标记的资源首部</p><p>post，delete，put，get对应我们最熟悉的增删改查</p><h2 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h2><ol><li><p>从http报文层面来看：<strong>get</strong>是吧请求信息放在<strong>u</strong>rl当作。<strong>post</strong>是把请求信息放在<strong>请求体</strong>当中。这一点使得<strong>get请求携带的数据有限</strong>。因为url本身是有长度限制的。post把数据请求放在报文体当中，对大小没有限制，从形式上看get把数据放在url当中不太安全，post把数据放在请求体当中比较安全</p></li><li><p>从数据层面来看：</p></li></ol><p>get符合幂等性和安全性，post不符合。按照http约定，get用于查看信息，post用来改变服务器上的信息。正因为get只请求查看信息，所以多次请求，所以对服务器产生的影响是相同的</p><ol start="3"><li>其他层面来看，get请求能够被缓存，get请求的url能保存为浏览器的数千，post请求不具备。，缓存时get能够被广泛应用的根本，它能够被缓存也是因为它的幂等性和安全性。除了返回结果没有多余动作。因此绝大部分get请求都被CDN缓存起来了，大大减少了web服务器的负担</li></ol><p>什么幂等性：方法被多次执行的时候所产生的影响和第一次执行产生的影响相同，</p><p>如何解决：使用数据库的唯一约束</p><p>redis提供的setnx</p><p>状态机，乐观锁</p><h2 id="get的长度限制是多少"><a href="#get的长度限制是多少" class="headerlink" title="get的长度限制是多少"></a>get的长度限制是多少</h2><p>http中的get是通过url进行数据传递的，url本身其实没有对数据的长度进行限制，真正限制get长度的是浏览器。比如IE浏览器，对url的限制是2000个字符们大概2kb左右这个给长度限制不是针对数据而言而是整个url</p><h2 id="http-请求的过程和原理"><a href="#http-请求的过程和原理" class="headerlink" title="http 请求的过程和原理"></a>http 请求的过程和原理</h2><p>客户端发起请求： </p><p>建立tcp连接</p><p>发送http请求</p><p>服务器处理请求</p><p>服务器发送响应</p><p>客户端接受响应</p><p>关闭TCP连接</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue2+3</title>
      <link href="/2023/09/25/vue-1/"/>
      <url>/2023/09/25/vue-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue2"><a href="#Vue2" class="headerlink" title="Vue2"></a>Vue2</h1><h2 id="vue模板语法"><a href="#vue模板语法" class="headerlink" title="vue模板语法"></a>vue模板语法</h2><h3 id="文本插值"><a href="#文本插值" class="headerlink" title="文本插值"></a>文本插值</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>msg属性每次更新， 双大括号中的值会发生变化</p><h3 id="Attibute绑定："><a href="#Attibute绑定：" class="headerlink" title="Attibute绑定："></a>Attibute绑定：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br><span class="line">简写为：</span><br><span class="line">&lt;div :id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</span><br><span class="line">布尔型属性</span><br><span class="line">&lt;button :disabled=&quot;isButtonDisabled&quot;&gt;Button&lt;/button&gt;</span><br></pre></td></tr></table></figure><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="v-text：-更新元素的文本内容"><a href="#v-text：-更新元素的文本内容" class="headerlink" title="v-text： 更新元素的文本内容"></a>v-text： 更新元素的文本内容</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span v-text=&quot;msg&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;!-- 等同于 --&gt;</span><br><span class="line">&lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure><h3 id="v-show：-基于表达式值的真假性，来改变元素的可见性。"><a href="#v-show：-基于表达式值的真假性，来改变元素的可见性。" class="headerlink" title="v-show： 基于表达式值的真假性，来改变元素的可见性。"></a>v-show： 基于表达式值的真假性，来改变元素的可见性。</h3><p>通过设置内联样式的display的css属性来工作，当元素可见时，将使用初始值display值，条件改变时，触发过度效果</p><h3 id="v-if：-当-v-if-元素被触发，元素及其所包含的指令-x2F-组件都会销毁和重构。如果初始条件是假，那么其内部的内容根本都不会被渲染。"><a href="#v-if：-当-v-if-元素被触发，元素及其所包含的指令-x2F-组件都会销毁和重构。如果初始条件是假，那么其内部的内容根本都不会被渲染。" class="headerlink" title="v-if： 当 v-if 元素被触发，元素及其所包含的指令&#x2F;组件都会销毁和重构。如果初始条件是假，那么其内部的内容根本都不会被渲染。"></a>v-if： 当 <code>v-if</code> 元素被触发，元素及其所包含的指令&#x2F;组件都会销毁和重构。如果初始条件是假，那么其内部的内容根本都不会被渲染。</h3><h3 id="v-for：基于原始数据多次渲染元素或模板块。"><a href="#v-for：基于原始数据多次渲染元素或模板块。" class="headerlink" title="v-for：基于原始数据多次渲染元素或模板块。"></a>v-for：基于原始数据多次渲染元素或模板块。</h3><p>v-for： 有一个问题： 不能实时检测复杂对象的变化，如果items发生了变化，item不会变化，解决方法</p><p>根据vue的官方文档说明：<strong>Vue 包含一组观察数组的变异方法，所以它们将会触发视图更新。</strong> 这些方法如下：</p><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="built_in">push</span>() <span class="built_in">pop</span>() <span class="built_in">shift</span>() <span class="built_in">unshift</span>() <span class="built_in">splice</span>() <span class="built_in">sort</span>() <span class="built_in">reverse</span>()</span><br></pre></td></tr></table></figure><p>就是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-for=&quot;item in items&quot;&gt;</span><br><span class="line">  &#123;&#123; item.text &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><p>给元素绑定事件监听器： </p><p>给元素绑定事件监听器。</p><ul><li><p><strong>缩写：</strong><code>@</code></p></li><li><p><strong>期望的绑定值类型：</strong><code>Function | Inline Statement | Object (不带参数)</code></p></li><li><p><strong>参数：</strong><code>event</code> (使用对象语法则为可选项)</p></li><li><p><strong>修饰符</strong></p></li><li><p><code>.stop</code> - 调用 <code>event.stopPropagation()</code>。</p></li><li><p><code>.prevent</code> - 调用 <code>event.preventDefault()</code>。</p></li><li><p><code>.capture</code> - 在捕获模式添加事件监听器。</p></li><li><p><code>.self</code> - 只有事件从元素本身发出才触发处理函数。</p></li><li><p><code>.&#123;keyAlias&#125;</code> - 只在某些按键下触发处理函数。</p></li><li><p><code>.once</code> - 最多触发一次处理函数。</p></li><li><p><code>.left</code> - 只在鼠标左键事件触发处理函数。</p></li><li><p><code>.right</code> - 只在鼠标右键事件触发处理函数。</p></li><li><p><code>.middle</code> - 只在鼠标中键事件触发处理函数。</p></li><li><p><code>.passive</code> - 通过 <code>&#123; passive: true &#125;</code> 附加一个 DOM 事件。</p></li></ul><h3 id="v-model：-双向数据绑定"><a href="#v-model：-双向数据绑定" class="headerlink" title="v-model： 双向数据绑定"></a>v-model： 双向数据绑定</h3><ul><li><code>&lt;input&gt;</code></li><li><code>&lt;select&gt;</code></li><li><code>&lt;textarea&gt;</code></li></ul><p>修饰符：</p><ul><li><a href="https://cn.vuejs.org/guide/essentials/forms.html#lazy"><code>.lazy</code></a> - 监听 <code>change</code> 事件而不是 <code>input</code></li><li><a href="https://cn.vuejs.org/guide/essentials/forms.html#number"><code>.number</code></a> - 将输入的合法字符串转为数字</li><li><a href="https://cn.vuejs.org/guide/essentials/forms.html#trim"><code>.trim</code></a> - 移除输入内容两端空格</li></ul><h2 id="vuex-作用实现数据的集中式管理-—-gt-数据传递-组件通信"><a href="#vuex-作用实现数据的集中式管理-—-gt-数据传递-组件通信" class="headerlink" title="vuex: 作用实现数据的集中式管理 —&gt;数据传递+组件通信"></a>vuex: 作用实现数据的集中式管理 —&gt;数据传递+组件通信</h2><p>数据由vuex统一管理，其他组件都要去使用vuex中的数据， 只要有一个组件修改了这个 共享的数据，其他啊组件都会同步更新，</p><p>vuex插件维护了一个共享的store，store对象中有state属性，state属性中存储有共享的数据</p><p>使用：</p><p>创建一个store.js对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import Vuex from &#x27;vuex&#x27;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  //状态对象</span><br><span class="line">  state: &#123;</span><br><span class="line">    num: 100</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  //负责的更新对象</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    //更新state</span><br><span class="line">    PLUSONE(state,value)&#123;</span><br><span class="line">      state.num += value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  //负责执行某个行为的对象</span><br><span class="line">  actions: &#123;</span><br><span class="line">    //value是传递过来的数据</span><br><span class="line">    //context是vuex的上下文对象</span><br><span class="line">    plusone(context,value)&#123;</span><br><span class="line">      value += 1 //处理业务</span><br><span class="line">      //业务逻辑处理完之后，下一个环节，走到数据更新</span><br><span class="line">      //提交上下文</span><br><span class="line">      context.commit(&#x27;PLUSONE&#x27;,value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后再main.js中使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import App from &#x27;./App.vue&#x27;</span><br><span class="line">import router from &#x27;./router&#x27;</span><br><span class="line">import store from &#x27;./store&#x27;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: h =&gt; h(App)</span><br><span class="line">&#125;).$mount(&#x27;#app&#x27;)</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">  &lt;button @click=&quot;plusone&quot;&gt; 点我加以&lt;/button&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123;this.$store.state.num&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;App&#x27;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      num: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">     plusone()&#123;</span><br><span class="line">       // this.num++</span><br><span class="line">       this.$store.state.num++</span><br><span class="line">       </span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="单页面和多页面对比"><a href="#单页面和多页面对比" class="headerlink" title="单页面和多页面对比"></a>单页面和多页面对比</h3><p>router： 用来管理和调度路由</p><p>单页面的web应用： 一个web应用，只有一个html应用， 刷新只有局部页面刷新</p><h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><p>子传父： </p><ul><li>数据绑定</li><li>直接调用this.$parent.xxx</li><li>依赖注入</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &lt;hello-world :str1=&quot;num&quot;&gt;&lt;/hello-world&gt;</span><br><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    num: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">  provide() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      num:this.num</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">子：</span><br><span class="line"> &lt;div&gt;</span><br><span class="line">    &#123;&#123;str1&#125;&#125;</span><br><span class="line">    &#123;&#123;this.$parent.num&#125;&#125; //或者</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  props: &#123;</span><br><span class="line">    str1: Number</span><br><span class="line">  &#125;,</span><br><span class="line">   inject:[&#x27;num&#x27;],</span><br></pre></td></tr></table></figure><h2 id="slot："><a href="#slot：" class="headerlink" title="slot："></a>slot：</h2><h4 id="匿名插槽"><a href="#匿名插槽" class="headerlink" title="匿名插槽"></a>匿名插槽</h4><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404172320330.png" alt="image-20240417232000951"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404172320683.png" alt="image-20240417232018596"></p><h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404172322889.png" alt="image-20240417232208816"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404172322619.png" alt="image-20240417232233519"></p><h4 id="作用域插槽：-传值"><a href="#作用域插槽：-传值" class="headerlink" title="作用域插槽： 传值"></a>作用域插槽： 传值</h4><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404172325376.png" alt="image-20240417232509274"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404172325185.png" alt="image-20240417232530084"></p><h3 id="如何封装组件"><a href="#如何封装组件" class="headerlink" title="如何封装组件"></a>如何封装组件</h3><h3 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h3><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404172337638.png" alt="image-20240417233754560"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404172343060.png" alt="image-20240417234344947"></p><p>适用于所有情况的通信： </p><p>getters的使用</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404172346914.png" alt="image-20240417234633804"></p><p>modules使用：</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404172354744.png" alt="image-20240417235443640"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404172354022.png" alt="image-20240417235417948"></p><p>mutations的使用方法：</p><p>mutaion没有返回值</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404172357086.png" alt="image-20240417235712994"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404172357665.png" alt="image-20240417235742561"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">state： 全局共享属性 使用： this.$store.state.xxx</span><br><span class="line">getters：  针对于state属性进行二次计算（小数点保留几位，类型转换），不能修改数据</span><br><span class="line">mutations： 存放同步方法</span><br><span class="line">actions： 存放异步方法</span><br><span class="line">modules： 把vuex再次进行模块之间的划分</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>actions和mutatiosn用来存放全局方法，没有返回值</p><p>mutations同步，actions返回一个promise对象，</p><p>mutation用来修改state的值，action的做那样用来提交mutations 的值的</p><p>setTimeOut（（） &#x3D;》{}） </p><h3 id="vuex的持久化管理：-存放全局属性的地方"><a href="#vuex的持久化管理：-存放全局属性的地方" class="headerlink" title="vuex的持久化管理： 存放全局属性的地方"></a>vuex的持久化管理： 存放全局属性的地方</h3><p>vuex本身不是使用持久化存储的:localStoreage 或者使用使用插件</p><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404180005743.png" alt="image-20240418000539657"></p><h2 id="路由的模式"><a href="#路由的模式" class="headerlink" title="路由的模式"></a>路由的模式</h2><p>history，hash</p><p>history: 以&#x2F;作为结尾</p><p>hash： 以#&#x2F;作为结尾</p><p>区别： 关于找不到当前页面，发送请求 的问题</p><p>history： 找不到不会发送请求</p><p>配置404页面</p><p>hash：   项目打包前端自测问题：</p><p>npm run build ： 生成dist文件 ， history，看不到内容，哈市可以看到内容</p><h2 id="导航故障问题"><a href="#导航故障问题" class="headerlink" title="导航故障问题"></a>导航故障问题</h2><p>重写router.push方法</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404180015305.png" alt="image-20240418001511195"></p><h3 id="router和route的区别"><a href="#router和route的区别" class="headerlink" title="router和route的区别"></a>router和route的区别</h3><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404180016462.png" alt="image-20240418001650397"></p><p>route是router的一个方式</p><h3 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h3><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404180018891.png" alt="image-20240418001853826"></p><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><h4 id="set"><a href="#set" class="headerlink" title="$set"></a>$set</h4><p>有没有遇到过数据更新，然后视图没有更新的情况</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404180025879.png" alt="image-20240418002520788"></p><p>this.$set(s数据， 位置， 更改为)</p><h4 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h4><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404180027965.png" alt="image-20240418002711875"></p><h3 id="data-：-获取当前组件的data数据"><a href="#data-：-获取当前组件的data数据" class="headerlink" title="$data ： 获取当前组件的data数据"></a>$data ： 获取当前组件的data数据</h3><h3 id="children-获取所有组件的子组件"><a href="#children-获取所有组件的子组件" class="headerlink" title="$children: 获取所有组件的子组件"></a>$children: 获取所有组件的子组件</h3><h4 id="parent：父组件"><a href="#parent：父组件" class="headerlink" title="$parent：父组件"></a>$parent：父组件</h4><h4 id="data数据定义：-直接写在data中，无法被单独修改，必须要修改一个return中的数据，才能修改"><a href="#data数据定义：-直接写在data中，无法被单独修改，必须要修改一个return中的数据，才能修改" class="headerlink" title="data数据定义： 直接写在data中，无法被单独修改，必须要修改一个return中的数据，才能修改"></a>data数据定义： 直接写在data中，无法被单独修改，必须要修改一个return中的数据，才能修改</h4><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404180030687.png" alt="image-20240418003037598"></p><h3 id="computed的计算属性"><a href="#computed的计算属性" class="headerlink" title="computed的计算属性"></a>computed的计算属性</h3><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404180033849.png" alt="image-20240418003336749"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404180035361.png" alt="image-20240418003514262"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404180036320.png" alt="image-20240418003650235"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404180038311.png" alt="image-20240418003835198"></p><p>深度监听：</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404180040207.png" alt="image-20240418004012124"></p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404180043594.png" alt="image-20240418004312533"></p><p>全局：</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404180043556.png" alt="image-20240418004336474"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404180045561.png" alt="image-20240418004503478"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404180047363.png" alt="image-20240418004740271"></p><h4 id="双向绑定原理"><a href="#双向绑定原理" class="headerlink" title="双向绑定原理"></a>双向绑定原理</h4><h2 id="vue和vue3的区别"><a href="#vue和vue3的区别" class="headerlink" title="vue和vue3的区别"></a>vue和vue3的区别</h2><p>vue2和vue3的区别：</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202404180053906.png" alt="image-20240418005336821"></p><h2 id="项目上线"><a href="#项目上线" class="headerlink" title="项目上线"></a>项目上线</h2><p>浏览器指认识html，所以需要打包工具进行打包编译， webpack和vite</p><h2 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm init vue@latest</span><br></pre></td></tr></table></figure><h2 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h2><p>创建一个vue3项目</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn/npm create vue@latest</span><br></pre></td></tr></table></figure><p>运行项目：生产环境</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><h3 id="setup函数"><a href="#setup函数" class="headerlink" title="setup函数"></a>setup函数</h3><p>vue3新增的配置项：</p><p>setup中定义的变量跨域看作是之前的data，</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前后端分离项目步骤</title>
      <link href="/2023/09/25/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/"/>
      <url>/2023/09/25/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="前后端项目创建步骤"><a href="#前后端项目创建步骤" class="headerlink" title="前后端项目创建步骤"></a>前后端项目创建步骤</h1><p>如果没有安装vue的需要执行以下步骤</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install  -g @vue/cli</span><br><span class="line">vue -V</span><br><span class="line">如果第二条命令有vue版本出现，则证明安装成功</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后开始创建项目。我们先从前端开始</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue create vue</span><br></pre></td></tr></table></figure><p>然后进入到选择界面，然后选择 <strong>Manually select features</strong></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309252135463.png" alt="image-20230925213507406"></p><p>选择Babel，Router之后点击确定</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309252142881.png" alt="image-20230925214247853"></p><p>选择 2.x</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309252157255.png" alt="image-20230925215741221"></p><p>然后选择 yes</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309252158338.png" alt="image-20230925215841302"></p><p>选择yes，然后命名</p><p>最后创建成功，然后开始漫长的等待</p><p>最后创建成功，然后</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd vue </span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><p>开始运行</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前后端分离项目步骤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流水线</title>
      <link href="/2023/09/25/%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
      <url>/2023/09/25/%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h1><h2 id="静态多发射处理器"><a href="#静态多发射处理器" class="headerlink" title="静态多发射处理器"></a>静态多发射处理器</h2><p>编译器在编译时，进行相关性分析，和静态分支预测，以静态完成指令打包</p><h6 id="如何理解静态："><a href="#如何理解静态：" class="headerlink" title="如何理解静态："></a>如何理解静态：</h6><ul><li>“静态”一词表示指令的并行执行是在编译阶段或指令发射之前就确定好的</li><li>编译时决策：在静态多发射处理器中，指令的并行执行是在编译阶段进行决策的。编译器会对程序进行静态分析，确定哪些指令可以并行执行，并将其组织成指令组（instruction bundle）。这些指令组在运行时被一次性发射到处理器中执行。</li><li>固定的并行度：静态多发射处理器通常有一个固定的并行度，即每个时钟周期内可以同时执行的指令数量。这个并行度在处理器设计时就被确定下来，并且在运行时是不可改变的。例如，一个四发射处理器每个周期可以同时执行四条指令。</li><li>静态调度：静态多发射处理器使用静态调度来确定指令的执行顺序。在编译阶段，编译器会根据数据依赖关系和控制流信息，对指令进行调度和排序，以最大限度地提高指令级并行性。这个静态调度的结果会被写入指令流（instruction stream）中，然后在运行时按照指令流的顺序执行。 总的来说，静态多发射处理器在编译阶段就确定了指令的并行执行方式和顺序，并且在运行时按照这个确定的方案执行指令。这种静态的设计可以在一定程度上简化处理器的控制逻辑，并提高处理器的性能。但同时也带来了一些挑战，如依赖关系的解决和冲突检测等。</li></ul><h6 id="N发射静态流水线特点"><a href="#N发射静态流水线特点" class="headerlink" title="N发射静态流水线特点"></a>N发射静态流水线特点</h6><ul><li><p>潜在性能提高N倍</p></li><li><p>硬件堆料</p></li><li><p>数据和控制相关带来更大的损失</p></li><li><p>需要极为强大+智能的编译器，尽可能采用VLIW编排指令</p></li></ul><h2 id="多发射动态流水线"><a href="#多发射动态流水线" class="headerlink" title="多发射动态流水线"></a>多发射动态流水线</h2><p><strong>实现</strong></p><ul><li><p>动态调度</p><p> <strong>CPU****在运行时重新安排指令的执行顺序，减少流水线</strong></p><p><strong>空转。</strong></p><p><strong>•</strong> <strong>能调度编译时不知道的竞争情况</strong></p><p><strong>•</strong> <strong>符号程序执行的实际情况</strong></p><p><strong>•</strong> <strong>具有更高的效率和准确性</strong></p><p><strong>•</strong> <strong>简化编译器设计</strong></p><p><strong>•</strong> <strong>代码移植性强</strong></p></li><li><p><strong>并行多线程或</strong>“<strong><strong>超线程</strong></strong>”</p></li></ul><h5 id="并行增加CPU数量"><a href="#并行增加CPU数量" class="headerlink" title="并行增加CPU数量"></a>并行增加CPU数量</h5><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251656457.png" alt="image-20230925165602285"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251656898.png" alt="image-20230925165613860"></p><h5 id="如何让流水线更快-–-解决方案"><a href="#如何让流水线更快-–-解决方案" class="headerlink" title="如何让流水线更快 – 解决方案"></a>如何让流水线更快 – 解决方案</h5><p> 动态多发射流水线 – 由硬件动态调度指令顺序发射给不同的流水线</p><ul><li><p>顺序多发射流水线</p><p> 限制：</p><p>​     数据依赖</p><p>​      冲突和检测</p><p>​    </p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251704760.png" alt="image-20230925170452698"></p><p><strong>解决方案：顺序发生，乱序执行，乱序完成</strong></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251708470.png" alt="image-20230925170850425"></p></li></ul><p>​    记分牌控制的四个阶段</p><p>  原：取指 -&gt;译码-&gt;执行-&gt;写回</p><p> now：<a href="https://blog.csdn.net/weixin_40064300/article/details/124443945?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169564113016800227411306%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169564113016800227411306&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-124443945-null-null.142%5Ev94%5Einsert_down28v1&utm_term=%E8%AE%B0%E5%88%86%E7%89%8C&spm=1018.2226.3001.4187">讲解</a></p><p><strong>•</strong> <strong>1.Issue—****指令译码，检测</strong>结构相关****</p><p>• 如果当前指令所使用的功能部件空闲，并且没有其他活动的指令</p><p>使用相同的目的寄存器（避免WAW), 记分牌发射该指令到功能部</p><p>件，并更新记分牌内部数据；<strong>如果有结构相关或<strong><strong>WAW</strong></strong>相关，则该</strong></p><p><strong>指令的发射暂停</strong>，并且也不发射后继指令，直到相关解除. </p><p><strong>•</strong> <strong>2. Read operands—****没有</strong>数据相关<strong>时，读操作数</strong></p><p>• 如果先前已发射的正在运行的指令不对当前指令的源操作数寄存</p><p>器进行写操作，或者一个正在工作的功能部件已经完成了对该寄</p><p>存器的写操作，则该操作数有效。操作数有效时，记分牌控制功</p><p>能部件读操作数，准备执行。</p><p>• 记分牌在这一步动态地解决了RAW相关，指令可能会乱序执行</p><p><strong>•</strong> <strong>3.Execution—****取到操作数后执行</strong> <strong>(EX)</strong> </p><p>• 接收到操作数后，功能部件开始执行. 当计算出结果后，它通知</p><p>记分牌，可以结束该条指令的执行. </p><p><strong>•</strong> <strong>4.Write result—finish execution (WB)</strong> </p><p>• 一旦记分牌得到功能部件执行完毕的信息后，记分牌检测WAR</p><p>相关，如果没有WAR相关，就写结果，如果有WAR 相关，则暂停</p><p>该条指令。</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251914498.png" alt="image-20230925191434424"></p><h5 id="exam"><a href="#exam" class="headerlink" title="exam:"></a>exam:</h5><p>指令状态表</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251930639.png" alt="image-20230925193044610"></p><p>功能部件状态表：</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251931161.png" alt="image-20230925193144130"></p><p>结果寄存器状态表：</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251932645.png" alt="image-20230925193216594"></p><p>begin：</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251935781.png" alt="image-20230925193518718"></p><p>首先由两个Load指令，只有一个可以执行功能部件能够执行Load操作，所以智能流入1，然后是，一次执行</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251939922.png" alt="image-20230925193907853"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251943377.png" alt="image-20230925194322307"></p><p>调度算法二：</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251943206.png" alt="image-20230925194350140"></p><h5 id="动态调度方法二：Tomasulo-Algorithm"><a href="#动态调度方法二：Tomasulo-Algorithm" class="headerlink" title="动态调度方法二：Tomasulo Algorithm"></a>动态调度方法二：Tomasulo Algorithm</h5><p>所用到的技术：数据重定向技术</p><h6 id="数据重定向技术：用于解决数据相关性导致的流水线停顿问题。当一个指令需要等待另一个指令的结果时，流水线会出现停顿，导致性能下降。数据重定向技术通过在流水线中插入一些逻辑电路，使得指令在等待其他指令结果时可以继续执行，从而提高流水线的利用率。"><a href="#数据重定向技术：用于解决数据相关性导致的流水线停顿问题。当一个指令需要等待另一个指令的结果时，流水线会出现停顿，导致性能下降。数据重定向技术通过在流水线中插入一些逻辑电路，使得指令在等待其他指令结果时可以继续执行，从而提高流水线的利用率。" class="headerlink" title="数据重定向技术：用于解决数据相关性导致的流水线停顿问题。当一个指令需要等待另一个指令的结果时，流水线会出现停顿，导致性能下降。数据重定向技术通过在流水线中插入一些逻辑电路，使得指令在等待其他指令结果时可以继续执行，从而提高流水线的利用率。"></a>数据重定向技术：用于解决数据相关性导致的流水线停顿问题。当一个指令需要等待另一个指令的结果时，流水线会出现停顿，导致性能下降。数据重定向技术通过在流水线中插入一些逻辑电路，使得指令在等待其他指令结果时可以继续执行，从而提高流水线的利用率。</h6><p>简单说就是简化读写操作：</p><p>比如说 write B A</p><p>​write B C</p><p>​           直接简化为： write C A</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251951341.png" alt="image-20230925195150289"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251953634.png" alt="image-20230925195350585"></p><p>例子：</p><ul><li></li></ul><ul><li><ul><li>乱序多发射流水线</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 大三课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据和信号</title>
      <link href="/2023/09/24/%E6%95%B0%E6%8D%AE%E5%92%8C%E4%BF%A1%E5%8F%B7/"/>
      <url>/2023/09/24/%E6%95%B0%E6%8D%AE%E5%92%8C%E4%BF%A1%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章—数据和信号"><a href="#第三章—数据和信号" class="headerlink" title="第三章—数据和信号"></a>第三章—数据和信号</h1><p>数据无法直接传输所以需要编程信号</p><p>信息（message）：文字，音频，视频等</p><p>数据（data）：再传输之前进行编码，编码之后编程数据</p><p>信号（signal）：数据再通信线路上传递需要变成电信号（双脚线，同轴电缆），光信号（光纤），</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242002720.png" alt="image-20230924200241668"></p><p>数据分类</p><ul><li>模拟数据：连续状态的信息</li><li>数字数据：离散状态的数据</li></ul><p>信号</p><ul><li><p>模拟信号：</p><p>优点：其精确的分辨率，与数字信号相比，模拟信号的信息密度更高。处理更简单，可以直接通过模拟电路组件实现。 缺点：易受干扰，很难纠正。</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242006441.png" alt="image-20230924200613409"></p><p>​                        模拟信号数字信号</p></li><li><p>数字信号</p><p>更高的抗干扰能力，更远的传输距离，且失真幅度小。便于加密处理、存储、处理和交换，设备便于集成化、微型，占用信道频带较宽。 缺点：算法复杂。</p></li></ul><p>数据通信中常用周期模拟信号（带宽小），和非周期数字信号。</p><h2 id="周期性的模拟信号"><a href="#周期性的模拟信号" class="headerlink" title="周期性的模拟信号"></a>周期性的模拟信号</h2><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242026709.png" alt="image-20230924202647663"></p><p>概念：</p><ul><li><p>振幅</p></li><li><p>频率</p></li><li><p>相位</p></li><li><p>波长</p></li><li><p>时域和频域</p><p>时域：时域是指信号在时间轴上的变化情况。在时域中，信号的数值随着时间的变化而变化。可以通过绘制信号的波形图来表示时域特性。时域分析主要关注信号在时间上的幅度、相位、频率等变化。</p><p>频域：指信号在频率轴上的变化情况。在频域中，信号的数值随着频率的变化而变化。频域分析可以将信号转换成频谱图，表示信号在不同频率上的强度。频域分析主要关注信号的频率成分、频率特性等。</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242029470.png" alt="image-20230924202913441"></p></li></ul><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242034064.png" alt="image-20230924203435036"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242034984.png" alt="image-20230924203456954"></p><h2 id="复合信号"><a href="#复合信号" class="headerlink" title="复合信号"></a>复合信号</h2><p>单一频率的正弦波在数据通信中没有用处，需要发送复合信号，复合信号由许多简单正弦波组成。 按照傅里叶分析，任何复合信号是由具有不同频率、相位和振幅的简单正弦波组合而成（附录C）。 如果复合信号是周期性的，分解得到的是一系列具有离散频率的信号。 如果复合信号是非周期性的，分解得到的是具有连续频率的正弦波组合。</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242037466.png" alt="image-20230924203714428"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242039641.png" alt="image-20230924203911611"></p><p><u>带宽&#x3D;最高频率-最低频率</u></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242041285.png" alt="image-20230924204135249"></p><p>带宽&#x3D;5000-1000</p><h2 id="数字信号"><a href="#数字信号" class="headerlink" title="数字信号"></a>数字信号</h2><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242042772.png" alt="image-20230924204225742"></p><p>比如</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242042175.png" alt="image-20230924204247149"></p><p>一个电平表示的比特位数</p><h6 id="n-x3D-log2L"><a href="#n-x3D-log2L" class="headerlink" title="n&#x3D;log2L"></a>n&#x3D;log2L</h6><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242048497.png" alt="image-20230924204834468"></p><p>L时电平数量</p><h4 id="比特率：位数-x2F-每秒"><a href="#比特率：位数-x2F-每秒" class="headerlink" title="比特率：位数&#x2F;每秒"></a>比特率：位数&#x2F;每秒</h4><p>假定我们需要每分钟 100页的速率下载文本文档。假设一页平均 24行，每一行 80个字符，每个字符需要 8位表示，则所需的通道比特率是多少？ 解: 根据题意，比特率为：</p><p>​比特率&#x3D;100 * 24 * 80 *8 &#x2F;60 &#x3D;25.6kbps（千比特&#x2F;秒）</p><h4 id="比特长度-x3D-传播长度-比特持续时间"><a href="#比特长度-x3D-传播长度-比特持续时间" class="headerlink" title="比特长度&#x3D;传播长度 * 比特持续时间"></a>比特长度&#x3D;传播长度 * 比特持续时间</h4><p>（一个比特再传输介质上的距离）</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242056927.png" alt="image-20230924205604887"></p><p>结论:<strong>数字信号的带宽时无穷的</strong></p><p>数字信号时一种复合的模拟信号（带宽无穷大的复合模拟信号）</p><h4 id="数字信号传输"><a href="#数字信号传输" class="headerlink" title="数字信号传输"></a>数字信号传输</h4><h5 id="基带传输"><a href="#基带传输" class="headerlink" title="基带传输"></a>基带传输</h5><p>通过通道传输数字信号，不转化为模拟信号，基带传输时一个带宽下限为0的低通通道</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242100728.png" alt="image-20230924210055697"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242101142.png" alt="image-20230924210150107"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242102362.png" alt="image-20230924210216324"></p><p><strong>结论：只有存在无穷大或者非常大带宽的低通通道，保持数字信号形状的数字信号基带传输才是有可能的</strong></p><p><strong>exam</strong>：计算带宽</p><p>比特率为：n</p><p>如果只有0，1</p><p>T&#x3D;2*1&#x2F;n</p><p>f&#x3D;1&#x2F;T&#x3D;n&#x2F;2</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242110215.png" alt="image-20230924211017172"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242111919.png" alt="image-20230924211102893"></p><p><strong>结论：基带传输当中，所需带宽与所需比特率成正比</strong></p><p>exam：</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242120740.png" alt="image-20230924212022711"></p><h4 id="带同通道"><a href="#带同通道" class="headerlink" title="带同通道"></a>带同通道</h4><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242122425.png" alt="image-20230924212241399"></p><p><strong>结论：如果可用通道是带通通道，不能直接发送数字信号到通道；需要在传输前把数字信号转换成模拟信号</strong></p><p>数字信号—&gt;模拟信号</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242123234.png" alt="image-20230924212347199"></p><h4 id="传输减损"><a href="#传输减损" class="headerlink" title="传输减损"></a>传输减损</h4><p>信号通过介质进行传输，但是其传输并非是完美无缺的。不完美的地方导致了信号减损。这意味着信号在介质的开始一端和结束一端是不相同的。发送的信号并非就是接收到的信号。通常会发生三种类型的减损：衰减、失真和噪声。</p><h5 id="衰减：幅度变化"><a href="#衰减：幅度变化" class="headerlink" title="衰减：幅度变化"></a>衰减：幅度变化</h5><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242127502.png" alt="image-20230924212700463"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242127953.png" alt="image-20230924212718915"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242128273.png" alt="image-20230924212855234"></p><h5 id="失真：波形变化"><a href="#失真：波形变化" class="headerlink" title="失真：波形变化"></a>失真：波形变化</h5><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242129268.png" alt="image-20230924212930231"></p><h5 id="噪声："><a href="#噪声：" class="headerlink" title="噪声："></a>噪声：</h5><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242134719.png" alt="image-20230924213429663"></h5><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242135809.png" alt="image-20230924213522756"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242135784.png" alt="image-20230924213546731"></p><h4 id="数据速率"><a href="#数据速率" class="headerlink" title="数据速率"></a>数据速率</h4><p>数据通信中一个非常重要的问题是：在一个通道中能够以多快的速率发送数据，即每秒钟的比特数。数据速率取决于三种因素：   1. 有效带宽   2. 使用的信号电平数   3. 通道的质量（噪声电平）</p><h5 id="无噪声通道-奈奎斯特比特率"><a href="#无噪声通道-奈奎斯特比特率" class="headerlink" title="无噪声通道: 奈奎斯特比特率"></a>无噪声通道: 奈奎斯特比特率</h5><h3 id="理论上的最大比特率-x3D-2-×-带宽-×-log2-L，-L是电平数"><a href="#理论上的最大比特率-x3D-2-×-带宽-×-log2-L，-L是电平数" class="headerlink" title="理论上的最大比特率 &#x3D; 2 × 带宽 ×  log2 L，  L是电平数"></a>理论上的最大比特率 &#x3D; 2 × 带宽 ×  log2 L，  L是电平数</h3><h5 id="噪声通道-香农容量定理"><a href="#噪声通道-香农容量定理" class="headerlink" title="噪声通道: 香农容量定理"></a>噪声通道: 香农容量定理</h5><h4 id="通道容量-x3D-带宽-×-log2-1-SNR-（SNR-信噪比）"><a href="#通道容量-x3D-带宽-×-log2-1-SNR-（SNR-信噪比）" class="headerlink" title="通道容量 &#x3D; 带宽 × log2(1+SNR)（SNR:信噪比）"></a>通道容量 &#x3D; 带宽 × log2(1+SNR)（SNR:信噪比）</h4><p><strong>香农公式中没有指出信号电平，意味着无论使用多少个电平，都不可能获得比通道容量更高的数据速率，即香农公式定义了噪声通道理论上的最高数据速率。</strong></p><h5 id="衡量网络性能"><a href="#衡量网络性能" class="headerlink" title="衡量网络性能"></a>衡量网络性能</h5><ul><li>带宽：以赫兹 为单位的带宽（物理层），以比特率衡量（网络中通常之这种）</li><li>吞吐量：单位时间成功传输数据的数量，</li></ul><p>​<img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242341279.png" alt="image-20230924234149233"></p><ul><li><p>延迟：</p><ul><li><strong>传播时间:指一个比特从源到目标的时间，取决于电磁信号的传播距离&#x3D;距离&#x2F;传播速度</strong></li><li><strong>传输时间&#x3D;报文长度&#x2F;传输速度</strong></li><li>排队时间</li><li>处理延迟</li></ul><p> 延迟&#x3D;传播延迟+传输延迟+排队时间+处理延迟</p></li></ul><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242354546.png" alt="image-20230924235443507"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 大三上 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java语法</title>
      <link href="/2023/09/24/java%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/09/24/java%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="java语法"><a href="#java语法" class="headerlink" title="java语法"></a>java语法</h1><p>java语言特点： </p><ul><li><p>平台无关性：JVM</p></li><li><p>面向对象：</p><p>继承，封装，多态</p></li><li><p>支持多线程:</p><p>java的多线程是通过继承Thread类实现的，c++的多线程是通过引入std：：thread实现的</p></li><li><p>解释和编译共存</p></li></ul><h2 id="JVM-JDK-JRE的区别"><a href="#JVM-JDK-JRE的区别" class="headerlink" title="JVM,JDK,JRE的区别"></a>JVM,JDK,JRE的区别</h2><p>JVM：java虚拟机，java程序运行在java虚拟机上，因此可对不同的平台实现java程序，所以java语言能够实现跨平台</p><p>JDK: java development Kit&#x3D;jRE +JVM+开发工具</p><p>jre&#x3D;jvm+核心类库</p><p>跨平台的实现原理：java源代码被编译成字节码，字节码可以被翻译成机器能够识别的机器码。</p><p>所以我们要理解为什么字节码能够被虚拟机所识别:</p><p>以下是一段java代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后java代码被编译为Javac.c代码</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309241348919.png" alt="image-20230924134850731"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>:  ldc           #<span class="number">2</span>                  <span class="comment">// String Hello, World!</span></span><br><span class="line"><span class="number">2</span>:  astore_1</span><br><span class="line"><span class="number">3</span>:  getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="number">6</span>:  aload_1</span><br><span class="line"><span class="number">7</span>:  invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line"><span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>字节码我觉得可以理解为汇编代码，就是中间代码。汇编代码也可以在不同的平台上执行。不同的平台安装对应的虚拟机，jvm将字节码翻译为二进制机器码，就可以实现java语言的平台无关性了</p><h2 id="java语言的编译与解释共存"><a href="#java语言的编译与解释共存" class="headerlink" title="java语言的编译与解释共存"></a>java语言的编译与解释共存</h2><p>编译型编程语言：源代码一次性翻译为可执行的机器代码</p><p>解释型编程语言：一行一行的解释成计价器代码</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309241400586.png" alt="image-20230924140033530"></p><p>java数据类型</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309241407585.png" alt="image-20230924140711529"></p><p>为什么在有的时候使用基本数据类型的时候一定要用它的包装类，而不使用他自己。</p><p>1.因为包装类提供一些方法，比如转化成String类型，Byte类型等，这些方法只有他的包装类型才有，它本书没有，这些方法可以很好的帮助我们去做转化</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309241419123.png" alt="image-20230924141900084"></p><p>2.java的一些繁星参数列表只有包装类型。比如list，set，map等</p><p>3.方法参数和返回值：如果一个方法需要进行一些特殊的处理或判断，或者需要返回一个整数，但是又需要保留null值的可能性，就可以使用Integer作为参数和返回值类型。</p><p>java可以自动对这些数据类型进拆箱和装箱</p><h2 id="自动转化类型，强制转化类型"><a href="#自动转化类型，强制转化类型" class="headerlink" title="自动转化类型，强制转化类型"></a>自动转化类型，强制转化类型</h2><p>自动转化，从小到大</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309241421151.png" alt="image-20230924142138116"></p><p>强制转化就是反过来</p><h2 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp; 和&amp;&amp;的区别"></a>&amp; 和&amp;&amp;的区别</h2><p>&amp;和&amp;&amp;都要求两边是同时为真，但是</p><p>&amp;&amp;：短路与：左边为false时，就不会判断右边了</p><p>&amp;：逻辑与，左边为false时，还要继续判断右边</p><h2 id="break，continue，return的区别"><a href="#break，continue，return的区别" class="headerlink" title="break，continue，return的区别"></a>break，continue，return的区别</h2><p>break：跳出整个循环</p><p>continue： 跳出本次循环，继续执行下一次循环</p><p>return： 程序返回，不再执行下面的代码</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309241426441.png" alt="image-20230924142602402"></p><h2 id="java在处理自增增运算的时候和自我赋值操作时"><a href="#java在处理自增增运算的时候和自我赋值操作时" class="headerlink" title="java在处理自增增运算的时候和自我赋值操作时"></a>java在处理自增增运算的时候和自我赋值操作时</h2><p>是先付给一个临时变量，再自增增，自增增之后，再赋值回去，所以它的值不会发生变化</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309241427030.png" alt="image-20230924142737997"></p><h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><p>面向对象：把问题纷纷凝结成哥哥对象 —&gt;编年体</p><p>面向过程：把问题分解成步骤—&gt;纪传体</p><h2 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h2><ul><li>继承：使用已存在的类，定义新类过程，可以继承原类，继承原类的方法和属性</li><li>封装：指将数据和操作数据的方法封装在一个类中，对外部隐藏具体的实现细节，只暴露必要的接口供其他类使用。封装的目的是为了提高软件的可维护性、可扩展性和安全性</li><li>多态：一个统一的接口来处理不同类型的对象，使得不同的对象可以以一致的方式进行操作和使用。多态性能够增加代码的灵活性、可扩展性和可维护性。比如说向上转型，overwrite，继承关系等</li></ul><h1 id="Java基本语法"><a href="#Java基本语法" class="headerlink" title="Java基本语法"></a>Java基本语法</h1><h2 id="标识符与数据类型"><a href="#标识符与数据类型" class="headerlink" title="标识符与数据类型"></a>标识符与数据类型</h2><h6 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h6><p>java区分大小写，以分隔符”；“结束语句</p><p>java注释类型： &#x2F;&#x2F; &#x2F;* *&#x2F;</p><h6 id="java标识符的定义规则"><a href="#java标识符的定义规则" class="headerlink" title="java标识符的定义规则"></a>java标识符的定义规则</h6><p>标识符以字母，”-“或”$”开始的字符</p><p>数字不能作为标识符的第一个字符</p><p>标识符不能是java关键字</p><p>标识符大小写敏感，且长度没有限定</p><h5 id="访问修饰符-public，private，protected以及不写时的区别"><a href="#访问修饰符-public，private，protected以及不写时的区别" class="headerlink" title="访问修饰符 public，private，protected以及不写时的区别"></a>访问修饰符 public，private，protected以及不写时的区别</h5><table><thead><tr><th>可见性</th><th>private</th><th>default</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>同一个类</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>同一个包</td><td>×</td><td>√</td><td>√</td><td>√</td></tr><tr><td>子类当中</td><td>×</td><td>×</td><td>√</td><td>√</td></tr><tr><td>全局</td><td>×</td><td>×</td><td>×</td><td>√</td></tr></tbody></table><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>基本形式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K,V&gt;</span><br></pre></td></tr></table></figure><p>Map 是一个接口，我们不能直接创建对象，可以通过多态的形式创建对象，Map中有两个参数，一个是K表示键，一个是V表示值，且一个键有一个对应值，Map中不能包含重复键，如果有冲附件添加，会以最后一次键为准，而其他键会被覆盖。</p><p>Map分类</p><ul><li>HashMap</li><li>TreeMap</li></ul><h4 id="Map的基本功能"><a href="#Map的基本功能" class="headerlink" title="Map的基本功能"></a>Map的基本功能</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(key,value); <span class="comment">//添加键值对</span></span><br><span class="line">map.remove(key);<span class="comment">//删除键为key的键值对</span></span><br><span class="line">map.contains(key);<span class="comment">//判读map是否包含键</span></span><br><span class="line">map.contains(value);<span class="comment">//判断map是否包含值</span></span><br><span class="line">map.isEmpty();<span class="comment">//判断map是否为空</span></span><br><span class="line">map.size();<span class="comment">//求map的大小</span></span><br></pre></td></tr></table></figure><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309241924347.png" alt="image-20230924192425215"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">value=map.get(key);<span class="comment">//根据键获取值</span></span><br><span class="line">Set=map.keySet();<span class="comment">//获取所有键的集合</span></span><br><span class="line">Collection&lt;K&gt; collection=map.values()<span class="comment">//获取所有的值</span></span><br><span class="line"> Set&lt;Map.Entry&lt;k,V&gt;&gt;  entrySet  =map.entrySet();<span class="comment">//获取键值对对象的所有集合</span></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL--DQL</title>
      <link href="/2023/09/23/SQL-DQL/"/>
      <url>/2023/09/23/SQL-DQL/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL-–DQL"><a href="#SQL-–DQL" class="headerlink" title="SQL –DQL"></a>SQL –DQL</h2><h2 id="DQL介绍"><a href="#DQL介绍" class="headerlink" title="DQL介绍"></a>DQL介绍</h2><p>DQL是查询语句负责查询表中的业务</p><p>通常分为以下几类</p><ul><li><p>基本查询（不带任何条件）</p></li><li><p>条件查询（WHERE）</p></li><li><p>聚合函数（count、max、min、avg、sum）</p></li><li><p>分组查询（group by）</p></li><li><p>排序查询（order by）</p></li><li><p>分页查询（limit）</p><p>查询的语句语法是</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">字段列表</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">表名列表</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">条件列表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">分组字段列表</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">分组后条件列表</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">排序字段列表</span><br><span class="line">limit</span><br><span class="line">分页参数</span><br><span class="line">```</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code> ## 基础查询</code></pre></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure><p>为了实现这个我们创建了两个表：person_info,city。来存储信息</p><p>两张表创建完成之后，插入的信息如下</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231716676.png" alt="image-20230923171647645"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231707350.png" alt="image-20230923170734296"></p><p>我们从表中查询的语句如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  字段名 <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure><ol><li>查询一张表中的所有字段，所有元组</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231719519.png" alt="image-20230923171925480"></p><p>然后就能看见表中的所有信息。</p><ol start="2"><li><p>查询表中的部分字段</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231722957.png" alt="image-20230923172217925"></p><p>查询过程中设置字段别名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span> <span class="keyword">as</span> 别名 <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231726744.png" alt="image-20230923172611713"></p><p>查询过程中去除某行的重复记录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 字段名  <span class="keyword">from</span> 表名;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231729361.png" alt="image-20230923172949331"></p><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p>语法</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件列表 ;</span><br></pre></td></tr></table></figure><p>where当中是查询的条件</p><p>例子：</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231732215.png" alt="image-20230923173217173"></p><p>where当中就是查询的条件</p><p>条件比较运算符：</p><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt; 或者!&#x3D;</td><td>不等于</td></tr><tr><td>betw…and…</td><td>在某个范围</td></tr><tr><td>in</td><td>in之后的列表选一个</td></tr><tr><td>is null</td><td>是空值</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>AND</td><td>或 &amp;&amp; 并且 (多个条件同时成立)</td></tr><tr><td>OR</td><td>或</td></tr><tr><td>NOT</td><td>或 ! 非 , 不是</td></tr></tbody></table><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231737581.png" alt="image-20230923173737544"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231738136.png" alt="image-20230923173815109"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231739115.png" alt="image-20230923173933079"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231740966.png" alt="image-20230923174021930"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231740079.png" alt="image-20230923174032049"></p><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p>模糊查询中</p><p>“%”表示任意长度的字符或者数字</p><p>“-“表示任意一个字符或者数字</p><p>案例：查找表中任意一个名字为两个字符的元组</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231745389.png" alt="image-20230923174557350"></p><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>介绍：将一列数据作为一个整体，进行纵向计算</p><p>常见函数</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值（average）</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><p>案例</p><p>统计元组数量</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231749844.png" alt="image-20230923174953814"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231750192.png" alt="image-20230923175059153"></p><p>案例：统计员工的平均年龄，最大年龄，最小年龄，年龄之和</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231753944.png" alt="image-20230923175302911"></p><h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><p>分组查询是指根据一个或多个列的值将数据分组，并对每个组进行聚合计算的查询操作。分组查询通常与聚合函数（如SUM、AVG、COUNT等）一起使用，以对每个组的数据进行统计或计算。</p><p>案例：按照姓名字符数进行分组</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231759385.png" alt="image-20230923175921352"></p><p>其他案例</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231800867.png" alt="image-20230923180055829"></p><h2 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h2><p>语法</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名<span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span> 字段<span class="number">1</span> 排序方式一，字段<span class="number">2</span> 排序方式二</span><br></pre></td></tr></table></figure><p>排序方式分类</p><ul><li>desc 降序</li><li>asc 升序（默认）</li></ul><p>案例：查询所有员工，并且按照年龄降序方式排列</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231804835.png" alt="image-20230923180454791"></p><p>案例： 查询所有员工并且按照升序方式排列</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231805161.png" alt="image-20230923180535118"></p><p>其他案例</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231805443.png" alt="image-20230923180558410"></p><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>分页操作在业务系统开发时，也是非常常见的一个功能，我们在网站中看到的各种各样的分页条，后台<br>都需要借助于数据库的分页操作。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 limit 起始索引, 查询记录数 ;</span><br></pre></td></tr></table></figure><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231824793.png" alt="image-20230923182412754"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL--DDL</title>
      <link href="/2023/09/23/SQL-DDL/"/>
      <url>/2023/09/23/SQL-DDL/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL–DDL"><a href="#SQL–DDL" class="headerlink" title="SQL–DDL"></a>SQL–DDL</h1><div class="markmap-container" style="height:250px">  <svg data="{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;sql-ddl&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;创建&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;数据库创建：create database 数据表名&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[3,6]},&quot;v&quot;:&quot;表格创建： create table person_info(&lt;br&gt;\nid int primary key comment &#39;工号&#39;,&lt;br&gt;\n...}&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;删除&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;删除数据库：drop database xxx;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;删除表格：drop table xxx；&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;删除表格中某一行：alter table 表名 drop 字段名;&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;修改&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;修改表名数据库名：rename 原数据库名/原表明 to 新数据库名/新表名&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;修改原数据库中的某一列&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;alter table 表名 add 字段名 类型(长度) [comment 注释] [约束];&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束];&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;alter table 表名 modify 字段名 新数据类型(长度);&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;展示数据库/表格&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;展示数据库结构：show tables&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;展示当前表格结构：desc table 表名&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;展示当前数据库的创建语句： show create table 表名&quot;}]}]}"></svg></div><p>SQL程序语言有四种类型，对数据库的基本操作都属于这四类，它们分别为；数据定义语言(DDL)、数据查询语言（DQL）、数据操纵语言（DML）、数据控制语言（DCL）</p><p>创建表格之前需要先创建数据库，以下是对数据库操作的一些语言</p><h2 id="创建数据库，选择数据库，查看数据库"><a href="#创建数据库，选择数据库，查看数据库" class="headerlink" title="创建数据库，选择数据库，查看数据库"></a>创建数据库，选择数据库，查看数据库</h2><p>创建表格之前需要先选择数据库，然后创建数据库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show databases; #展示但所有数据库</span><br><span class="line">create database  person; #创建名叫person的数据库</span><br><span class="line">use person;#使用名叫person的数据库</span><br><span class="line">select database(); #查看当前所用的数据库</span><br></pre></td></tr></table></figure><h2 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h2><p>然后再创建数据库，语法如下，每行“,”结尾，然后创建完数据库之后以”；“结尾，数据库都是如此，语言以”，“好结尾</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table person_info( </span><br><span class="line">id int primary key comment &#x27;工号&#x27;,   </span><br><span class="line">name varchar(255) comment &#x27;员工姓名&#x27;,   </span><br><span class="line">age int comment &#x27;员工年龄&#x27;,   </span><br><span class="line">acount varchar(255) comment &#x27;员工账号&#x27; ,</span><br><span class="line">depart varchar(255) comment &#x27;员工部门&#x27;, </span><br><span class="line">position varchar(255) comment  &#x27;员工职位&#x27;</span><br><span class="line">); #创建数据库的信息</span><br></pre></td></tr></table></figure><p><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/1.png" alt="img"><br><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/2.png" alt="img"></p><p>然后有了表格，可以再创建一个和他有关联的表格 –&gt;<br> 注意自动增加列必须为主键，一个表格可以有多个主键，写多个主键的时候要采用符合主键的写法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table city</span><br><span class="line">(    id int auto_increment ,  </span><br><span class="line">depart varchar(255)  comment &#x27;部门&#x27;,  </span><br><span class="line">city varchar(255) comment &#x27;城市&#x27;,   </span><br><span class="line">primary key (id,depart)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="复合主键和普通主键的区别"><a href="#复合主键和普通主键的区别" class="headerlink" title="复合主键和普通主键的区别"></a><u>复合主键和普通主键的区别</u></h3><p>复合主键和普通主键都能唯一标识一组元组，复合主键查询成本更高</p><h3 id="设置表格与表格之间的外键"><a href="#设置表格与表格之间的外键" class="headerlink" title="设置表格与表格之间的外键"></a>设置表格与表格之间的外键</h3><p>外键的定义：<br>1.外键是某个表中的一列，它包含在另一个表的主键中。<br>2.外键也是索引的一种，是通过一张表中的一列指向另一张表中的主键，来对两张表进行关联。<br>3.一张表可以有一个外键，也可以存在多个外键，与多张表进行关联。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名</span><br><span class="line">ADD CONSTRAINT FK_外键名称 FOREIGN KEY (列名) REFERENCES 另一张表名(另一张表的主键);</span><br><span class="line">alter table person_info add constraint p_d foreign key (depart) references  </span><br><span class="line">city(depart) ;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意添加数据时要先向主表中添加数据，在向从表中添加数据（reference当中必须有关联的数据）<br><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/3.png" alt="img"></p><h2 id="向表格当中添加数据"><a href="#向表格当中添加数据" class="headerlink" title="向表格当中添加数据"></a>向表格当中添加数据</h2><p><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/4.png" alt="img"></p><p>语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into person_info (id, name, age, acount, depart, position) values (&#x27;1&#x27;,&#x27;张三&#x27;,&#x27;15&#x27;, &#x27;215100&#x27;,&#x27;人力资源&#x27;,&#x27;经理&#x27;);</span><br><span class="line">insert into city(depart, city) values (&#x27;人力资源&#x27;,&#x27;西安&#x27;);</span><br></pre></td></tr></table></figure><h2 id="查询表结构"><a href="#查询表结构" class="headerlink" title="查询表结构"></a>查询表结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">desc 表名 查询表明</span><br><span class="line">desc person_info </span><br></pre></td></tr></table></figure><p><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/5.png" alt="img"></p><h2 id="查询表的创建语句"><a href="#查询表的创建语句" class="headerlink" title="查询表的创建语句"></a>查询表的创建语句</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show create table 表名</span><br><span class="line">show create table page_info</span><br></pre></td></tr></table></figure><p><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/6.png" alt="img"></p><h2 id="修改表的某一列"><a href="#修改表的某一列" class="headerlink" title="修改表的某一列"></a>修改表的某一列</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">alter table 表名 add  字段名  类型(长度)  [comment 注释]  [约束];</span><br><span class="line"></span><br><span class="line">alter table 表名 change  旧字段名  新字段名  类型(长度)  [comment 注释]  [约束];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alter table 表名 modify  字段名  新数据类型(长度);</span><br></pre></td></tr></table></figure><p>注意：change 可以修改名字<br>modify 智能修改数据类型<br>这些修改都不能修改主键约束<br><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/7.png" alt="img"></p><p>删除表的某一列</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 drop 字段名;</span><br></pre></td></tr></table></figure><p><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/8.png" alt="img"></p><h2 id="删除表或者数据库"><a href="#删除表或者数据库" class="headerlink" title="删除表或者数据库"></a>删除表或者数据库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">drop  table [ if exists ]  表名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">drop  database [ if exists ]  数据库名;</span><br></pre></td></tr></table></figure><p><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/9.png" alt="img"></p><p><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/10.png" alt="img"></p><h2 id="修改数据库或表格的名字"><a href="#修改数据库或表格的名字" class="headerlink" title="修改数据库或表格的名字"></a>修改数据库或表格的名字</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename 表格名/数据库名 to 新名字</span><br></pre></td></tr></table></figure><p><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/13.png" alt="img"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA热部署</title>
      <link href="/2023/09/17/IDEA%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
      <url>/2023/09/17/IDEA%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA热部署"><a href="#IDEA热部署" class="headerlink" title="IDEA热部署"></a>IDEA热部署</h1><p>如何使得IDEA新建一个SpringBoot的时候如何一边写代码一边运行<br>（自动化完成重启）<br>解决办法：开发环境热部署<br>安装spring-boot-dev-tools<br><code>https://mvnrepository.com/</code></p><p>1.首先在pom.xml当中加入依赖</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.1.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.然后下载完毕之后，再在apllication当中增加配置<br>如果是yml文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    devtools:  </span><br><span class="line">        restart:   </span><br><span class="line">        enabled: true</span><br><span class="line">        additional-paths: src/main/java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果是propertites文件<br>就是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.devtools.restart.enabled=true</span><br><span class="line">spring.devtools.addition-paths=src/main/java</span><br></pre></td></tr></table></figure><p>3.如果是eclipse软件，这样就行了。如果是IDEA软件，还需要<br>打开<br>File-&gt;settings-&gt;Build-&gt;Exceution-&gt;Deployment-&gt;Comple-&gt;勾选BUild project automatically<br>  4.快捷键<br>  ctr+shift+alt+&#x2F;<br> 打开registergouxuan<br> compler.automake.allow+&#x3D;.when.app.running</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享chatGPT二次开发应用</title>
      <link href="/2023/07/17/%E5%88%86%E4%BA%ABchatGPT%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/"/>
      <url>/2023/07/17/%E5%88%86%E4%BA%ABchatGPT%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="基于chatgpt的二次开发应用"><a href="#基于chatgpt的二次开发应用" class="headerlink" title="基于chatgpt的二次开发应用"></a>基于chatgpt的二次开发应用</h1><h2 id="秘塔写作猫"><a href="#秘塔写作猫" class="headerlink" title="秘塔写作猫"></a><a href="https://xiezuocat.com/">秘塔写作猫</a></h2><p>介绍：给标题直接进行写作，可用于水作业。比如一些水课的大作业。还有语法改错等</p><h2 id="未来百科"><a href="#未来百科" class="headerlink" title="未来百科"></a><a href="https://www.futurepedia.io/">未来百科</a></h2><p>介绍：会介绍一些基于AI二次开发的应用，<br>我觉得还不错，上面的一些工具都还挺有意思的</p><h2 id="一些读论文的工具"><a href="#一些读论文的工具" class="headerlink" title="一些读论文的工具"></a>一些读论文的工具</h2><p><a href="explainpaper.com">解释纸 </a><br><a href="Lateral.io">Lateral.io</a>)<br><a href="https://arxivxplorer.com/">搜索论文的工具</a><br><a href="https://www.chatpdf.com/">chatPDF</a></p><h2 id="更多的工具"><a href="#更多的工具" class="headerlink" title="更多的工具"></a>更多的工具</h2><p><a href="https://github.com/LangLangShanDeNanKe/chatgpt">点击链接1</a><br><a href="https://github.com/yzfly/awesome-chatgpt-zh">点击链接2</a><br>github上面分享的一些关于gpt二次开发的应用</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>today</title>
      <link href="/2023/03/29/today/"/>
      <url>/2023/03/29/today/</url>
      
        <content type="html"><![CDATA[<h1 id="TODAY"><a href="#TODAY" class="headerlink" title="TODAY"></a>TODAY</h1><p>今天也要好好学习<br>不管了，就这样吧。反正是试试。<br><a href="https://github.com/lhx715/lhx715.github.io/blob/master/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230329110638.jpg" title="无"><img src="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230329110638.jpg" alt="无" title="无"></a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/27/hello-world/"/>
      <url>/2023/03/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
