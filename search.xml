<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java设计模式</title>
      <link href="/2024/02/10/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/02/10/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> [object Object] </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/25/%E8%AE%A1%E7%BD%91/"/>
      <url>/2024/01/25/%E8%AE%A1%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="1-说说计算机网络体系结构"><a href="#1-说说计算机网络体系结构" class="headerlink" title="1.说说计算机网络体系结构"></a>1.说说计算机网络体系结构</h2><p>OSI七层模型，TCP&#x2F;IP5层模型，五层结构</p><p>OSI:</p><p>应用层</p><p>表示层</p><p>会话层应用层应用层</p><p>传输层传输层传输层</p><p>网络层网络层网络层</p><p>数据链路层     数据链路层</p><p>物理层          网络接口层      物理层</p><p>OSI是一个<strong>理论上</strong>的网络通信模型，TCP&#x2F;IP是<strong>实际上</strong>的网络通信模型，五层模型是为了介绍<strong>网络原理折中</strong>的网络通信模型</p><h2 id="2-数据在各层之间是如何传输的"><a href="#2-数据在各层之间是如何传输的" class="headerlink" title="2.数据在各层之间是如何传输的"></a>2.数据在各层之间是如何传输的</h2><p>物理层：比特流从一跳到另一跳的传递</p><p>数据链路层：物理层的数据无差错的传递给数据链路层，负责将帧从一条到另一跳</p><p>功能：成帧，物理寻址，流量控制，差错控制，访问控制</p><p>网络层：负责将各个分组从源地址传递到目的地址</p><p>功能：逻辑寻址，路由选择</p><p>传输层：负责将报文从一个进程到另一个进程的传递</p><p>（分段，组装，连接控制，流量控制，差错控制）</p><p>会话层：负责会话的控制和同步（会话控制，同步，session）</p><p>表示层：翻译加密，压缩数据</p><p>应用层：向用户提供服务</p><p>3.从浏览器输入url到显示主页的过程</p><ol><li><p>查缓存，浏览器有没有缓存这个页面。</p></li><li><p>dns解析：</p></li></ol><p>将域名解析为ip地址：浏览器先在缓存中找有没有域名和ip对应的缓存，如果没有就去dns服务器查找对应域名得ip</p><ol start="3"><li><p>tcp3次握手</p><p>和目标地址建立3次握手，建立连接</p></li><li><p>http传输</p><p>浏览器向服务器发起一个http请求，服务端处理请求，返回http响应。浏览器解析并且渲染页面</p></li><li><p>tcp四次挥手</p><p>断开连接，</p></li></ol><h2 id="3-说说websokect和socket得区别"><a href="#3-说说websokect和socket得区别" class="headerlink" title="3. 说说websokect和socket得区别"></a>3. 说说websokect和socket得区别</h2><p>websokect：持<strong>久化化协议，低延迟，全双工</strong>和<strong>长期运行</strong>的协议</p><p>优点：</p><p>双向实时通信</p><p>降低延迟</p><p>更高效的资源利用</p><p> 限制：</p><p>不提供加密功能</p><p>不支持古老的浏览器</p><p>websocket是建立在http协议上的一个双向的协议，http是单向的协议</p><p>所以websokect是应用层的协议</p><p><strong>socket不是协议，是方便使用tcp和udp抽象出来的一组接口</strong></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202401251623732.png" alt="image-20240125162243157"></p><p>http是断开响应式，websocket则会通过poll轮询来保持连接。说穿了就是http只能客户端请求服务端才能响应。而websocket服务端可以将数据发送给客户端。</p><h2 id="4-说一下你了解的端口及对应的服务"><a href="#4-说一下你了解的端口及对应的服务" class="headerlink" title="4.说一下你了解的端口及对应的服务"></a>4.说一下你了解的端口及对应的服务</h2><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202401251631266.png" alt="image-20240125163111224"></p><h2 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h2><p>cdn（content delivery network）是一种全球网络分发系统，把网站复制到里用户近的服务器上，提高网站的性能和速度。</p><p>CDN静态加速</p><p>使用缓存技术，将不经常修改的内容拷贝到服务器上</p><p>CDN动态加速：不仅使用缓存，还使用动态内容优化技术，加速数据库查询和动态页面的生成，针对的是经常修改的，</p><h2 id="http常用的状态码"><a href="#http常用的状态码" class="headerlink" title="http常用的状态码"></a>http常用的状态码</h2><p>1xx：信息状态码</p><p>2xx：成功状态码</p><p>3xx：重定向状态码</p><p>4xx：客户端错误状态码</p><p>5xx：服务端错误状态码</p><p>101：切换请求协议</p><p>200：请求成功</p><p>301：请求资源永久移动</p><p>302：请求资源临时移动</p><p>400：客户端请求的语法错误</p><p>401：当前请求需要认证</p><p>403：服务端理解请求，但拒绝执行</p><p>500：服务器内部错误</p><h2 id="说说301和302的区别"><a href="#说说301和302的区别" class="headerlink" title="说说301和302的区别"></a>说说301和302的区别</h2><p>301：<strong>永久性移动</strong>，请求的资源已被移动到新位置。服务器返回响应时，会返回<strong>新的资源地址</strong></p><p>302：<strong>临时性移动</strong>，服务器从另外的地址响应资源，但是客户还应该<strong>继续使用这个地址</strong></p><h2 id="http有哪些请求方式"><a href="#http有哪些请求方式" class="headerlink" title="http有哪些请求方式"></a>http有哪些请求方式</h2><p>get     向服务器获取简单的资源请求</p><p>post    向服务器提交数据请求</p><p>put      修改指定资源</p><p>delete    删除url标记的指定资源</p><p>connect   用于代理服务器</p><p>trance   主要用于换回测试</p><p>options  返回所有可用的方法</p><p>head     获取url标记的资源首部</p><p>post，delete，put，get对应我们最熟悉的增删改查</p><h2 id="get和post的区别"><a href="#get和post的区别" class="headerlink" title="get和post的区别"></a>get和post的区别</h2><ol><li><p>从http报文层面来看：<strong>get</strong>是吧请求信息放在<strong>u</strong>rl当作。<strong>post</strong>是把请求信息放在<strong>请求体</strong>当中。这一点使得<strong>get请求携带的数据有限</strong>。因为url本身是有长度限制的。post把数据请求放在报文体当中，对大小没有限制，从形式上看get把数据放在url当中不太安全，post把数据放在请求体当中比较安全</p></li><li><p>从数据层面来看：</p></li></ol><p>get符合幂等性和安全性，post不符合。按照http约定，get用于查看信息，post用来改变服务器上的信息。正因为get只请求查看信息，所以多次请求，所以对服务器产生的影响是相同的</p><ol start="3"><li>其他层面来看，get请求能够被缓存，get请求的url能保存为浏览器的数千，post请求不具备。，缓存时get能够被广泛应用的根本，它能够被缓存也是因为它的幂等性和安全性。除了返回结果没有多余动作。因此绝大部分get请求都被CDN缓存起来了，大大减少了web服务器的负担</li></ol><p>什么幂等性：方法被多次执行的时候所产生的影响和第一次执行产生的影响相同，</p><p>如何解决：使用数据库的唯一约束</p><p>redis提供的setnx</p><p>状态机，乐观锁</p><h2 id="get的长度限制是多少"><a href="#get的长度限制是多少" class="headerlink" title="get的长度限制是多少"></a>get的长度限制是多少</h2><p>http中的get是通过url进行数据传递的，url本身其实没有对数据的长度进行限制，真正限制get长度的是浏览器。比如IE浏览器，对url的限制是2000个字符们大概2kb左右这个给长度限制不是针对数据而言而是整个url</p><h2 id="http-请求的过程和原理"><a href="#http-请求的过程和原理" class="headerlink" title="http 请求的过程和原理"></a>http 请求的过程和原理</h2><p>客户端发起请求： </p><p>建立tcp连接</p><p>发送http请求</p><p>服务器处理请求</p><p>服务器发送响应</p><p>客户端接受响应</p><p>关闭TCP连接</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/23/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0/"/>
      <url>/2024/01/23/%E7%AE%97%E6%B3%95%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="算法日记"><a href="#算法日记" class="headerlink" title="算法日记"></a>算法日记</h1><h2 id="删除链表中重复元素的所有结点"><a href="#删除链表中重复元素的所有结点" class="headerlink" title="删除链表中重复元素的所有结点"></a>删除链表中重复元素的所有结点</h2><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202401231633889.png" alt="image-20240123163303779"></p><p>代码思路：</p><p>1.递归</p><p>递归终止条件</p><ol><li>如果head为空，那么肯定没有重复元素，直接返回</li><li>如果head.val!&#x3D;head.next.val，就要保留当前结点，对当前结点之后的结点做递归，看看后面的结点是不是有重复元素</li><li>如果head.val&#x3D;&#x3D;head.next.val ，就要找到不等于head.val的之后的结点，返回之后结点的递归</li></ol><p>代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>(head==<span class="literal">null</span>)</span><br><span class="line">           <span class="keyword">return</span> head;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (head.next!=<span class="literal">null</span>&amp;&amp;head.val!=head.next.val) &#123;</span><br><span class="line">           head.next=deleteDuplicates(head.next);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head.next!=<span class="literal">null</span>&amp;&amp;head.val==head.next.val) &#123;</span><br><span class="line">           ListNode h=head.next;</span><br><span class="line">           <span class="keyword">while</span> (h!=<span class="literal">null</span>&amp;&amp;head.val==h.val)</span><br><span class="line">               h=h.next;</span><br><span class="line">           <span class="keyword">return</span>  deleteDuplicates(h);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span>  head;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a>旋转链表</h2><p><img src="C:\Users\86198\AppData\Roaming\Typora\typora-user-images\image-20240123181437576.png" alt="image-20240123181437576"></p><p>思路：</p><ol><li>计算出一共有多少个结点</li><li>计算出大头的结点时谁，找到打头结点</li><li>从打头结点开始，遍历一遍，最后一个结点的next置为null</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">rotateRight</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">      <span class="type">ListNode</span> <span class="variable">head1</span> <span class="operator">=</span> head;</span><br><span class="line">      <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (head1.next != <span class="literal">null</span>) &#123;</span><br><span class="line">          head1 = head1.next;</span><br><span class="line">          n++;</span><br><span class="line">      &#125;</span><br><span class="line">      head1.next = head;</span><br><span class="line">      head1=head;</span><br><span class="line">      k=n-k%n;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">      &#123;</span><br><span class="line">          head1=head1.next;</span><br><span class="line">      &#125;</span><br><span class="line">      head = head1;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">          head1 = head1.next;</span><br><span class="line">      &#125;</span><br><span class="line">      head1.next = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="分隔链表"><a href="#分隔链表" class="headerlink" title="分隔链表"></a>分隔链表</h2><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202401231827723.png" alt="image-20240123182715665"></p><p>思路：</p><p>1.两个链表一个链表存储值小的结点，另一个链表存储值大的结点，</p><p>2.小结点的next连接大大节点的prev上</p><h2 id="路径和最大"><a href="#路径和最大" class="headerlink" title="路径和最大"></a>路径和最大</h2><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202401242311215.png" alt="image-20240124231107086"></p><p>1.比较的是当前路径的最大和总的最大和</p><p>2.比较完了，要返回给上一结点左+右结点的路径和，让上一节点来选择怎么走</p><p>代码示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  <span class="type">int</span> max1;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.max1=Integer.MIN_VALUE;</span><br><span class="line">           dfsroot(root);</span><br><span class="line">            <span class="keyword">return</span> max1;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">dfsroot</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> max=root.val;</span><br><span class="line">        <span class="type">int</span> left=Math.max(dfsroot(root.left),<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> right=Math.max(dfsroot(root.right),<span class="number">0</span>);</span><br><span class="line">        max1=Math.max(max1,max+left+right);</span><br><span class="line">        <span class="keyword">return</span> max+Math.max(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二叉搜索树的-特点"><a href="#二叉搜索树的-特点" class="headerlink" title="二叉搜索树的  特点"></a>二叉搜索树的  特点</h1><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202401251357931.png" alt="image-20240125135718835"></p><p>结点的左孩子小于结点值，结点的右孩子大于结点值</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/25/%E8%80%83%E7%82%B9/"/>
      <url>/2023/12/25/%E8%80%83%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h1><p>程序题45分</p><p>第一讲：</p><ol><li><p>什么是嵌入式系统</p><p>从技术的角度：</p><p>   嵌入式系统是一个以应用为中心、以计算机技术为</p><p> 基础，并融合微电子技术、通信技术和自动控制技术，</p><p> 而且软硬件可裁剪，适用于应用系统对功能、可靠性、</p><p> 成本、体积、功耗和应用环境有特殊要求的专用计算机</p><p> 系统。</p></li></ol><p>第二讲</p><p>开发语言，过程</p><p>l<strong>2</strong> <strong>嵌入式系统开发过程</strong></p><p>l<strong>第<strong><strong>1</strong></strong>步 嵌入式系统需求分析</strong></p><p>l<strong>第<strong><strong>2</strong></strong>步 嵌入式系统设计</strong></p><p>l<strong>第<strong><strong>3</strong></strong>步 嵌入式系统实现</strong></p><p>l<strong>第<strong><strong>4</strong></strong>步 嵌入式系统测试</strong></p><p>l<strong>第<strong><strong>5</strong></strong>步 嵌入式系统发布</strong></p><p>第三四讲</p><p>1.基于什么样的处理器，指令集</p><p><strong>ARM****具有两套指令集：</strong></p><p><strong>——ARM****指令集</strong></p><p><strong>——Thumb****指令集</strong></p><p>第五讲</p><p>STM32103的总线</p><p>什么是低功耗模式</p><p>第六讲</p><p>基本概念</p><p>不通的工作模式</p><p>重映射</p><p>第七讲</p><p>如何计算</p><p>中断</p><p>中断的概念</p><p>中断的共享</p><p>中断的优先级</p><p>UART</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/12/19/%E8%AE%A1%E7%BD%91%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/"/>
      <url>/2023/12/19/%E8%AE%A1%E7%BD%91%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="计网配置信息"><a href="#计网配置信息" class="headerlink" title="计网配置信息"></a>计网配置信息</h2><p>查看ip</p><p>display ip interface brief </p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202312182153895.png" alt="img"></p><p>ISP:</p><p>设备：</p><p>AR2220</p><p>配置命令行：只需要加入两端的ip地址即可</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">sysname ISP</span><br><span class="line"></span><br><span class="line">interface GigabitEthernet0/0/0</span><br><span class="line"></span><br><span class="line"> ip address 202.82.100.2 255.255.255.248 </span><br><span class="line"></span><br><span class="line">interface GigabitEthernet0/0/1</span><br><span class="line"></span><br><span class="line"> ip address 203.82.101.254 255.255.255.0</span><br></pre></td></tr></table></figure><p>R1</p><p>设备</p><p>AR2220</p><p>命令配置：</p><p>acl协议配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysname R1</span><br><span class="line"></span><br><span class="line">acl number 2000 </span><br><span class="line"></span><br><span class="line"> rule 5 permit </span><br></pre></td></tr></table></figure><p>外网配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface GigabitEthernet0/0/0</span><br><span class="line"></span><br><span class="line"> ip address 202.82.100.1 255.255.255.248 </span><br><span class="line"></span><br><span class="line"> nat outbound 2000</span><br></pre></td></tr></table></figure><p>其他普通端口配置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface GigabitEthernet0/0/1</span><br><span class="line"></span><br><span class="line"> ip address 192.82.150.254 255.255.255.0 </span><br><span class="line"></span><br><span class="line">interface GigabitEthernet0/0/2</span><br><span class="line"></span><br><span class="line"> ip address 192.82.90.1 255.255.255.0</span><br><span class="line"></span><br><span class="line">interface GigabitEthernet4/0/0</span><br><span class="line"></span><br><span class="line"> ip address 192.82.200.1 255.255.255.0 </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置ospf路由</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ospf 1 </span><br><span class="line"></span><br><span class="line"> default-route-advertise always</span><br><span class="line"></span><br><span class="line"> area 0.0.0.0 </span><br><span class="line"></span><br><span class="line"> network 192.82.90.0 0.0.0.255 </span><br><span class="line"></span><br><span class="line"> network 192.82.150.0 0.0.0.255 </span><br><span class="line"></span><br><span class="line"> network 192.82.200.0 0.0.0.255 </span><br><span class="line"></span><br><span class="line">ip route-static 0.0.0.0 0.0.0.0 202.82.100.2</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置S1:</p><p>S5700</p><p>创建vlan，并且加入各种ip地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">sysname S1</span><br><span class="line"></span><br><span class="line">vlan batch 10 20 30 70 80 90</span><br><span class="line"></span><br><span class="line">interface Vlanif10</span><br><span class="line"></span><br><span class="line"> ip address 192.82.10.254 255.255.255.0 </span><br><span class="line"></span><br><span class="line">interface Vlanif20</span><br><span class="line"></span><br><span class="line"> ip address 192.82.20.254 255.255.255.0 </span><br><span class="line"></span><br><span class="line">interface Vlanif30</span><br><span class="line"></span><br><span class="line"> ip address 192.82.30.254 255.255.255.0 </span><br><span class="line"></span><br><span class="line"> dhcp select interface</span><br><span class="line"></span><br><span class="line">interface Vlanif70</span><br><span class="line"></span><br><span class="line"> ip address 192.82.70.254 255.255.255.0 </span><br><span class="line"></span><br><span class="line">interface Vlanif80</span><br><span class="line"></span><br><span class="line"> ip address 192.82.80.254 255.255.255.0 </span><br><span class="line"></span><br><span class="line"> dhcp select interface</span><br><span class="line"></span><br><span class="line"> dhcp server dns-list 192.82.150.20 </span><br><span class="line"></span><br><span class="line">interface Vlanif90</span><br><span class="line"></span><br><span class="line"> ip address 192.82.90.254 255.255.255.0 </span><br></pre></td></tr></table></figure><p>进入端口设置类型</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface GigabitEthernet0/0/1</span><br><span class="line"></span><br><span class="line"> port link-type trunk</span><br><span class="line"></span><br><span class="line"> port trunk allow-pass vlan 10</span><br><span class="line"></span><br><span class="line">interface GigabitEthernet0/0/2</span><br><span class="line"></span><br><span class="line"> port link-type trunk</span><br><span class="line"></span><br><span class="line"> port trunk allow-pass vlan 20</span><br><span class="line"></span><br><span class="line">interface GigabitEthernet0/0/3</span><br><span class="line"></span><br><span class="line"> port link-type trunk</span><br><span class="line"></span><br><span class="line"> port trunk allow-pass vlan 30</span><br><span class="line"></span><br><span class="line">interface GigabitEthernet0/0/4</span><br><span class="line"></span><br><span class="line"> port link-type trunk</span><br><span class="line"></span><br><span class="line"> port trunk pvid vlan 70</span><br><span class="line"></span><br><span class="line"> port trunk allow-pass vlan 70 80</span><br><span class="line"></span><br><span class="line">interface GigabitEthernet0/0/5</span><br><span class="line"></span><br><span class="line"> port link-type trunk</span><br><span class="line"></span><br><span class="line"> port trunk allow-pass vlan 70 80</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设置路由-交换机端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface GigabitEthernet0/0/24</span><br><span class="line"></span><br><span class="line"> port link-type access</span><br><span class="line"></span><br><span class="line"> port default vlan 90</span><br></pre></td></tr></table></figure><p>动态路由</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ospf 1 </span><br><span class="line"></span><br><span class="line"> area 0.0.0.0 </span><br><span class="line"></span><br><span class="line"> network 192.82.10.0 0.0.0.255 </span><br><span class="line"></span><br><span class="line"> network 192.82.20.0 0.0.0.255 </span><br><span class="line"></span><br><span class="line"> network 192.82.30.0 0.0.0.255 </span><br><span class="line"></span><br><span class="line"> network 192.82.70.0 0.0.0.255 </span><br><span class="line"></span><br><span class="line"> network 192.82.80.0 0.0.0.255 </span><br><span class="line"></span><br><span class="line"> network 192.82.90.0 0.0.0.255 </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同级S2</p><p>配置vlan</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysname S2</span><br><span class="line"></span><br><span class="line">vlan batch 40 50 60 100</span><br><span class="line"></span><br><span class="line">interface Vlanif40</span><br><span class="line"></span><br><span class="line"> ip address 192.82.40.254 255.255.255.0 </span><br><span class="line"></span><br><span class="line">interface Vlanif50</span><br><span class="line"></span><br><span class="line"> ip address 192.82.50.254 255.255.255.0 </span><br><span class="line"></span><br><span class="line">interface Vlanif60</span><br><span class="line"></span><br><span class="line"> ip address 192.82.60.254 255.255.255.0 </span><br><span class="line"></span><br><span class="line">interface Vlanif100</span><br><span class="line"></span><br><span class="line"> ip address 192.82.100.254 255.255.255.0 </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>普通接口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface GigabitEthernet0/0/1</span><br><span class="line"></span><br><span class="line"> port link-type trunk</span><br><span class="line"></span><br><span class="line"> port trunk allow-pass vlan 40</span><br><span class="line"></span><br><span class="line">interface GigabitEthernet0/0/2</span><br><span class="line"></span><br><span class="line"> port link-type trunk</span><br><span class="line"></span><br><span class="line"> port trunk allow-pass vlan 50</span><br><span class="line"></span><br><span class="line">interface GigabitEthernet0/0/3</span><br><span class="line"></span><br><span class="line"> port link-type trunk</span><br><span class="line"></span><br><span class="line"> port trunk allow-pass vlan 60</span><br></pre></td></tr></table></figure><p>路由器-交换机端口</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">interface GigabitEthernet0/0/4</span><br><span class="line"></span><br><span class="line"> port link-type access</span><br><span class="line"></span><br><span class="line">interface GigabitEthernet0/0/24</span><br><span class="line"></span><br><span class="line"> port link-type access</span><br><span class="line"></span><br><span class="line"> port default vlan 100</span><br></pre></td></tr></table></figure><p>动态路由</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ospf 1 </span><br><span class="line"></span><br><span class="line"> area 0.0.0.0 </span><br><span class="line"></span><br><span class="line"> network 192.82.40.0 0.0.0.255 </span><br><span class="line"></span><br><span class="line"> network 192.82.50.0 0.0.0.255 </span><br><span class="line"></span><br><span class="line"> network 192.82.60.0 0.0.0.255 </span><br><span class="line"></span><br><span class="line"> network 192.82.100.0 0.0.0.255 </span><br></pre></td></tr></table></figure><p>普通交换机s3700</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysname S3</span><br><span class="line"></span><br><span class="line">vlan batch 10</span><br><span class="line"></span><br><span class="line">interface Ethernet0/0/1</span><br><span class="line"></span><br><span class="line"> port link-type access</span><br><span class="line"></span><br><span class="line"> port default vlan 10</span><br><span class="line"></span><br><span class="line">interface GigabitEthernet0/0/1</span><br><span class="line"></span><br><span class="line"> port link-type trunk</span><br><span class="line"></span><br><span class="line"> port trunk allow-pass vlan 10</span><br></pre></td></tr></table></figure><p>普通交换机S4</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysname S4</span><br><span class="line">vlan batch 20</span><br><span class="line">interface Ethernet0/0/1</span><br><span class="line"> port link-type access</span><br><span class="line"> port default vlan 20</span><br><span class="line">interface GigabitEthernet0/0/1</span><br><span class="line"> port link-type trunk</span><br><span class="line"> port trunk allow-pass vlan 20</span><br><span class="line"></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/11/13/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2023/11/13/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql数据库"><a href="#mysql数据库" class="headerlink" title="mysql数据库"></a>mysql数据库</h1><p>索引：帮助mysql高效获取数据的数据结构</p><p>索引数据结构：</p><p>数据结构：</p><p>树的数据结构</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202311131702154.png" alt="image-20231113170257004"></p><p>那些情况需要创建索引</p><ol><li>主键自动创建索引</li><li>频繁作为查询条件的应该创建索引</li><li>查询中与其他表关联的字段，建立外键索引</li><li>多字段下倾向创建组合索引</li><li>查询中排序的字段，排序字段通过索引取访问将大大提高排序速度</li><li>查询中统计或者字段分组</li></ol><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>单独创建： &#96;&#96;&#96; alert table 表名 add primary key （字段名 ）&#96;</p><p>单独删除<code>alert table 表名  drop primary key</code></p><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>单独创建</p><figure class="highlight plaintext"><figcaption><span>~~~</span></figcaption><table><tr><td class="code"><pre><span class="line">alert  table 表名 add unique 索引名（字段名）</span><br><span class="line">或者 create unique index 索引名  on 表名（字段）</span><br></pre></td></tr></table></figure><h4 id="单值索引"><a href="#单值索引" class="headerlink" title="单值索引"></a>单值索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert  table 表名 add index 索引名（字段名）</span><br><span class="line">或者 create  index 索引名  on 表名（字段）</span><br></pre></td></tr></table></figure><h4 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert  table 表名 add index 索引名（字段1，字段2）</span><br><span class="line">或者 create  index 索引名  on 表名（字段1，字段2）</span><br></pre></td></tr></table></figure><h3 id="EXPAIN"><a href="#EXPAIN" class="headerlink" title="EXPAIN"></a>EXPAIN</h3><p>explain 关键字可以模拟优化SQL查询语句，从而指导MYSQL是如何处理SQL语句的，可以用来分析查询语句或者表结构的性能瓶颈，起作用</p><ul><li>表的读取顺序</li><li>哪些索引可以使用</li><li>数据取操作的操作类型</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202311132015123.png" alt="image-20231113201509051"></p><h6 id="id："><a href="#id：" class="headerlink" title="id："></a>id：</h6><p> 查询顺序</p><p>id相同时，执行顺序是从上往下</p><p>id不同时，id的值越大优先级越高，越先被执行</p><p>id相同</p><h6 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h6><p>simple:  简单的查询，不包括子查询或者UNION</p><p>PRIMARY: 查询中包含任何复杂的字部分，最外层查询被标记为primary</p><p>DERIVED:在from列表中的子查询被标记为DERIVED(衍生),mysql会递归执行这些子查询，把结果放在临时表中</p><p>SUNQUERY: 在select或者where列表当中包含了子查询</p><h6 id="type"><a href="#type" class="headerlink" title="type"></a>type</h6><p>访问类型排序，是否使用索引</p><p>System&gt;const&gt;eq&gt;ref&gt;range&gt;index&gt;all</p><p>all：将遍历全表来找到数据</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/11/12/Redis/"/>
      <url>/2023/11/12/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="1-什么时Redis"><a href="#1-什么时Redis" class="headerlink" title="1.什么时Redis"></a>1.什么时Redis</h2><p>1.基于键值对，nosql</p><p>2.五种基本数据类型，加geo，bitmap</p><p>3.数据在内存</p><p>4.读写性能</p><p>5.持久化</p><h2 id="2-redis可用用来干什么"><a href="#2-redis可用用来干什么" class="headerlink" title="2. redis可用用来干什么"></a>2. redis可用用来干什么</h2><p>1.缓存</p><p>2.计数器</p><p>4.排行榜</p><p>5.社交网络</p><p>6.消息队列</p><p>6.分布式锁</p><p>7.地址缓存</p><h1 id="3-redis的数据结构"><a href="#3-redis的数据结构" class="headerlink" title="3. redis的数据结构"></a>3. redis的数据结构</h1><ol><li><p>string</p></li><li><p>set</p></li><li><p>list</p></li><li><p>sortedset</p></li><li><p>hash</p></li></ol><h2 id="4-redis为什么快"><a href="#4-redis为什么快" class="headerlink" title="4. redis为什么快"></a>4. redis为什么快</h2><ol><li>完全基于内存操作</li><li>单线程</li><li>非阻塞的IO多路复用</li><li>优化的数据结构</li></ol><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><ol><li>什么是阻塞IO: 一堆线程来在排队工作，没有有限级</li><li>多路复用IO</li></ol><h2 id="redis为什么选择单线程"><a href="#redis为什么选择单线程" class="headerlink" title="redis为什么选择单线程"></a>redis为什么选择单线程</h2><ol><li>避免频繁的上下文切换</li><li>纯内存操作，cpu不会成为瓶颈。</li></ol><h2 id="redis-使用多线程"><a href="#redis-使用多线程" class="headerlink" title="redis 使用多线程"></a>redis 使用多线程</h2><p>处理数据的读写和协议解析，但是执行命令还是单线程的。</p><p>消除瓶颈段（网络IO ）</p><h2 id="redis持久化方法"><a href="#redis持久化方法" class="headerlink" title="redis持久化方法"></a>redis持久化方法</h2><ol><li><p>RDB</p><p>RDB把当前数据生成快照保存到硬盘，手动触发和自动触发</p><p>手动触发：</p><p>save，bgsave</p><p>自动触发</p><ol><li><p>修改redis.confg文件的save m,n</p><ol start="2"><li>从节点执行全量复制，主节点执行的bgsave的文件发送给从节点</li><li>执行dubug reload命令时，也会触发save操作</li><li>默认情况下shutdown，没有开启aof也会触发RDB</li></ol></li></ol></li><li><p>AOF</p><ol><li><p>以独立日志的方式记录每次写命令。重启时再重新执行AOF文件中的命令来恢复数据</p><p>解决了 数据持久化的   <strong>实时性问题</strong></p></li></ol><p>2.工作流程</p><ol><li>命令append到aof_buf</li><li>命令同步（sync） aof文件</li><li>aof 重写压缩</li><li>reload 数据恢复</li></ol><h2 id="rdb-和AOF各自的优缺点"><a href="#rdb-和AOF各自的优缺点" class="headerlink" title="rdb 和AOF各自的优缺点"></a>rdb 和AOF各自的优缺点</h2><p>1.rdb：</p><p>优：恢复速度快</p><p>​     只有一个dump.file文件（二进制）</p><p>​    容灾性好</p><p>缺：</p><ol><li>实时性低</li><li>存在兼容问题</li></ol><p>AOF:</p><p>优点：</p><ol><li>实行性好，配置apendfsync属性，always就可以每写入一条命令保存一次</li><li>通过append模式写文件的时候，即使服务器宕机，可用通过redis-check-aof工具来解决数据一致性问题</li></ol><p>缺点：</p><p>1.文件大</p><p>2.恢复速度不如RDB</p><h2 id="rdb和AOF如何选择"><a href="#rdb和AOF如何选择" class="headerlink" title="rdb和AOF如何选择"></a>rdb和AOF如何选择</h2><p>1.一般来说，想要达到数据安全性，应该同时使用RDB和AOF，   redis重启时就会优先载入AOF（数据更完整）</p><ol start="2"><li>接受分钟内数据丢失，选RDB</li></ol><h2 id="redis数据恢复过程"><a href="#redis数据恢复过程" class="headerlink" title="redis数据恢复过程"></a>redis数据恢复过程</h2><ol><li>redis启动,优先AOF,没有RDB</li></ol><h2 id="redis4-0混合持久化"><a href="#redis4-0混合持久化" class="headerlink" title="redis4.0混合持久化"></a>redis4.0混合持久化</h2><ol><li><p>解决aof启动慢的问题</p></li><li><p>前面部分时RDB文件，后面是AOF文件（持久化开始到持久化结束）</p></li><li><p>先加载RDB，再重放增量AOF</p></li></ol><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><h1 id="高可用的三种方式"><a href="#高可用的三种方式" class="headerlink" title="高可用的三种方式"></a>高可用的三种方式</h1><ol><li>主从，哨兵，集群</li></ol><h2 id="什么时主从复制"><a href="#什么时主从复制" class="headerlink" title="什么时主从复制"></a>什么时主从复制</h2><ol><li><p>redis主节点服务器的数据单向复制到从节点</p><p>用处</p><p>   1.数据冗余</p><ol start="2"><li>故障恢复</li><li>负载均衡</li><li>高可用基石</li></ol></li></ol><h2 id="redis主从复制常见的拓扑结构"><a href="#redis主从复制常见的拓扑结构" class="headerlink" title="redis主从复制常见的拓扑结构"></a>redis主从复制常见的拓扑结构</h2><ol><li>一主一丛</li><li>一主多从</li><li>树状</li></ol><h2 id="主从复制的过程"><a href="#主从复制的过程" class="headerlink" title="主从复制的过程"></a>主从复制的过程</h2><ol><li>保存主节点的ip地址和port</li><li>主从建立socket连接</li><li>发送ping命令</li><li>权限认证</li><li>同步数据集</li><li>命令持续复制</li></ol><h2 id="主从数据同步的方式"><a href="#主从数据同步的方式" class="headerlink" title="主从数据同步的方式"></a>主从数据同步的方式</h2><ol><li><p>redis2.8以上版本使用psync命令来完成主从数据同步，同步过程分为：全量复制和部分复制</p></li><li><p>全量复制</p><p>初次复制的场景，redis早期的复制</p></li></ol><h2 id="主从复制的问题"><a href="#主从复制的问题" class="headerlink" title="主从复制的问题"></a>主从复制的问题</h2><ol><li>故障恢复的自动化</li><li>单机限制了它的读写能力和存储能力</li></ol><h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><p>实现了： <strong>自动化故障恢复</strong></p><p>功能：</p><ol><li>监控</li><li>自动故障转移</li><li>配置提供者</li><li>通知</li></ol><h2 id="哨兵实现原理"><a href="#哨兵实现原理" class="headerlink" title="哨兵实现原理"></a>哨兵实现原理</h2><ol><li><p>定时监控-》客观下线  主观下线-&gt;领导者选举    故障转移</p></li><li><p>定时监控</p></li></ol><p>   10s 发送info，获取最新的拓扑结构</p><p>   2 s 发送sentinel，发送哨兵信息</p><ol><li><p>做心跳检测，确认结点是否可达</p></li><li><p>主观下线</p></li></ol><p>   哨兵结点认为某个结点有问题</p><ol><li><p>客观下线</p><p>超过一定结点认为结点有问题</p></li><li><p>领导者选举Raft算法</p><p>哨兵结点会选举出一个领导者来完成故障转移</p></li><li><p>故障转移具体程</p><ol><li>选择出新的主节点，执行slave of no命令</li><li>领导者向剩余结点发送命令让他们成为新主结点的从节点</li><li>密切关注原来结点，恢复后马上让他成为从节点</li></ol><h2 id="redis-存在脑裂问题"><a href="#redis-存在脑裂问题" class="headerlink" title="redis 存在脑裂问题"></a>redis 存在脑裂问题</h2><p>脑裂问题时指</p><ol><li><p>在分布式系统当中，优于网络原因从节点之间无法通信，多个结点认为自己是主节点</p><p>引发数据不一致现象</p></li></ol><p>避免脑裂问题的办法：</p><p>1.投票机制，哨兵投票哪个结点时主结点</p><ol start="2"><li>Quorum机制，哨兵结点数量超过一半时，才会进行故障转移。这样可以确保在网络分区时，集群中的大多数结点能相互通信，避免出现脑裂问题</li></ol></li></ol><h2 id="redis主节点挑选"><a href="#redis主节点挑选" class="headerlink" title="redis主节点挑选"></a>redis主节点挑选</h2><ol><li>过滤掉不健康的结点</li><li>选择优先级高的从节点</li><li>选择复制偏移量大的从节点</li><li>选择runid最小的从节点</li></ol><h2 id="redis集群"><a href="#redis集群" class="headerlink" title="redis集群"></a>redis集群</h2><p>1.哨兵解决了高可用，集群就是最终方案解决了分布式问题</p><p>原理就是</p><ol><li>数据分区：数据分区是集群最核心的功能，集群将数据分散到多个结点。一方面突破了</li></ol><p>   redis单机内存大小的限制，存储容量大大增加</p><ol start="2"><li><p>每个主节点都可以对望提供读服务和写服务，大大提高了集群的响应能力</p></li><li><p>高可用：主从复制和故障自动化转移</p></li></ol><p>数据分区</p><ol><li><p>结点取余分区： hash（key）%n来确定数据映射到哪个结点上</p></li><li><p>一致性哈希分区： 哈希值空间组成一个圆环，对key取hash函数，顺时针离哪个圆环近，就给谁</p></li><li><p>虚拟槽分区：</p><p>虚拟结点的概念：每个实际结点包含一定数量的槽，每个槽包含一定数量范围的哈希值得槽</p></li></ol></li></ol><h2 id="为什么是16384个槽"><a href="#为什么是16384个槽" class="headerlink" title="为什么是16384个槽"></a>为什么是16384个槽</h2><p>16384是一个固定得槽位，源自hash槽分片算法</p><h2 id="redis集群得原理"><a href="#redis集群得原理" class="headerlink" title="redis集群得原理"></a>redis集群得原理</h2><ol><li><p>设置结点：redis集群至少要6个结点才能保证组成高可用得集群，每个结点都要开启cluster-enabled-yes。才能让redis在集群模式下工作</p></li><li><p>结点握手：meet，结点握手是指运行在集群模式下得结点通过gossip协议进行通信，科幻端发起</p><p>meet-ip-port完成结点握手之后就组成了多节点得集群</p></li><li><p>分配槽</p></li></ol><p>​     redis集群把所有数据都映射到16384个槽位当中，每个结点对应若干个槽，只有当结点分配了槽位，才能响应和槽关联得命令。通过cluster-add-slots</p><ol><li>故障转移</li></ol><p>​      和哨兵得故障转移类似</p><ol><li><p>集群内结点通过ping&#x2F;pong时间结点间得通信，定期发送ping，pong作为恢复。</p><p>cluster-time-out没有收到恢复,就会认为他主管下线，然后该结点就会通过Gossip消息传播</p><p>半数持有槽的结点认为该结点主管下线之后，就会触主管下线</p></li></ol><p>​      </p><p>​      </p><p>​      </p><p>​      </p><p>​      </p><p>​<br>​      </p><p>​      </p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>苍穹外卖日记</title>
      <link href="/2023/10/25/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E6%97%A5%E8%AE%B0/"/>
      <url>/2023/10/25/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E6%97%A5%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>#项目介绍</p><h3 id="业务模块"><a href="#业务模块" class="headerlink" title="业务模块"></a>业务模块</h3><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310252100364.png" alt="image-20231025210006261"></p><h3 id="产品原型"><a href="#产品原型" class="headerlink" title="产品原型"></a>产品原型</h3><p>静态的页面</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310252102663.png" alt="image-20231025210252608"></p><h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><p>前端 ： web页面用户端（小程序）</p><p>后端 ： 后端服务（java）</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>springboot</title>
      <link href="/2023/10/24/springboot/"/>
      <url>/2023/10/24/springboot/</url>
      
        <content type="html"><![CDATA[<h1 id="springBoot"><a href="#springBoot" class="headerlink" title="springBoot"></a>springBoot</h1><p>创建项目之后，需要更改setting当中的maven属性</p><p>然后才能正确运行</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310252157940.png" alt="image-20231025215758806"></p><h2 id="Springboot-getterandsetter"><a href="#Springboot-getterandsetter" class="headerlink" title="Springboot getterandsetter"></a>Springboot getterandsetter</h2><p>@data</p><p>包括getter，setter，tostring，hashcode，equals方法等</p><p>dependency:lombook</p><h2 id="基于SpringBoot的SSMP的整合案例"><a href="#基于SpringBoot的SSMP的整合案例" class="headerlink" title="基于SpringBoot的SSMP的整合案例"></a>基于SpringBoot的SSMP的整合案例</h2><p>技术方案：</p><p>Mybatisplus</p><p>Druid</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310252250178.png" alt="image-20231025225019080"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sql窗口函数</title>
      <link href="/2023/10/23/sql%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
      <url>/2023/10/23/sql%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="sql-窗口函数"><a href="#sql-窗口函数" class="headerlink" title="sql 窗口函数"></a>sql 窗口函数</h1><h2 id="窗口函数的分类"><a href="#窗口函数的分类" class="headerlink" title="窗口函数的分类"></a>窗口函数的分类</h2><table><thead><tr><th align="center">函数名</th><th>作用</th></tr></thead><tbody><tr><td align="center">ROW_NUMBER（）</td><td>顺序排序   1，2，3</td></tr><tr><td align="center">RANK( )</td><td>并列排序 ，跳过重复的序列号   1，1，3</td></tr><tr><td align="center">DENSE_RANK()</td><td>并列排序，不会跳过重复的序列号，1，1，2</td></tr><tr><td align="center">PERCENT_RANK()</td><td>等级百分比</td></tr><tr><td align="center">CUME_DIST()</td><td>累计分布值</td></tr><tr><td align="center">LAG(expr,n)</td><td>返回当前行的前n行的exper的值</td></tr><tr><td align="center">LEAD(exper,n)</td><td>返回当前行的后n行的expr的值</td></tr><tr><td align="center">FIRST_VALUE(expr)</td><td>返回第一个expr的值</td></tr><tr><td align="center">LAST_VALUE(expr)</td><td>返回最后一个expr的值</td></tr><tr><td align="center">NTH_VALUE(expr,n)</td><td>返回第n个expr的值</td></tr><tr><td align="center">NTILE(n)</td><td>将分区中的有序数据分为n个桶，记录桶编号</td></tr></tbody></table><h2 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h2><p><code>函数  over （PARTITION BY 字段名（窗口按照什么进行分组，分组后，在各个组中分别执行）ORDER BY 按照什么字段进行排序，使得窗口函数按照排序后的顺序进行编号）</code></p><h3 id="ROW-NUMBER"><a href="#ROW-NUMBER" class="headerlink" title="ROW_NUMBER()"></a>ROW_NUMBER()</h3><p>例子：</p><p>按照category 进行分类，并按照price进行排序，顺序排序，相同的价格编号不同</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310232147411.png" alt="image-20231023214725276"></p><h3 id="RANK"><a href="#RANK" class="headerlink" title="RANK()"></a>RANK()</h3><p>例子： </p><p>按照category 进行分类，并按照price进行排序，并列排序，相同的价格编号相同，然后跳过编号相同的，后面的编号不是连续的</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310232149194.png" alt="image-20231023214958124"></p><h3 id="DENSE-RANK"><a href="#DENSE-RANK" class="headerlink" title="DENSE_RANK()"></a>DENSE_RANK()</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>例子： </p><p>按照category 进行分类，并按照price进行排序，并列排序，相同的价格编号相同，然后跳过编号相同的，后面的编号是连续的</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310232154139.png" alt="image-20231023215438077"></p><h3 id="percent-rank-–-等级百分比"><a href="#percent-rank-–-等级百分比" class="headerlink" title="percent_rank() – 等级百分比"></a>percent_rank() – 等级百分比</h3><p>计算分区或结果集中行的百分位数的排名</p><p><code> percent_rank=(rank-1)/(rows-1)</code></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310232203245.png" alt="image-20231023220304173"></p><h3 id="cume-dist-–累计分布值，小于等于-当前rank值得行数-x2F-分组内得总行数"><a href="#cume-dist-–累计分布值，小于等于-当前rank值得行数-x2F-分组内得总行数" class="headerlink" title="cume_dist –累计分布值，小于等于 当前rank值得行数&#x2F;分组内得总行数"></a>cume_dist –累计分布值，小于等于 当前rank值得行数&#x2F;分组内得总行数</h3><p>例子：</p><p>计算分布区域内小于等于该rank值的数的总行数占窗口内总行数的值</p><p><code>cume_dist= &lt;=rank的行数/总行数</code></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310232206200.png" alt="image-20231023220656134"></p><h3 id="lag"><a href="#lag" class="headerlink" title="lag"></a>lag</h3><p>lag（expr，n）-返回当前行的前n行（本组内）的expr的值</p><p>例子： 按照category进行分组，返回分组当中当前行的前第几行n行</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310232212563.png" alt="image-20231023221211498"></p><h3 id="lead（expr，n）"><a href="#lead（expr，n）" class="headerlink" title="lead（expr，n）"></a>lead（expr，n）</h3><p>LEAD(expr,n) 返回后当前行的后n行（本组）的expr值</p><p>例子，返回当前行后一行的值</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310232217260.png" alt="image-20231023221736203"></p><h3 id="first-value（）-取分组内排序后，截至到当前行，第一个值"><a href="#first-value（）-取分组内排序后，截至到当前行，第一个值" class="headerlink" title="first_value（） 取分组内排序后，截至到当前行，第一个值"></a>first_value（） 取分组内排序后，截至到当前行，第一个值</h3><p>返回当前分组的第一行</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310232219209.png" alt="image-20231023221958145"></p><p>Last_value()  取分组内排序后 截至到当前行的最后一个值</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310232221638.png" alt="image-20231023222148573"></p><h3 id="NTH-VALUE-expr-n-返回第n个expr的值"><a href="#NTH-VALUE-expr-n-返回第n个expr的值" class="headerlink" title="NTH_VALUE(expr,n) 返回第n个expr的值"></a>NTH_VALUE(expr,n) 返回第n个expr的值</h3><p>返回窗口中的第n个值</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310241818891.png" alt="image-20231024181808829"></p><h3 id="NTILE的用法"><a href="#NTILE的用法" class="headerlink" title="NTILE的用法"></a>NTILE的用法</h3><p>将一个组分为多少个桶。</p><p><code>NTILE(N) OVER (PARTITION BY column1, column2,... ORDER BY expression [ASC|DESC])</code></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310241822171.png" alt="image-20231024182231104"></p><h2 id="窗口函数语法"><a href="#窗口函数语法" class="headerlink" title="窗口函数语法"></a>窗口函数语法</h2><p><code>&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt;                  order by &lt;用于排序的列名&gt;                  frame_clause &lt;窗口大小&gt;)</code></p><h3 id="指定窗口大小"><a href="#指定窗口大小" class="headerlink" title="指定窗口大小"></a>指定窗口大小</h3><p><code>当ORDER BY后面缺少窗口从句条件，窗口大小默认是 RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW. （分组中的第一行，当前行的所有对等行）</code></p><ul><li><strong>current row</strong>：对于 rows 方式，代表了当前行；对于 range ，代表了当前行的所有对等行。</li><li><strong>unbounded preceding</strong>：代表了分组中的第一行。</li><li><strong>unbounded following</strong>：代表了分组中的最后一行。</li><li><strong>n preceding</strong>：对于 rows 方式，代表了当前行之前的第 n 行；对于 range ，代表了等于当前行的值减去 n 的所有行；如果当前行的值为 NULL，代表了当前行的所有对等行。</li><li><strong>n following</strong>：对于 rows 方式，代表了当前行之后的第 n 行；对于 range ，代表了等于当前行的值加上 n 的所有行；如果当前行的值为 NULL，代表了当前行的所有对等行。</li></ul><p>此外：聚合函数也可以当作窗口函数进行使用</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/04/%E7%AE%97%E6%B3%95/"/>
      <url>/2023/10/04/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树的层序遍历</p><p>依赖于队列进行实现</p><p>依赖队列实现</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202311151642068.png" alt="image-20231115164159970"></p><p>以此类推，多子树的层序遍历等都是可以用队列实现</p><h6 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h6><p>定义：平衡二叉树左右两个结点的子树的高度差的绝对值不超过1</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2023/10/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/10/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>分类：</p><ul><li>线性结构： 一对一（顺序存储结构，链式存储结构）<ul><li>数组</li><li>队列</li><li>链表</li><li>栈</li></ul></li><li>非线性结构：一对多，或者多对多<ul><li>二维数组</li><li>多为数组</li><li>广义表</li><li>树</li><li>图</li></ul></li></ul><h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><p>什么时候用：当一个数组中大部分元素是0，或者为同一个值得数组时，可以用稀疏数组来保存该数组。—&gt;原始的二维数组有很多没有意义的数据</p><p>处理方式：</p><ul><li>记录数组一共有几行几列，有多少个不同得值</li><li>把具有不同得值的元素行列记录在一个小规模数组中，从而缩小程序的规模</li></ul><p>例子：</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310031523268.png" alt="image-20231003152345161"></p><p>如果按照原来的方式存储就需要42个存储空间，现在需要27个存储空间</p><p>稀疏数组的应用实例：棋盘</p><p>二维数组转稀疏数组的思路</p><ul><li>遍历原始的二维数组，得到有效数组的个数</li><li>根据sum，可以创建稀疏数组 spareArr int【sum+1][3]的值</li></ul><p>稀疏数组转二维数组的思路</p><ul><li>先读取第一行，根据第一行的数据创建原始的二维数组</li><li>读取稀疏数组的后几行数据，并且赋值给原始的二维数组即可</li></ul><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>数据结构特点：先进先出，可以由数组或者链表数实现</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310031855492.png" alt="image-20231003185524436"></p><p>队列的实现方式：</p><p>队列本身是有序列表，若使用数组的结构来存储队列的数据，数组的声明如下</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310031901023.png" alt="image-20231003190122987"></p><p>实现方式</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310031919429.png" alt="image-20231003191956391"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310031924861.png" alt="image-20231003192455825"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310031925929.png" alt="image-20231003192531889"></p><p>当rear&#x3D;&#x3D;&#x3D;front就是空</p><p>rear&#x3D;&#x3D;front就是空 </p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310031928593.png" alt="："></p><h3 id="java源代码-ArrayDeque"><a href="#java源代码-ArrayDeque" class="headerlink" title="java源代码 ArrayDeque"></a>java源代码 ArrayDeque</h3><p>队列的实现原理</p><h3 id="首先创建一个队列的对象"><a href="#首先创建一个队列的对象" class="headerlink" title="首先创建一个队列的对象"></a>首先创建一个队列的对象</h3><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310032033969.png" alt="image-20231003203333938"></p><h4 id="它的构造函数是："><a href="#它的构造函数是：" class="headerlink" title="它的构造函数是："></a>它的构造函数是：</h4><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310032034710.png" alt="image-20231003203443670"></p><p>numElements的默认值是17。也可以加入其他的值</p><h4 id="增："><a href="#增：" class="headerlink" title="增："></a>增：</h4><p>增加队列的头部元素：</p><p>首先判断传入元素是否为空：如果为空，就抛出异常。</p><p>否则就在数组的头部插入元素</p><p>在头部插入的时候要检查是否超过下限，如果超过就放在数组的尾部（循环队列）</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310032038751.png" alt="image-20231003203831714"></p><p>增加尾部元素</p><p>也是先判断元素是否为空，如果为空就抛出异常</p><p>然后，在数组的末尾插入元素，</p><p>然后判数组是否已满，如果满了就需要扩容</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310032200778.png" alt="image-20231003220045737"></p><p>普通增加：</p><p>调用addLast函数</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310032204451.png" alt="image-20231003220431420"></p><p>判断是否增加成功：</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310032205153.png" alt="image-20231003220506113"></p><p>将集合的元素全部插入到队列当中：</p><p>首先判断是否需要进行扩容，扩容之后再将集合当中的每个元素加入到数组当中</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202310032206140.png" alt="image-20231003220630096"></p><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><table><thead><tr><th>函数</th><th>逻辑</th></tr></thead><tbody><tr><td>pollFisrt</td><td>删除头部元素</td></tr><tr><td>pollLast</td><td>删除尾部元素</td></tr><tr><td>poll</td><td>调用pollFirst</td></tr><tr><td>removeFirst</td><td>调用pollFirst，然后判断获取到的元素是否为空，如果为空，抛出已成，否则返回元素</td></tr><tr><td>removeLast</td><td>调用pollLast,然后判断获取到的元素是否为空，如果为空，抛出已成，否则返回元素</td></tr><tr><td>remove</td><td>调用removeFirst</td></tr><tr><td>pop</td><td>调用removeFirst</td></tr><tr><td>delete</td><td>通过移动数组进行覆盖操作，实现删除元素操作</td></tr><tr><td>removeFirstOccrence</td><td>遍历数组，找到元素第一次出现的位置，然后调用delete函数，删除该元素</td></tr><tr><td>removeLastOccrence</td><td>遍历数组，找到元素最后一次出现的位置，然后调用delete函数，删除元素</td></tr></tbody></table><p>删除头部元素：</p><p>首先获取头部元素，然后把头部元素的位置设为空，</p><p>头部元素位置 head++（下一个元素）</p><p>最后返回头部元素</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">pollFirst</span><span class="params">()</span> &#123;</span><br><span class="line">       Object[] es;</span><br><span class="line">       <span class="type">int</span> h;</span><br><span class="line">       <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> elementAt(es = <span class="built_in">this</span>.elements, h = <span class="built_in">this</span>.head);</span><br><span class="line">       <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">           es[h] = <span class="literal">null</span>;</span><br><span class="line">           <span class="built_in">this</span>.head = inc(h, es.length);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> e;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>删除尾部元素：</p><p>首先获取尾部元素。和尾部元素的位置</p><p>然后判断是否获取到了尾部元素</p><p>，将尾部元素的位置设置为空，返回尾部元素，此时tail指向的位置已经是下一个尾部元素的位置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">pollLast</span><span class="params">()</span> &#123;</span><br><span class="line">        Object[] es;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> elementAt(es = <span class="built_in">this</span>.elements, t = dec(<span class="built_in">this</span>.tail, es.length));</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">            es[<span class="built_in">this</span>.tail = t] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>删除： </p><p>removeFirst  判断获取到的队头元素是否为空，如果为空抛出异常</p><p>否则返回对头元素</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public E removeFirst() &#123;</span><br><span class="line">    E e = this.pollFirst();</span><br><span class="line">    if (e == null) &#123;</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除队尾元素：</p><p>判断删除的元素是否为空，如果为空，抛出异常</p><p>否则返回队尾元素</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public E removeLast() &#123;</span><br><span class="line">        E e = this.pollLast();</span><br><span class="line">        if (e == null) &#123;</span><br><span class="line">            throw new NoSuchElementException();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>delete函数：</p><p>front:队列的头</p><p>back：队列的尾</p><p>h：head的值</p><p>t：尾部的值</p><p>判断队列的头是否小于尾部，如果小于则证明，被删除元素位于front和back之间</p><p>然后判断head和i的关系，如果i&gt;head,就将h到i的元素进行右移</p><p>如果h&gt;i:</p><p>在这种情况下，根据i和tail的大小关系进行元素的挪移。如果i小于等于tail，则使用System.arraycopy将元素从i+1开始到tail的位置向左移动一位，覆盖掉i的位置。否则，将元素从i+1开始到capacity-1的位置向左移动一位，然后将第一个元素移动到数组的最后一个位置，再将元素从1开始到t-1的位置向左移动一位。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">       Object[] es = <span class="built_in">this</span>.elements;</span><br><span class="line">       <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> es.length;</span><br><span class="line">       <span class="type">int</span> h;</span><br><span class="line">       <span class="type">int</span> <span class="variable">front</span> <span class="operator">=</span> sub(i, h = <span class="built_in">this</span>.head, capacity);</span><br><span class="line">       <span class="type">int</span> t;</span><br><span class="line">       <span class="type">int</span> <span class="variable">back</span> <span class="operator">=</span> sub(t = <span class="built_in">this</span>.tail, i, capacity) - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (front &lt; back) &#123;</span><br><span class="line">           <span class="keyword">if</span> (h &lt;= i) &#123;</span><br><span class="line">               System.arraycopy(es, h, es, h + <span class="number">1</span>, front);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               System.arraycopy(es, <span class="number">0</span>, es, <span class="number">1</span>, i);</span><br><span class="line">               es[<span class="number">0</span>] = es[capacity - <span class="number">1</span>];</span><br><span class="line">               System.arraycopy(es, h, es, h + <span class="number">1</span>, front - (i + <span class="number">1</span>));</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           es[h] = <span class="literal">null</span>;</span><br><span class="line">           <span class="built_in">this</span>.head = inc(h, capacity);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.tail = dec(t, capacity);</span><br><span class="line">           <span class="keyword">if</span> (i &lt;= <span class="built_in">this</span>.tail) &#123;</span><br><span class="line">               System.arraycopy(es, i + <span class="number">1</span>, es, i, back);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               System.arraycopy(es, i + <span class="number">1</span>, es, i, capacity - (i + <span class="number">1</span>));</span><br><span class="line">               es[capacity - <span class="number">1</span>] = es[<span class="number">0</span>];</span><br><span class="line">               System.arraycopy(es, <span class="number">1</span>, es, <span class="number">0</span>, t - <span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           es[<span class="built_in">this</span>.tail] = <span class="literal">null</span>;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>removeLastOccurence函数</p><p>找到第一次出现的对象o，然后删除o</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeFirstOccurrence</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o != <span class="literal">null</span>) &#123;</span><br><span class="line">            Object[] es = <span class="built_in">this</span>.elements;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.head;</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="built_in">this</span>.tail;</span><br><span class="line">            <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> i &lt;= end ? end : es.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(i &gt;= to) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (to == end) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    i = <span class="number">0</span>;</span><br><span class="line">                    to = end;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (o.equals(es[i])) &#123;</span><br><span class="line">                    <span class="built_in">this</span>.delete(i);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>removeLastOccurence</p><p>遍历数组，找到元素最后一次出现的位置，删除元素</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean removeLastOccurrence(Object o) &#123;</span><br><span class="line">        if (o != null) &#123;</span><br><span class="line">            Object[] es = this.elements;</span><br><span class="line">            int i = this.tail;</span><br><span class="line">            int end = this.head;</span><br><span class="line">            int to = i &gt;= end ? end : 0;</span><br><span class="line"></span><br><span class="line">            while(true) &#123;</span><br><span class="line">                --i;</span><br><span class="line"></span><br><span class="line">                while(i &gt; to - 1) &#123;</span><br><span class="line">                    if (o.equals(es[i])) &#123;</span><br><span class="line">                        this.delete(i);</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    --i;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (to == end) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                i = es.length;</span><br><span class="line">                to = end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>circularclear：</p><p>删除i到end的元素，挨个遍历，设置为空</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static void circularClear(Object[] es, int i, int end) &#123;</span><br><span class="line">    int to = i &lt;= end ? end : es.length;</span><br><span class="line"></span><br><span class="line">    while(true) &#123;</span><br><span class="line">        while(i &gt;= to) &#123;</span><br><span class="line">            if (to == end) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i = 0;</span><br><span class="line">            to = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        es[i] = null;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clear：</p><p>调用circularclear函数，删除从头到尾的所有数组</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void clear() &#123;</span><br><span class="line">    circularClear(this.elements, this.head, this.tail);</span><br><span class="line">    this.head = this.tail = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>contains函数</p><p>从head到tail遍历所有函数，看是否存在元素o如果存在直接返回true</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean contains(Object o) &#123;</span><br><span class="line">    if (o != null) &#123;</span><br><span class="line">        Object[] es = this.elements;</span><br><span class="line">        int i = this.head;</span><br><span class="line">        int end = this.tail;</span><br><span class="line">        int to = i &lt;= end ? end : es.length;</span><br><span class="line"></span><br><span class="line">        while(true) &#123;</span><br><span class="line">            while(i &gt;= to) &#123;</span><br><span class="line">                if (to == end) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                i = 0;</span><br><span class="line">                to = end;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (o.equals(es[i])) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>elementAt：</p><p>返回在位置i处的元素</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final &lt;E&gt; E elementAt(Object[] es, int i) &#123;</span><br><span class="line">    return es[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getFirst</p><p>获得队列的第一个元素</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public E getFirst() &#123;</span><br><span class="line">    E e = elementAt(this.elements, this.head);</span><br><span class="line">    if (e == null) &#123;</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getLast</p><p>获取队列的最后一个元素</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public E getLast() &#123;</span><br><span class="line">    Object[] es = this.elements;</span><br><span class="line">    E e = elementAt(es, dec(this.tail, es.length));</span><br><span class="line">    if (e == null) &#123;</span><br><span class="line">        throw new NoSuchElementException();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>peekFirst</p><p>获取队列的第一个元素</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public E peekFirst() &#123;</span><br><span class="line">    return elementAt(this.elements, this.head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pop:</p><p>获取队列的最后一个元素，并且删除该元素</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public E pop() &#123;</span><br><span class="line">    return this.removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他：</p><p>size：</p><p>获取队列对的长度</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    return sub(this.tail, this.head, this.elements.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用sub函数实现。</p><p>isempty：</p><p>判断列表是否为空，如果tail等于head就是空，否则不是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">    return this.head == this.tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>toArray：</p><p>转化为数组</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object[] toArray() &#123;</span><br><span class="line">    return this.toArray(Object[].class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private &lt;T&gt; T[] toArray(Class&lt;T[]&gt; klazz) &#123;</span><br><span class="line">    Object[] es = this.elements;</span><br><span class="line">    int head = this.head;</span><br><span class="line">    int tail = this.tail;</span><br><span class="line">    int var10001 = head &lt;= tail ? 0 : es.length;</span><br><span class="line">    int var10000 = tail + (head &lt;= tail ? 0 : es.length);</span><br><span class="line">    int end = tail + var10001;</span><br><span class="line">    Object[] a;</span><br><span class="line">    if (var10000 &gt;= 0) &#123;</span><br><span class="line">        a = Arrays.copyOfRange(es, head, end, klazz);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        a = Arrays.copyOfRange(es, 0, end - head, klazz);</span><br><span class="line">        System.arraycopy(es, head, a, 0, es.length - head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (end != tail) &#123;</span><br><span class="line">        System.arraycopy(es, 0, a, es.length - head, tail);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue-1</title>
      <link href="/2023/09/25/vue-1/"/>
      <url>/2023/09/25/vue-1/</url>
      
        <content type="html"><![CDATA[<script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前后端分离项目步骤</title>
      <link href="/2023/09/25/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/"/>
      <url>/2023/09/25/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="前后端项目创建步骤"><a href="#前后端项目创建步骤" class="headerlink" title="前后端项目创建步骤"></a>前后端项目创建步骤</h1><p>如果没有安装vue的需要执行以下步骤</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install  -g @vue/cli</span><br><span class="line">vue -V</span><br><span class="line">如果第二条命令有vue版本出现，则证明安装成功</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后开始创建项目。我们先从前端开始</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue create vue</span><br></pre></td></tr></table></figure><p>然后进入到选择界面，然后选择 <strong>Manually select features</strong></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309252135463.png" alt="image-20230925213507406"></p><p>选择Babel，Router之后点击确定</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309252142881.png" alt="image-20230925214247853"></p><p>选择 2.x</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309252157255.png" alt="image-20230925215741221"></p><p>然后选择 yes</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309252158338.png" alt="image-20230925215841302"></p><p>选择yes，然后命名</p><p>最后创建成功，然后开始漫长的等待</p><p>最后创建成功，然后</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd vue </span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><p>开始运行</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前后端分离项目步骤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流水线</title>
      <link href="/2023/09/25/%E6%B5%81%E6%B0%B4%E7%BA%BF/"/>
      <url>/2023/09/25/%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h1><h2 id="静态多发射处理器"><a href="#静态多发射处理器" class="headerlink" title="静态多发射处理器"></a>静态多发射处理器</h2><p>编译器在编译时，进行相关性分析，和静态分支预测，以静态完成指令打包</p><h6 id="如何理解静态："><a href="#如何理解静态：" class="headerlink" title="如何理解静态："></a>如何理解静态：</h6><ul><li>“静态”一词表示指令的并行执行是在编译阶段或指令发射之前就确定好的</li><li>编译时决策：在静态多发射处理器中，指令的并行执行是在编译阶段进行决策的。编译器会对程序进行静态分析，确定哪些指令可以并行执行，并将其组织成指令组（instruction bundle）。这些指令组在运行时被一次性发射到处理器中执行。</li><li>固定的并行度：静态多发射处理器通常有一个固定的并行度，即每个时钟周期内可以同时执行的指令数量。这个并行度在处理器设计时就被确定下来，并且在运行时是不可改变的。例如，一个四发射处理器每个周期可以同时执行四条指令。</li><li>静态调度：静态多发射处理器使用静态调度来确定指令的执行顺序。在编译阶段，编译器会根据数据依赖关系和控制流信息，对指令进行调度和排序，以最大限度地提高指令级并行性。这个静态调度的结果会被写入指令流（instruction stream）中，然后在运行时按照指令流的顺序执行。 总的来说，静态多发射处理器在编译阶段就确定了指令的并行执行方式和顺序，并且在运行时按照这个确定的方案执行指令。这种静态的设计可以在一定程度上简化处理器的控制逻辑，并提高处理器的性能。但同时也带来了一些挑战，如依赖关系的解决和冲突检测等。</li></ul><h6 id="N发射静态流水线特点"><a href="#N发射静态流水线特点" class="headerlink" title="N发射静态流水线特点"></a>N发射静态流水线特点</h6><ul><li><p>潜在性能提高N倍</p></li><li><p>硬件堆料</p></li><li><p>数据和控制相关带来更大的损失</p></li><li><p>需要极为强大+智能的编译器，尽可能采用VLIW编排指令</p></li></ul><h2 id="多发射动态流水线"><a href="#多发射动态流水线" class="headerlink" title="多发射动态流水线"></a>多发射动态流水线</h2><p><strong>实现</strong></p><ul><li><p>动态调度</p><p> <strong>CPU****在运行时重新安排指令的执行顺序，减少流水线</strong></p><p><strong>空转。</strong></p><p><strong>•</strong> <strong>能调度编译时不知道的竞争情况</strong></p><p><strong>•</strong> <strong>符号程序执行的实际情况</strong></p><p><strong>•</strong> <strong>具有更高的效率和准确性</strong></p><p><strong>•</strong> <strong>简化编译器设计</strong></p><p><strong>•</strong> <strong>代码移植性强</strong></p></li><li><p><strong>并行多线程或</strong>“<strong><strong>超线程</strong></strong>”</p></li></ul><h5 id="并行增加CPU数量"><a href="#并行增加CPU数量" class="headerlink" title="并行增加CPU数量"></a>并行增加CPU数量</h5><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251656457.png" alt="image-20230925165602285"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251656898.png" alt="image-20230925165613860"></p><h5 id="如何让流水线更快-–-解决方案"><a href="#如何让流水线更快-–-解决方案" class="headerlink" title="如何让流水线更快 – 解决方案"></a>如何让流水线更快 – 解决方案</h5><p> 动态多发射流水线 – 由硬件动态调度指令顺序发射给不同的流水线</p><ul><li><p>顺序多发射流水线</p><p> 限制：</p><p>​     数据依赖</p><p>​      冲突和检测</p><p>​    </p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251704760.png" alt="image-20230925170452698"></p><p><strong>解决方案：顺序发生，乱序执行，乱序完成</strong></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251708470.png" alt="image-20230925170850425"></p></li></ul><p>​    记分牌控制的四个阶段</p><p>  原：取指 -&gt;译码-&gt;执行-&gt;写回</p><p> now：<a href="https://blog.csdn.net/weixin_40064300/article/details/124443945?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169564113016800227411306%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169564113016800227411306&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-124443945-null-null.142%5Ev94%5Einsert_down28v1&utm_term=%E8%AE%B0%E5%88%86%E7%89%8C&spm=1018.2226.3001.4187">讲解</a></p><p><strong>•</strong> <strong>1.Issue—****指令译码，检测</strong>结构相关****</p><p>• 如果当前指令所使用的功能部件空闲，并且没有其他活动的指令</p><p>使用相同的目的寄存器（避免WAW), 记分牌发射该指令到功能部</p><p>件，并更新记分牌内部数据；<strong>如果有结构相关或<strong><strong>WAW</strong></strong>相关，则该</strong></p><p><strong>指令的发射暂停</strong>，并且也不发射后继指令，直到相关解除. </p><p><strong>•</strong> <strong>2. Read operands—****没有</strong>数据相关<strong>时，读操作数</strong></p><p>• 如果先前已发射的正在运行的指令不对当前指令的源操作数寄存</p><p>器进行写操作，或者一个正在工作的功能部件已经完成了对该寄</p><p>存器的写操作，则该操作数有效。操作数有效时，记分牌控制功</p><p>能部件读操作数，准备执行。</p><p>• 记分牌在这一步动态地解决了RAW相关，指令可能会乱序执行</p><p><strong>•</strong> <strong>3.Execution—****取到操作数后执行</strong> <strong>(EX)</strong> </p><p>• 接收到操作数后，功能部件开始执行. 当计算出结果后，它通知</p><p>记分牌，可以结束该条指令的执行. </p><p><strong>•</strong> <strong>4.Write result—finish execution (WB)</strong> </p><p>• 一旦记分牌得到功能部件执行完毕的信息后，记分牌检测WAR</p><p>相关，如果没有WAR相关，就写结果，如果有WAR 相关，则暂停</p><p>该条指令。</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251914498.png" alt="image-20230925191434424"></p><h5 id="exam"><a href="#exam" class="headerlink" title="exam:"></a>exam:</h5><p>指令状态表</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251930639.png" alt="image-20230925193044610"></p><p>功能部件状态表：</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251931161.png" alt="image-20230925193144130"></p><p>结果寄存器状态表：</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251932645.png" alt="image-20230925193216594"></p><p>begin：</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251935781.png" alt="image-20230925193518718"></p><p>首先由两个Load指令，只有一个可以执行功能部件能够执行Load操作，所以智能流入1，然后是，一次执行</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251939922.png" alt="image-20230925193907853"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251943377.png" alt="image-20230925194322307"></p><p>调度算法二：</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251943206.png" alt="image-20230925194350140"></p><h5 id="动态调度方法二：Tomasulo-Algorithm"><a href="#动态调度方法二：Tomasulo-Algorithm" class="headerlink" title="动态调度方法二：Tomasulo Algorithm"></a>动态调度方法二：Tomasulo Algorithm</h5><p>所用到的技术：数据重定向技术</p><h6 id="数据重定向技术：用于解决数据相关性导致的流水线停顿问题。当一个指令需要等待另一个指令的结果时，流水线会出现停顿，导致性能下降。数据重定向技术通过在流水线中插入一些逻辑电路，使得指令在等待其他指令结果时可以继续执行，从而提高流水线的利用率。"><a href="#数据重定向技术：用于解决数据相关性导致的流水线停顿问题。当一个指令需要等待另一个指令的结果时，流水线会出现停顿，导致性能下降。数据重定向技术通过在流水线中插入一些逻辑电路，使得指令在等待其他指令结果时可以继续执行，从而提高流水线的利用率。" class="headerlink" title="数据重定向技术：用于解决数据相关性导致的流水线停顿问题。当一个指令需要等待另一个指令的结果时，流水线会出现停顿，导致性能下降。数据重定向技术通过在流水线中插入一些逻辑电路，使得指令在等待其他指令结果时可以继续执行，从而提高流水线的利用率。"></a>数据重定向技术：用于解决数据相关性导致的流水线停顿问题。当一个指令需要等待另一个指令的结果时，流水线会出现停顿，导致性能下降。数据重定向技术通过在流水线中插入一些逻辑电路，使得指令在等待其他指令结果时可以继续执行，从而提高流水线的利用率。</h6><p>简单说就是简化读写操作：</p><p>比如说 write B A</p><p>​write B C</p><p>​           直接简化为： write C A</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251951341.png" alt="image-20230925195150289"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309251953634.png" alt="image-20230925195350585"></p><p>例子：</p><ul><li></li></ul><ul><li><ul><li>乱序多发射流水线</li></ul></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 大三课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据和信号</title>
      <link href="/2023/09/24/%E6%95%B0%E6%8D%AE%E5%92%8C%E4%BF%A1%E5%8F%B7/"/>
      <url>/2023/09/24/%E6%95%B0%E6%8D%AE%E5%92%8C%E4%BF%A1%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章—数据和信号"><a href="#第三章—数据和信号" class="headerlink" title="第三章—数据和信号"></a>第三章—数据和信号</h1><p>数据无法直接传输所以需要编程信号</p><p>信息（message）：文字，音频，视频等</p><p>数据（data）：再传输之前进行编码，编码之后编程数据</p><p>信号（signal）：数据再通信线路上传递需要变成电信号（双脚线，同轴电缆），光信号（光纤），</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242002720.png" alt="image-20230924200241668"></p><p>数据分类</p><ul><li>模拟数据：连续状态的信息</li><li>数字数据：离散状态的数据</li></ul><p>信号</p><ul><li><p>模拟信号：</p><p>优点：其精确的分辨率，与数字信号相比，模拟信号的信息密度更高。处理更简单，可以直接通过模拟电路组件实现。 缺点：易受干扰，很难纠正。</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242006441.png" alt="image-20230924200613409"></p><p>​                        模拟信号数字信号</p></li><li><p>数字信号</p><p>更高的抗干扰能力，更远的传输距离，且失真幅度小。便于加密处理、存储、处理和交换，设备便于集成化、微型，占用信道频带较宽。 缺点：算法复杂。</p></li></ul><p>数据通信中常用周期模拟信号（带宽小），和非周期数字信号。</p><h2 id="周期性的模拟信号"><a href="#周期性的模拟信号" class="headerlink" title="周期性的模拟信号"></a>周期性的模拟信号</h2><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242026709.png" alt="image-20230924202647663"></p><p>概念：</p><ul><li><p>振幅</p></li><li><p>频率</p></li><li><p>相位</p></li><li><p>波长</p></li><li><p>时域和频域</p><p>时域：时域是指信号在时间轴上的变化情况。在时域中，信号的数值随着时间的变化而变化。可以通过绘制信号的波形图来表示时域特性。时域分析主要关注信号在时间上的幅度、相位、频率等变化。</p><p>频域：指信号在频率轴上的变化情况。在频域中，信号的数值随着频率的变化而变化。频域分析可以将信号转换成频谱图，表示信号在不同频率上的强度。频域分析主要关注信号的频率成分、频率特性等。</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242029470.png" alt="image-20230924202913441"></p></li></ul><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242034064.png" alt="image-20230924203435036"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242034984.png" alt="image-20230924203456954"></p><h2 id="复合信号"><a href="#复合信号" class="headerlink" title="复合信号"></a>复合信号</h2><p>单一频率的正弦波在数据通信中没有用处，需要发送复合信号，复合信号由许多简单正弦波组成。 按照傅里叶分析，任何复合信号是由具有不同频率、相位和振幅的简单正弦波组合而成（附录C）。 如果复合信号是周期性的，分解得到的是一系列具有离散频率的信号。 如果复合信号是非周期性的，分解得到的是具有连续频率的正弦波组合。</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242037466.png" alt="image-20230924203714428"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242039641.png" alt="image-20230924203911611"></p><p><u>带宽&#x3D;最高频率-最低频率</u></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242041285.png" alt="image-20230924204135249"></p><p>带宽&#x3D;5000-1000</p><h2 id="数字信号"><a href="#数字信号" class="headerlink" title="数字信号"></a>数字信号</h2><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242042772.png" alt="image-20230924204225742"></p><p>比如</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242042175.png" alt="image-20230924204247149"></p><p>一个电平表示的比特位数</p><h6 id="n-x3D-log2L"><a href="#n-x3D-log2L" class="headerlink" title="n&#x3D;log2L"></a>n&#x3D;log2L</h6><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242048497.png" alt="image-20230924204834468"></p><p>L时电平数量</p><h4 id="比特率：位数-x2F-每秒"><a href="#比特率：位数-x2F-每秒" class="headerlink" title="比特率：位数&#x2F;每秒"></a>比特率：位数&#x2F;每秒</h4><p>假定我们需要每分钟 100页的速率下载文本文档。假设一页平均 24行，每一行 80个字符，每个字符需要 8位表示，则所需的通道比特率是多少？ 解: 根据题意，比特率为：</p><p>​比特率&#x3D;100 * 24 * 80 *8 &#x2F;60 &#x3D;25.6kbps（千比特&#x2F;秒）</p><h4 id="比特长度-x3D-传播长度-比特持续时间"><a href="#比特长度-x3D-传播长度-比特持续时间" class="headerlink" title="比特长度&#x3D;传播长度 * 比特持续时间"></a>比特长度&#x3D;传播长度 * 比特持续时间</h4><p>（一个比特再传输介质上的距离）</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242056927.png" alt="image-20230924205604887"></p><p>结论:<strong>数字信号的带宽时无穷的</strong></p><p>数字信号时一种复合的模拟信号（带宽无穷大的复合模拟信号）</p><h4 id="数字信号传输"><a href="#数字信号传输" class="headerlink" title="数字信号传输"></a>数字信号传输</h4><h5 id="基带传输"><a href="#基带传输" class="headerlink" title="基带传输"></a>基带传输</h5><p>通过通道传输数字信号，不转化为模拟信号，基带传输时一个带宽下限为0的低通通道</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242100728.png" alt="image-20230924210055697"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242101142.png" alt="image-20230924210150107"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242102362.png" alt="image-20230924210216324"></p><p><strong>结论：只有存在无穷大或者非常大带宽的低通通道，保持数字信号形状的数字信号基带传输才是有可能的</strong></p><p><strong>exam</strong>：计算带宽</p><p>比特率为：n</p><p>如果只有0，1</p><p>T&#x3D;2*1&#x2F;n</p><p>f&#x3D;1&#x2F;T&#x3D;n&#x2F;2</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242110215.png" alt="image-20230924211017172"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242111919.png" alt="image-20230924211102893"></p><p><strong>结论：基带传输当中，所需带宽与所需比特率成正比</strong></p><p>exam：</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242120740.png" alt="image-20230924212022711"></p><h4 id="带同通道"><a href="#带同通道" class="headerlink" title="带同通道"></a>带同通道</h4><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242122425.png" alt="image-20230924212241399"></p><p><strong>结论：如果可用通道是带通通道，不能直接发送数字信号到通道；需要在传输前把数字信号转换成模拟信号</strong></p><p>数字信号—&gt;模拟信号</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242123234.png" alt="image-20230924212347199"></p><h4 id="传输减损"><a href="#传输减损" class="headerlink" title="传输减损"></a>传输减损</h4><p>信号通过介质进行传输，但是其传输并非是完美无缺的。不完美的地方导致了信号减损。这意味着信号在介质的开始一端和结束一端是不相同的。发送的信号并非就是接收到的信号。通常会发生三种类型的减损：衰减、失真和噪声。</p><h5 id="衰减：幅度变化"><a href="#衰减：幅度变化" class="headerlink" title="衰减：幅度变化"></a>衰减：幅度变化</h5><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242127502.png" alt="image-20230924212700463"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242127953.png" alt="image-20230924212718915"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242128273.png" alt="image-20230924212855234"></p><h5 id="失真：波形变化"><a href="#失真：波形变化" class="headerlink" title="失真：波形变化"></a>失真：波形变化</h5><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242129268.png" alt="image-20230924212930231"></p><h5 id="噪声："><a href="#噪声：" class="headerlink" title="噪声："></a>噪声：</h5><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242134719.png" alt="image-20230924213429663"></h5><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242135809.png" alt="image-20230924213522756"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242135784.png" alt="image-20230924213546731"></p><h4 id="数据速率"><a href="#数据速率" class="headerlink" title="数据速率"></a>数据速率</h4><p>数据通信中一个非常重要的问题是：在一个通道中能够以多快的速率发送数据，即每秒钟的比特数。数据速率取决于三种因素：   1. 有效带宽   2. 使用的信号电平数   3. 通道的质量（噪声电平）</p><h5 id="无噪声通道-奈奎斯特比特率"><a href="#无噪声通道-奈奎斯特比特率" class="headerlink" title="无噪声通道: 奈奎斯特比特率"></a>无噪声通道: 奈奎斯特比特率</h5><h3 id="理论上的最大比特率-x3D-2-×-带宽-×-log2-L，-L是电平数"><a href="#理论上的最大比特率-x3D-2-×-带宽-×-log2-L，-L是电平数" class="headerlink" title="理论上的最大比特率 &#x3D; 2 × 带宽 ×  log2 L，  L是电平数"></a>理论上的最大比特率 &#x3D; 2 × 带宽 ×  log2 L，  L是电平数</h3><h5 id="噪声通道-香农容量定理"><a href="#噪声通道-香农容量定理" class="headerlink" title="噪声通道: 香农容量定理"></a>噪声通道: 香农容量定理</h5><h4 id="通道容量-x3D-带宽-×-log2-1-SNR-（SNR-信噪比）"><a href="#通道容量-x3D-带宽-×-log2-1-SNR-（SNR-信噪比）" class="headerlink" title="通道容量 &#x3D; 带宽 × log2(1+SNR)（SNR:信噪比）"></a>通道容量 &#x3D; 带宽 × log2(1+SNR)（SNR:信噪比）</h4><p><strong>香农公式中没有指出信号电平，意味着无论使用多少个电平，都不可能获得比通道容量更高的数据速率，即香农公式定义了噪声通道理论上的最高数据速率。</strong></p><h5 id="衡量网络性能"><a href="#衡量网络性能" class="headerlink" title="衡量网络性能"></a>衡量网络性能</h5><ul><li>带宽：以赫兹 为单位的带宽（物理层），以比特率衡量（网络中通常之这种）</li><li>吞吐量：单位时间成功传输数据的数量，</li></ul><p>​<img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242341279.png" alt="image-20230924234149233"></p><ul><li><p>延迟：</p><ul><li><strong>传播时间:指一个比特从源到目标的时间，取决于电磁信号的传播距离&#x3D;距离&#x2F;传播速度</strong></li><li><strong>传输时间&#x3D;报文长度&#x2F;传输速度</strong></li><li>排队时间</li><li>处理延迟</li></ul><p> 延迟&#x3D;传播延迟+传输延迟+排队时间+处理延迟</p></li></ul><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309242354546.png" alt="image-20230924235443507"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 大三上 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java语法</title>
      <link href="/2023/09/24/java%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/09/24/java%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="java语法"><a href="#java语法" class="headerlink" title="java语法"></a>java语法</h1><p>java语言特点： </p><ul><li><p>平台无关性：JVM</p></li><li><p>面向对象：</p><p>继承，封装，多态</p></li><li><p>支持多线程:</p><p>java的多线程是通过继承Thread类实现的，c++的多线程是通过引入std：：thread实现的</p></li><li><p>解释和编译共存</p></li></ul><h2 id="JVM-JDK-JRE的区别"><a href="#JVM-JDK-JRE的区别" class="headerlink" title="JVM,JDK,JRE的区别"></a>JVM,JDK,JRE的区别</h2><p>JVM：java虚拟机，java程序运行在java虚拟机上，因此可对不同的平台实现java程序，所以java语言能够实现跨平台</p><p>JDK: java development Kit&#x3D;jRE +JVM+开发工具</p><p>jre&#x3D;jvm+核心类库</p><p>跨平台的实现原理：java源代码被编译成字节码，字节码可以被翻译成机器能够识别的机器码。</p><p>所以我们要理解为什么字节码能够被虚拟机所识别:</p><p>以下是一段java代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后java代码被编译为Javac.c代码</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309241348919.png" alt="image-20230924134850731"></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>:  ldc           #<span class="number">2</span>                  <span class="comment">// String Hello, World!</span></span><br><span class="line"><span class="number">2</span>:  astore_1</span><br><span class="line"><span class="number">3</span>:  getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line"><span class="number">6</span>:  aload_1</span><br><span class="line"><span class="number">7</span>:  invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line"><span class="number">10</span>: <span class="keyword">return</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>字节码我觉得可以理解为汇编代码，就是中间代码。汇编代码也可以在不同的平台上执行。不同的平台安装对应的虚拟机，jvm将字节码翻译为二进制机器码，就可以实现java语言的平台无关性了</p><h2 id="java语言的编译与解释共存"><a href="#java语言的编译与解释共存" class="headerlink" title="java语言的编译与解释共存"></a>java语言的编译与解释共存</h2><p>编译型编程语言：源代码一次性翻译为可执行的机器代码</p><p>解释型编程语言：一行一行的解释成计价器代码</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309241400586.png" alt="image-20230924140033530"></p><p>java数据类型</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309241407585.png" alt="image-20230924140711529"></p><p>为什么在有的时候使用基本数据类型的时候一定要用它的包装类，而不使用他自己。</p><p>1.因为包装类提供一些方法，比如转化成String类型，Byte类型等，这些方法只有他的包装类型才有，它本书没有，这些方法可以很好的帮助我们去做转化</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309241419123.png" alt="image-20230924141900084"></p><p>2.java的一些繁星参数列表只有包装类型。比如list，set，map等</p><p>3.方法参数和返回值：如果一个方法需要进行一些特殊的处理或判断，或者需要返回一个整数，但是又需要保留null值的可能性，就可以使用Integer作为参数和返回值类型。</p><p>java可以自动对这些数据类型进拆箱和装箱</p><h2 id="自动转化类型，强制转化类型"><a href="#自动转化类型，强制转化类型" class="headerlink" title="自动转化类型，强制转化类型"></a>自动转化类型，强制转化类型</h2><p>自动转化，从小到大</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309241421151.png" alt="image-20230924142138116"></p><p>强制转化就是反过来</p><h2 id="amp-和-amp-amp-的区别"><a href="#amp-和-amp-amp-的区别" class="headerlink" title="&amp; 和&amp;&amp;的区别"></a>&amp; 和&amp;&amp;的区别</h2><p>&amp;和&amp;&amp;都要求两边是同时为真，但是</p><p>&amp;&amp;：短路与：左边为false时，就不会判断右边了</p><p>&amp;：逻辑与，左边为false时，还要继续判断右边</p><h2 id="break，continue，return的区别"><a href="#break，continue，return的区别" class="headerlink" title="break，continue，return的区别"></a>break，continue，return的区别</h2><p>break：跳出整个循环</p><p>continue： 跳出本次循环，继续执行下一次循环</p><p>return： 程序返回，不再执行下面的代码</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309241426441.png" alt="image-20230924142602402"></p><h2 id="java在处理自增增运算的时候和自我赋值操作时"><a href="#java在处理自增增运算的时候和自我赋值操作时" class="headerlink" title="java在处理自增增运算的时候和自我赋值操作时"></a>java在处理自增增运算的时候和自我赋值操作时</h2><p>是先付给一个临时变量，再自增增，自增增之后，再赋值回去，所以它的值不会发生变化</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309241427030.png" alt="image-20230924142737997"></p><h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><p>面向对象：把问题纷纷凝结成哥哥对象 —&gt;编年体</p><p>面向过程：把问题分解成步骤—&gt;纪传体</p><h2 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h2><ul><li>继承：使用已存在的类，定义新类过程，可以继承原类，继承原类的方法和属性</li><li>封装：指将数据和操作数据的方法封装在一个类中，对外部隐藏具体的实现细节，只暴露必要的接口供其他类使用。封装的目的是为了提高软件的可维护性、可扩展性和安全性</li><li>多态：一个统一的接口来处理不同类型的对象，使得不同的对象可以以一致的方式进行操作和使用。多态性能够增加代码的灵活性、可扩展性和可维护性。比如说向上转型，overwrite，继承关系等</li></ul><h1 id="Java基本语法"><a href="#Java基本语法" class="headerlink" title="Java基本语法"></a>Java基本语法</h1><h2 id="标识符与数据类型"><a href="#标识符与数据类型" class="headerlink" title="标识符与数据类型"></a>标识符与数据类型</h2><h6 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h6><p>java区分大小写，以分隔符”；“结束语句</p><p>java注释类型： &#x2F;&#x2F; &#x2F;* *&#x2F;</p><h6 id="java标识符的定义规则"><a href="#java标识符的定义规则" class="headerlink" title="java标识符的定义规则"></a>java标识符的定义规则</h6><p>标识符以字母，”-“或”$”开始的字符</p><p>数字不能作为标识符的第一个字符</p><p>标识符不能是java关键字</p><p>标识符大小写敏感，且长度没有限定</p><h5 id="访问修饰符-public，private，protected以及不写时的区别"><a href="#访问修饰符-public，private，protected以及不写时的区别" class="headerlink" title="访问修饰符 public，private，protected以及不写时的区别"></a>访问修饰符 public，private，protected以及不写时的区别</h5><table><thead><tr><th>可见性</th><th>private</th><th>default</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>同一个类</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>同一个包</td><td>×</td><td>√</td><td>√</td><td>√</td></tr><tr><td>子类当中</td><td>×</td><td>×</td><td>√</td><td>√</td></tr><tr><td>全局</td><td>×</td><td>×</td><td>×</td><td>√</td></tr></tbody></table><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>基本形式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K,V&gt;</span><br></pre></td></tr></table></figure><p>Map 是一个接口，我们不能直接创建对象，可以通过多态的形式创建对象，Map中有两个参数，一个是K表示键，一个是V表示值，且一个键有一个对应值，Map中不能包含重复键，如果有冲附件添加，会以最后一次键为准，而其他键会被覆盖。</p><p>Map分类</p><ul><li>HashMap</li><li>TreeMap</li></ul><h4 id="Map的基本功能"><a href="#Map的基本功能" class="headerlink" title="Map的基本功能"></a>Map的基本功能</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(key,value); <span class="comment">//添加键值对</span></span><br><span class="line">map.remove(key);<span class="comment">//删除键为key的键值对</span></span><br><span class="line">map.contains(key);<span class="comment">//判读map是否包含键</span></span><br><span class="line">map.contains(value);<span class="comment">//判断map是否包含值</span></span><br><span class="line">map.isEmpty();<span class="comment">//判断map是否为空</span></span><br><span class="line">map.size();<span class="comment">//求map的大小</span></span><br></pre></td></tr></table></figure><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309241924347.png" alt="image-20230924192425215"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">value=map.get(key);<span class="comment">//根据键获取值</span></span><br><span class="line">Set=map.keySet();<span class="comment">//获取所有键的集合</span></span><br><span class="line">Collection&lt;K&gt; collection=map.values()<span class="comment">//获取所有的值</span></span><br><span class="line"> Set&lt;Map.Entry&lt;k,V&gt;&gt;  entrySet  =map.entrySet();<span class="comment">//获取键值对对象的所有集合</span></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL--DQL</title>
      <link href="/2023/09/23/SQL-DQL/"/>
      <url>/2023/09/23/SQL-DQL/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL-–DQL"><a href="#SQL-–DQL" class="headerlink" title="SQL –DQL"></a>SQL –DQL</h2><h2 id="DQL介绍"><a href="#DQL介绍" class="headerlink" title="DQL介绍"></a>DQL介绍</h2><p>DQL是查询语句负责查询表中的业务</p><p>通常分为以下几类</p><ul><li><p>基本查询（不带任何条件）</p></li><li><p>条件查询（WHERE）</p></li><li><p>聚合函数（count、max、min、avg、sum）</p></li><li><p>分组查询（group by）</p></li><li><p>排序查询（order by）</p></li><li><p>分页查询（limit）</p><p>查询的语句语法是</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">字段列表</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">表名列表</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">条件列表</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">分组字段列表</span><br><span class="line"><span class="keyword">having</span></span><br><span class="line">分组后条件列表</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">排序字段列表</span><br><span class="line">limit</span><br><span class="line">分页参数</span><br><span class="line">```</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code> ## 基础查询</code></pre></li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure><p>为了实现这个我们创建了两个表：person_info,city。来存储信息</p><p>两张表创建完成之后，插入的信息如下</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231716676.png" alt="image-20230923171647645"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231707350.png" alt="image-20230923170734296"></p><p>我们从表中查询的语句如下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  字段名 <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure><ol><li>查询一张表中的所有字段，所有元组</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231719519.png" alt="image-20230923171925480"></p><p>然后就能看见表中的所有信息。</p><ol start="2"><li><p>查询表中的部分字段</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231722957.png" alt="image-20230923172217925"></p><p>查询过程中设置字段别名</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span> <span class="keyword">as</span> 别名 <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231726744.png" alt="image-20230923172611713"></p><p>查询过程中去除某行的重复记录</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 字段名  <span class="keyword">from</span> 表名;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231729361.png" alt="image-20230923172949331"></p><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><p>语法</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名 <span class="keyword">where</span> 条件列表 ;</span><br></pre></td></tr></table></figure><p>where当中是查询的条件</p><p>例子：</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231732215.png" alt="image-20230923173217173"></p><p>where当中就是查询的条件</p><p>条件比较运算符：</p><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt; 或者!&#x3D;</td><td>不等于</td></tr><tr><td>betw…and…</td><td>在某个范围</td></tr><tr><td>in</td><td>in之后的列表选一个</td></tr><tr><td>is null</td><td>是空值</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>AND</td><td>或 &amp;&amp; 并且 (多个条件同时成立)</td></tr><tr><td>OR</td><td>或</td></tr><tr><td>NOT</td><td>或 ! 非 , 不是</td></tr></tbody></table><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231737581.png" alt="image-20230923173737544"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231738136.png" alt="image-20230923173815109"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231739115.png" alt="image-20230923173933079"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231740966.png" alt="image-20230923174021930"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231740079.png" alt="image-20230923174032049"></p><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p>模糊查询中</p><p>“%”表示任意长度的字符或者数字</p><p>“-“表示任意一个字符或者数字</p><p>案例：查找表中任意一个名字为两个字符的元组</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231745389.png" alt="image-20230923174557350"></p><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>介绍：将一列数据作为一个整体，进行纵向计算</p><p>常见函数</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值（average）</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><p>案例</p><p>统计元组数量</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231749844.png" alt="image-20230923174953814"></p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231750192.png" alt="image-20230923175059153"></p><p>案例：统计员工的平均年龄，最大年龄，最小年龄，年龄之和</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231753944.png" alt="image-20230923175302911"></p><h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><p>分组查询是指根据一个或多个列的值将数据分组，并对每个组进行聚合计算的查询操作。分组查询通常与聚合函数（如SUM、AVG、COUNT等）一起使用，以对每个组的数据进行统计或计算。</p><p>案例：按照姓名字符数进行分组</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231759385.png" alt="image-20230923175921352"></p><p>其他案例</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231800867.png" alt="image-20230923180055829"></p><h2 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h2><p>语法</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名<span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span> 字段<span class="number">1</span> 排序方式一，字段<span class="number">2</span> 排序方式二</span><br></pre></td></tr></table></figure><p>排序方式分类</p><ul><li>desc 降序</li><li>asc 升序（默认）</li></ul><p>案例：查询所有员工，并且按照年龄降序方式排列</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231804835.png" alt="image-20230923180454791"></p><p>案例： 查询所有员工并且按照升序方式排列</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231805161.png" alt="image-20230923180535118"></p><p>其他案例</p><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231805443.png" alt="image-20230923180558410"></p><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>分页操作在业务系统开发时，也是非常常见的一个功能，我们在网站中看到的各种各样的分页条，后台<br>都需要借助于数据库的分页操作。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表名 limit 起始索引, 查询记录数 ;</span><br></pre></td></tr></table></figure><p><img src="https://content-1321156231.cos.ap-nanjing.myqcloud.com/202309231824793.png" alt="image-20230923182412754"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL--DDL</title>
      <link href="/2023/09/23/SQL-DDL/"/>
      <url>/2023/09/23/SQL-DDL/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL–DDL"><a href="#SQL–DDL" class="headerlink" title="SQL–DDL"></a>SQL–DDL</h1><div class="markmap-container" style="height:250px">  <svg data="{&quot;t&quot;:&quot;heading&quot;,&quot;d&quot;:1,&quot;p&quot;:{&quot;lines&quot;:[0,1]},&quot;v&quot;:&quot;sql-ddl&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[1,2]},&quot;v&quot;:&quot;创建&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[2,3]},&quot;v&quot;:&quot;数据库创建：create database 数据表名&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[3,6]},&quot;v&quot;:&quot;表格创建： create table person_info(&lt;br&gt;\nid int primary key comment &#39;工号&#39;,&lt;br&gt;\n...}&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[6,7]},&quot;v&quot;:&quot;删除&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[7,8]},&quot;v&quot;:&quot;删除数据库：drop database xxx;&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[8,9]},&quot;v&quot;:&quot;删除表格：drop table xxx；&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[9,10]},&quot;v&quot;:&quot;删除表格中某一行：alter table 表名 drop 字段名;&quot;}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[10,11]},&quot;v&quot;:&quot;修改&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[11,12]},&quot;v&quot;:&quot;修改表名数据库名：rename 原数据库名/原表明 to 新数据库名/新表名&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[12,13]},&quot;v&quot;:&quot;修改原数据库中的某一列&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[13,14]},&quot;v&quot;:&quot;alter table 表名 add 字段名 类型(长度) [comment 注释] [约束];&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[14,15]},&quot;v&quot;:&quot;alter table 表名 change 旧字段名 新字段名 类型(长度) [comment 注释] [约束];&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:7,&quot;p&quot;:{&quot;lines&quot;:[15,16]},&quot;v&quot;:&quot;alter table 表名 modify 字段名 新数据类型(长度);&quot;}]}]},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:3,&quot;p&quot;:{&quot;lines&quot;:[16,17]},&quot;v&quot;:&quot;展示数据库/表格&quot;,&quot;c&quot;:[{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[17,18]},&quot;v&quot;:&quot;展示数据库结构：show tables&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[18,19]},&quot;v&quot;:&quot;展示当前表格结构：desc table 表名&quot;},{&quot;t&quot;:&quot;list_item&quot;,&quot;d&quot;:5,&quot;p&quot;:{&quot;lines&quot;:[19,20]},&quot;v&quot;:&quot;展示当前数据库的创建语句： show create table 表名&quot;}]}]}"></svg></div><p>SQL程序语言有四种类型，对数据库的基本操作都属于这四类，它们分别为；数据定义语言(DDL)、数据查询语言（DQL）、数据操纵语言（DML）、数据控制语言（DCL）</p><p>创建表格之前需要先创建数据库，以下是对数据库操作的一些语言</p><h2 id="创建数据库，选择数据库，查看数据库"><a href="#创建数据库，选择数据库，查看数据库" class="headerlink" title="创建数据库，选择数据库，查看数据库"></a>创建数据库，选择数据库，查看数据库</h2><p>创建表格之前需要先选择数据库，然后创建数据库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show databases; #展示但所有数据库</span><br><span class="line">create database  person; #创建名叫person的数据库</span><br><span class="line">use person;#使用名叫person的数据库</span><br><span class="line">select database(); #查看当前所用的数据库</span><br></pre></td></tr></table></figure><h2 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h2><p>然后再创建数据库，语法如下，每行“,”结尾，然后创建完数据库之后以”；“结尾，数据库都是如此，语言以”，“好结尾</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table person_info( </span><br><span class="line">id int primary key comment &#x27;工号&#x27;,   </span><br><span class="line">name varchar(255) comment &#x27;员工姓名&#x27;,   </span><br><span class="line">age int comment &#x27;员工年龄&#x27;,   </span><br><span class="line">acount varchar(255) comment &#x27;员工账号&#x27; ,</span><br><span class="line">depart varchar(255) comment &#x27;员工部门&#x27;, </span><br><span class="line">position varchar(255) comment  &#x27;员工职位&#x27;</span><br><span class="line">); #创建数据库的信息</span><br></pre></td></tr></table></figure><p><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/1.png" alt="img"><br><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/2.png" alt="img"></p><p>然后有了表格，可以再创建一个和他有关联的表格 –&gt;<br> 注意自动增加列必须为主键，一个表格可以有多个主键，写多个主键的时候要采用符合主键的写法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table city</span><br><span class="line">(    id int auto_increment ,  </span><br><span class="line">depart varchar(255)  comment &#x27;部门&#x27;,  </span><br><span class="line">city varchar(255) comment &#x27;城市&#x27;,   </span><br><span class="line">primary key (id,depart)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="复合主键和普通主键的区别"><a href="#复合主键和普通主键的区别" class="headerlink" title="复合主键和普通主键的区别"></a><u>复合主键和普通主键的区别</u></h3><p>复合主键和普通主键都能唯一标识一组元组，复合主键查询成本更高</p><h3 id="设置表格与表格之间的外键"><a href="#设置表格与表格之间的外键" class="headerlink" title="设置表格与表格之间的外键"></a>设置表格与表格之间的外键</h3><p>外键的定义：<br>1.外键是某个表中的一列，它包含在另一个表的主键中。<br>2.外键也是索引的一种，是通过一张表中的一列指向另一张表中的主键，来对两张表进行关联。<br>3.一张表可以有一个外键，也可以存在多个外键，与多张表进行关联。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE 表名</span><br><span class="line">ADD CONSTRAINT FK_外键名称 FOREIGN KEY (列名) REFERENCES 另一张表名(另一张表的主键);</span><br><span class="line">alter table person_info add constraint p_d foreign key (depart) references  </span><br><span class="line">city(depart) ;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意添加数据时要先向主表中添加数据，在向从表中添加数据（reference当中必须有关联的数据）<br><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/3.png" alt="img"></p><h2 id="向表格当中添加数据"><a href="#向表格当中添加数据" class="headerlink" title="向表格当中添加数据"></a>向表格当中添加数据</h2><p><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/4.png" alt="img"></p><p>语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into person_info (id, name, age, acount, depart, position) values (&#x27;1&#x27;,&#x27;张三&#x27;,&#x27;15&#x27;, &#x27;215100&#x27;,&#x27;人力资源&#x27;,&#x27;经理&#x27;);</span><br><span class="line">insert into city(depart, city) values (&#x27;人力资源&#x27;,&#x27;西安&#x27;);</span><br></pre></td></tr></table></figure><h2 id="查询表结构"><a href="#查询表结构" class="headerlink" title="查询表结构"></a>查询表结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">desc 表名 查询表明</span><br><span class="line">desc person_info </span><br></pre></td></tr></table></figure><p><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/5.png" alt="img"></p><h2 id="查询表的创建语句"><a href="#查询表的创建语句" class="headerlink" title="查询表的创建语句"></a>查询表的创建语句</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show create table 表名</span><br><span class="line">show create table page_info</span><br></pre></td></tr></table></figure><p><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/6.png" alt="img"></p><h2 id="修改表的某一列"><a href="#修改表的某一列" class="headerlink" title="修改表的某一列"></a>修改表的某一列</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">alter table 表名 add  字段名  类型(长度)  [comment 注释]  [约束];</span><br><span class="line"></span><br><span class="line">alter table 表名 change  旧字段名  新字段名  类型(长度)  [comment 注释]  [约束];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">alter table 表名 modify  字段名  新数据类型(长度);</span><br></pre></td></tr></table></figure><p>注意：change 可以修改名字<br>modify 智能修改数据类型<br>这些修改都不能修改主键约束<br><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/7.png" alt="img"></p><p>删除表的某一列</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 drop 字段名;</span><br></pre></td></tr></table></figure><p><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/8.png" alt="img"></p><h2 id="删除表或者数据库"><a href="#删除表或者数据库" class="headerlink" title="删除表或者数据库"></a>删除表或者数据库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">drop  table [ if exists ]  表名;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">drop  database [ if exists ]  数据库名;</span><br></pre></td></tr></table></figure><p><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/9.png" alt="img"></p><p><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/10.png" alt="img"></p><h2 id="修改数据库或表格的名字"><a href="#修改数据库或表格的名字" class="headerlink" title="修改数据库或表格的名字"></a>修改数据库或表格的名字</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename 表格名/数据库名 to 新名字</span><br></pre></td></tr></table></figure><p><img src="https://img-1321156231.cos.ap-nanjing.myqcloud.com/13.png" alt="img"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA热部署</title>
      <link href="/2023/09/17/IDEA%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
      <url>/2023/09/17/IDEA%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="IDEA热部署"><a href="#IDEA热部署" class="headerlink" title="IDEA热部署"></a>IDEA热部署</h1><p>如何使得IDEA新建一个SpringBoot的时候如何一边写代码一边运行<br>（自动化完成重启）<br>解决办法：开发环境热部署<br>安装spring-boot-dev-tools<br><code>https://mvnrepository.com/</code></p><p>1.首先在pom.xml当中加入依赖</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-devtools --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.1.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.然后下载完毕之后，再在apllication当中增加配置<br>如果是yml文件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">    devtools:  </span><br><span class="line">        restart:   </span><br><span class="line">        enabled: true</span><br><span class="line">        additional-paths: src/main/java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果是propertites文件<br>就是</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.devtools.restart.enabled=true</span><br><span class="line">spring.devtools.addition-paths=src/main/java</span><br></pre></td></tr></table></figure><p>3.如果是eclipse软件，这样就行了。如果是IDEA软件，还需要<br>打开<br>File-&gt;settings-&gt;Build-&gt;Exceution-&gt;Deployment-&gt;Comple-&gt;勾选BUild project automatically<br>  4.快捷键<br>  ctr+shift+alt+&#x2F;<br> 打开registergouxuan<br> compler.automake.allow+&#x3D;.when.app.running</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享chatGPT二次开发应用</title>
      <link href="/2023/07/17/%E5%88%86%E4%BA%ABchatGPT%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/"/>
      <url>/2023/07/17/%E5%88%86%E4%BA%ABchatGPT%E4%BA%8C%E6%AC%A1%E5%BC%80%E5%8F%91%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="基于chatgpt的二次开发应用"><a href="#基于chatgpt的二次开发应用" class="headerlink" title="基于chatgpt的二次开发应用"></a>基于chatgpt的二次开发应用</h1><h2 id="秘塔写作猫"><a href="#秘塔写作猫" class="headerlink" title="秘塔写作猫"></a><a href="https://xiezuocat.com/">秘塔写作猫</a></h2><p>介绍：给标题直接进行写作，可用于水作业。比如一些水课的大作业。还有语法改错等</p><h2 id="未来百科"><a href="#未来百科" class="headerlink" title="未来百科"></a><a href="https://www.futurepedia.io/">未来百科</a></h2><p>介绍：会介绍一些基于AI二次开发的应用，<br>我觉得还不错，上面的一些工具都还挺有意思的</p><h2 id="一些读论文的工具"><a href="#一些读论文的工具" class="headerlink" title="一些读论文的工具"></a>一些读论文的工具</h2><p><a href="explainpaper.com">解释纸 </a><br><a href="Lateral.io">Lateral.io</a>)<br><a href="https://arxivxplorer.com/">搜索论文的工具</a><br><a href="https://www.chatpdf.com/">chatPDF</a></p><h2 id="更多的工具"><a href="#更多的工具" class="headerlink" title="更多的工具"></a>更多的工具</h2><p><a href="https://github.com/LangLangShanDeNanKe/chatgpt">点击链接1</a><br><a href="https://github.com/yzfly/awesome-chatgpt-zh">点击链接2</a><br>github上面分享的一些关于gpt二次开发的应用</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>today</title>
      <link href="/2023/03/29/today/"/>
      <url>/2023/03/29/today/</url>
      
        <content type="html"><![CDATA[<h1 id="TODAY"><a href="#TODAY" class="headerlink" title="TODAY"></a>TODAY</h1><p>今天也要好好学习<br>不管了，就这样吧。反正是试试。<br><a href="https://github.com/lhx715/lhx715.github.io/blob/master/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230329110638.jpg" title="无"><img src="/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230329110638.jpg" alt="无" title="无"></a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/03/27/hello-world/"/>
      <url>/2023/03/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
